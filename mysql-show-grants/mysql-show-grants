#!/usr/bin/perl

# mysql-show-grants canonicalizes and prints MySQL grants so you can effectively
# replicate, compare and version-control them.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use Term::ReadLine;

our $VERSION = '@VERSION@';

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my %opt_spec = (
   d => { s => 'database|d=s', r => 0, d => 'Database' },
   h => { s => 'host|h=s',     r => 0, d => 'Database server hostname' },
   l => { s => 'help',         r => 0, d => 'Show this help message' },
   P => { s => 'port|P=i',     r => 0, d => 'Database server port' },
   p => { s => 'pass|p=s',     r => 0, d => 'Database password' },
   u => { s => 'user|u=s',     r => 0, d => 'Database username' },
   #o => { s => 
);

# Define the order cmdline opts will appear in help output.  Add any extra ones
# defined above.  If it's not in this list, it's not an option to this
# program.  Note that 'h' is host and 'l' is help.
my @opt_keys = qw( h d P u p l );

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   d => '',
   h => '',
   P => 3306,
   p => undef,
   u => undef,
);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => \$opts{$_} }  @opt_keys );

if ( $opts{l} || grep { !$opts{$_} && $opt_spec{$_}->{r} } @opt_keys ) {
   print "Usage: $PROGRAM_NAME <options> batch-file\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
      $long  = "[no]$long" if $opt_spec{$key}->{s} =~ m/!/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME shows grants (user privileges) from a MySQL server.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# This will end up containing what's needed to connect to MySQL.
my $conn = {
   h  => $opts{h},
   db => $opts{d},
   u  => $opts{u},
   p  => $opts{p},
   P  => $opts{P},
};

if ( grep { !$conn->{$_} } keys %$conn ) {
   # Try to use the user's .my.cnf file.
   eval {
      my $homedir = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE};
      open my $conf_file, "<", "$homedir/.my.cnf" or die $OS_ERROR;
      while ( my $line = <$conf_file> ) {
         chomp $line;
         $line =~ s/(^\s*)|(\s*#.*$)//g;
         next unless $line;
         my ( $key, $val ) = split( /\s*=\s*/, $line );
         next unless defined $val;
         if ( $key eq 'host' )     { $conn->{h}  ||= $val; }
         if ( $key eq 'user' )     { $conn->{u}  ||= $val; }
         if ( $key =~ m/^pass/ )   { $conn->{p}  ||= $val; }
         if ( $key eq 'database' ) { $conn->{db} ||= $val; }
         if ( $key eq 'port' )     { $conn->{P}  ||= $val; }
      }
      close $conf_file;
   };
   if ( $EVAL_ERROR && $EVAL_ERROR !~ m/No such file/ ) {
      print "I tried to read your .my.cnf file, but got '$EVAL_ERROR'\n";
   }
}

# Fill in defaults for some things
$conn->{h} ||= 'localhost';
$conn->{u} ||= getlogin() || getpwuid($UID);

my %prompts = (
   P  => "Port number: ",
   h  => "Database host: ",
   u  => "Database user: ",
   p  => "Database password: ",
   db => "Database: ",
);

# If anything remains, prompt the terminal
my $term;
foreach my $thing ( grep { !defined $conn->{$_} } keys %$conn ) {
   $term ||= Term::ReadLine->new('terminal');
   $conn->{$thing} = $term->readline($prompts{$thing});
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my $dbh = DBI->connect(
   "DBI:mysql:database=$conn->{db};host=$conn->{h};port=$conn->{P}",
   $conn->{u}, $conn->{p}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

my $users = $dbh->selectall_arrayref(
   'SELECT DISTINCT User, Host FROM mysql.user ORDER BY User, Host',
   { Slice => {} });

foreach my $u (@$users) {
   my @grants = @{ $dbh->selectcol_arrayref(
      "SHOW GRANTS FOR '$u->{User}'\@'$u->{Host}'") };
   @grants = map {
      # Sort the actual grants lexically within each row for consistency.
      $_ =~ s/GRANT (.*?) ON (`|\*)/"GRANT " . join(', ', sort(split(', ', $1))) . " ON $2"/e;
      $_;
   } @grants;

   # Sort the grant rows for consistency too, but the one with the password
   # should always come first.
   @grants = sort {
      $b =~ m/IDENTIFIED BY/ <=> $a =~ m/IDENTIFIED BY/ || $a cmp $b
   } @grants;
   print join( "\n", "-- Grants for '$u->{User}'\@'$u->{Host}'", map {"$_;"} @grants ), "\n";
}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-show-grants - Canonicalize and print MySQL grants so you can effectively
replicate, compare and version-control them.

=head1 DESCRIPTION

mysql-show-grants extracts, orders, and then prints grants for MySQL user
accounts.

Why would you want this?  There are several reasons.

The first is to easily replicate users from one server to another; you can
simply extract the grants from the first server and pipe the output directly
into another server.

The second use is to place your grants into version control.  If you do a daily
automated grant dump into version control, you'll get lots of spurious
changesets for grants that don't change, because MySQL prints the actual grants
out in a seemingly random order.  For instance, one day it'll say

  GRANT DELETE, INSERT, UPDATE ON `test`.* TO 'foo'@'%';

And then another day it'll say

  GRANT INSERT, DELETE, UPDATE ON `test`.* TO 'foo'@'%';

The grants haven't changed, but the order has.  This script sorts the grants
within the line, between 'GRANT' and 'ON'.  If there are multiple rows from SHOW
GRANTS, it sorts the rows too, except that it always prints the row with the
user's password first, if it exists.  This removes three kinds of inconsistency
you'll get from running SHOW GRANTS, and avoids spurious changesets in version
control.

Finally, if you want to diff grants across servers, it will be hard without
"canonicalizing" them, which this script does.  The output is fully diff-able.

=cut
