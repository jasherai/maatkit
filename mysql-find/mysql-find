#!/usr/bin/perl

# This is mysql-find, a program to find tables and take actions like GNU find.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# TODO
# ############################################################################
# The following properties can be tested:
#         Version: 10
#      Row_format: Compact                    Row_format: Fixed
#  Avg_row_length: 0                      Avg_row_length: 0
#       Data_free: 0                           Data_free: 0
#  Auto_increment: NULL                   Auto_increment: NULL
#       Collation: latin1_swedish_ci
#        Checksum: NULL
#         Comment: InnoDB free: 4096 kB          Comment:

# ############################################################################
# Get configuration information.
# ############################################################################

# 'y' is the 'tYpe' of the option ('t' is generated later and used for something
# else).
my @opt_spec = (
   { s => 'case-insensitive',  y => 'o', d => 'Regular expression patterns ignore case' },
   { s => 'daystart',          y => 'o', d => 'Measure times from the beginning of the day' },
   { s => 'defaults-file|F=s', y => 'o', d => 'Only read default options from the given file' },
   { s => 'help',              y => 'o', d => 'Show this help message' },
   { s => 'password|p=s',      y => 'o', d => 'Password to use when connecting' },
   { s => 'port|P=i',          y => 'o', d => 'Port number to use for connection' },
   { s => 'quote!',            y => 'o', d => 'Quote database and table names (default)' },
   { s => 'socket|S=s',        y => 'o', d => 'Socket file to use for connection' },
   { s => 'user|u=s',          y => 'o', d => 'User for login if not current user' },
   { s => 'or',                y => 'o', d => 'Combine tests with OR, not AND' },

   { s => 'cmin=s',            y => 't', d => 'Table was created n minutes ago' },
   { s => 'ctime=s',           y => 't', d => 'Table was created n days ago' },
   { s => 'datasize=s',        y => 't', d => 'Table data uses n bytes of space' },
   { s => 'dblike=s',          y => 't', d => 'Database name matches SQL LIKE pattern' },
   { s => 'dbregex=s',         y => 't', d => 'Database name matches this pattern' },
   { s => 'empty',             y => 't', d => 'Table has no rows' },
   { s => 'engine=s',          y => 't', d => 'Table storage engine matches this pattern' },
   { s => 'indexsize=s',       y => 't', d => 'Table indexes use n bytes of space' },
   { s => 'kmin=s',            y => 't', d => 'Table was checked n minutes ago' },
   { s => 'ktime=s',           y => 't', d => 'Table was checked n days ago' },
   { s => 'mmin=s',            y => 't', d => 'Table was last modified n minutes ago' },
   { s => 'mtime=s',           y => 't', d => 'Table was last modified n days ago' },
   { s => 'pid=s',             y => 't', d => 'Table name has nonexistent MySQL connection ID' },
   { s => 'rows=s',            y => 't', d => 'Table has n rows' },
   { s => 'tablesize=s',       y => 't', d => 'Table (data+index) uses n bytes of space' },
   { s => 'tbllike=s',         y => 't', d => 'Table name matches SQL LIKE pattern' },
   { s => 'tblregex=s',        y => 't', d => 'Table name matches this pattern' },

   { s => 'exec=s',            y => 'a', d => 'Execute this SQL with each item found' },
   { s => 'exec_plus=s',       y => 'a', d => 'Execute this SQL with all items at once' },
   { s => 'print',             y => 'a', d => 'Print the database and table name' },
   { s => 'printf=s',          y => 'a', d => 'Print format, with escapes and directives' },
   # TODO: insert action (actually, that should just be exec)

);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ( quote => 1 );

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# ############################################################################
# Validate and expand arguments
# ############################################################################
foreach my $option (
      grep { defined $opts{$_} }
      qw(cmin ctime datasize indexsize kmin ktime mmin mtime rows tablesize) )
{
   if ( $opts{$option} && $opts{$option} !~ m/^[+-]?\d+[kMG]?$/ ) {
      warn "Invalid argument to --$option\n";
      $opts{help} = 1;
   }
   $opts{$option} = expand($opts{$option});
}

if ( $opts{pid} && $opts{pid} !~ m/\(\\d\+\)/ ) { # Ensure there is a capture group
   warn "--pid regex doesn't capture digits with (\\d+)\n";
   $opts{help} = 1;
}

if ( $opts{help} ) {
   print "Usage: mysql-find [option]... [database...]\n";
   my %sections = ( o => 'Options', t => 'Tests', a => 'Actions' );
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   foreach my $section ( qw(o t a) ) {
      print "\n$sections{$section}:\n";
      foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
         next unless $spec->{y} eq $section;
         my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
         my $short = $spec->{t} ? "-$spec->{t}" : '';
         printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
      }
   }

   print <<USAGE;

mysql-find finds MySQL tables and executes actions, like GNU find.  The default
action is to print the database and table name.  Connection options are read
from MySQL option files.  For more details, please read the documentation:

   perldoc mysql-find

USAGE
   exit(1);
}

# ############################################################################
# Lookup tables and global variables
# ############################################################################
my %time_for;     # Holds time constants for mmin, mtime etc
my %connections;  # Holds a list of thread IDs connected
my $dbh;          # This program's $dbh
my $this_pid;     # The thread ID of this program's $dbh
my %sth_for;      # Prepared $sths per-option, for exec etc
my %fmt_for;      # Interpolated things for printf

my %arg_for = (
   a => 'Auto_increment',
   A => 'Avg_row_length',
   c => 'Checksum',
   C => 'Create_time',
   D => 'Database',
   d => 'Data_length',
   E => 'Engine',
   F => 'Data_free',
   f => 'Innodb_free',
   I => 'Index_length',
   K => 'Check_time',
   L => 'Collation',
   M => 'Max_data_length',
   N => 'Name',
   O => 'Comment',
   P => 'Create_options',
   R => 'Row_format',
   S => 'Rows',
   T => 'Table_length',
   U => 'Update_time',
   V => 'Version',
);

# Functions to call while evaluating tests.
my %test_for = (
   cmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Create_time', 'cmin');
   },
   ctime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Create_time', 'ctime');
   },
   datasize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Data_length', $opts{datasize});
   },
   dbregex => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Database', $opts{dblike});
   },
   empty => sub {
      my ( $table ) = @_;
      return test_number($table, 'Rows', '0');
   },
   engine => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Engine', $opts{engine});
   },
   indexsize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Index_length', $opts{indexsize});
   },
   kmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Check_time', 'kmin');
   },
   ktime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Check_time', 'ktime');
   },
   mmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Update_time', 'mmin');
   },
   mtime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Update_time', 'mtime');
   },
   pid => sub {
      my ( $table ) = @_;

      #TODO document this my ( $process ) = $tbl =~ m/\D_(\d+)$/;
      my $test = $opts{'case-insensitive'} ? "(?i)$opts{pid}" : $opts{pid};
      my ( $pid ) = $table->{Name} =~ m/$test/;
      return $pid && $pid < $this_pid && !exists $connections{$pid};
   },
   rows => sub {
      my ( $table ) = @_;
      return test_number($table, 'Rows', $opts{rows});
   },
   tablesize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Table_length', $opts{tablesize});
   },
   tblregex => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Name', $opts{tblregex});
   },
);

# Functions to call when doing actions
my %action_for = (
   print => sub {
      my ( $table ) = @_;
      print "$table->{Database}.$table->{Name}\n";
   },
   exec => sub {
      my ( $table ) = @_;
      if ( !$sth_for{exec} ) {
         my $sql = $opts{exec};
      }
      # TODO
      die "exec: TODO\n";
   },
   printf => sub {
      my ( $table ) = @_;
      if ( !$fmt_for{printf} ) {
         my ($str, $arg_names) = interpolate($opts{printf});
         $fmt_for{printf} = { str => $str, arg_names => $arg_names };
      }
      printf($fmt_for{printf}->{str},
         map { defined $_ ? $_ : '' }
         @{$table}{@{$fmt_for{printf}->{arg_names}}});
   },
);

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(F h P S))
   . ';mysql_read_default_group=mysql';
$dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

# If no other action was given, the default action is to print.
if ( !grep { $opts{$_} } qw( exec exec_plus print printf ) ) {
   $opts{print} = 1;
}

# Figure out the time referred to by date/time options
my $basetime;
foreach my $option ( grep { defined $opts{$_} } qw(cmin ctime kmin ktime mmin mtime) ) {
   # Initialize a consistent point in time
   $basetime ||=
      $dbh->selectcol_arrayref(
         "SELECT " . ($opts{daystart} ? 'CURRENT_DATE' : 'CURRENT_TIMESTAMP')
      )->[0];

   my ($val) = $opts{$option} =~ m/(\d+)/;
   my $inter = $option =~ m/min/ ? 'MINUTE' : 'DAY';
   my $query = "SELECT DATE_SUB('$basetime', INTERVAL $val $inter)";
   $time_for{$option} = $dbh->selectcol_arrayref($query)->[0];
}

if ( $opts{pid} ) { # Fetch and save a list of processes currently running.
   $this_pid    = $dbh->{mysql_thread_id};
   %connections = map { $_ => 1 }
      @{$dbh->selectcol_arrayref('SHOW FULL PROCESSLIST')};
}

# ############################################################################
# Go do it.
# ############################################################################
my @databases = @ARGV         ? @ARGV
              : $opts{dblike} ? @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE ?', {}, $opts{dblike})}
              :                 @{$dbh->selectcol_arrayref('SHOW DATABASES')};

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if $database =~ m/^(?:information_schema|lost\+found)$/mi;

   my $sth = $opts{tbllike}
           ? $dbh->prepare("SHOW TABLE STATUS FROM `$database` LIKE ?")
           : $dbh->prepare("SHOW TABLE STATUS FROM `$database`");

   $sth->execute($opts{tbllike} || ());
   my @tables = @{$sth->fetchall_arrayref({})};

   # Make results uniform across MySQL versions, and generate additional
   # properties TODO document these properties.
   foreach my $table ( @tables ) {
      my ($ib_free) = $table->{Comment} =~ m/InnoDB free: (\d+) kB/;

      $table->{Database}       = $database;
      $table->{Engine}       ||= $table->{Type};
      $table->{Collation}    ||= 'latin1_swedish_ci';
      $table->{Table_length}   = ($table->{Index_length} || 0) + ($table->{Data_length} || 0);
      $table->{Innodb_free}    = defined $ib_free ? 1_024 * $ib_free : undef;

      delete $table->{Type};
   }

   # Apply the tests to find the matching tables
   @tables = grep {
      my $table = $_;
      my @tests = grep { $opts{$_} } keys %test_for;
      !@tests || ($opts{or} ? any($table, @tests) : all($table, @tests));
   } @tables;

   # Quote database and table names if desired
   if ( $opts{quote} ) {
      foreach my $table ( @tables ) {
         $table->{Database} = $dbh->quote_identifier($table->{Database});
         $table->{Name}     = $dbh->quote_identifier($table->{Name});
      }
   }

   # TODO: implement test_plus by saving to a global list.
   foreach my $table ( @tables ) {
      my @actions = grep { $opts{$_} } keys %action_for;
      foreach my $action ( @actions ) {
         $action_for{$action}->($table);
      }
   }
}

# ############################################################################
# Subroutines
# ############################################################################

# One test is true
sub any {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 1 if $test_for{$test}->($table);
   }
   return 0;
}

# All tests are true
sub all {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 0 unless $test_for{$test}->($table);
   }
   return 1;
}

# Checks the given property of the given table to see if it passes the test
sub test_number {
   my ( $table, $prop, $test ) = @_;
   my ($num) = $test =~ m/(\d+)/;
   return defined $table->{$prop} && (
         ( $test =~ m/-/  && $table->{$prop} < $num )
      || ( $test =~ m/\+/ && $table->{$prop} > $num )
      || (                   $table->{$prop} == $num ));
}

# Checks the given property of the given table to see if it passes the test
sub test_date {
   my ( $table, $prop, $test ) = @_;
   return defined $table->{$prop} && (
         ( $opts{$test} =~ m/-/ &&  $table->{$prop} gt $time_for{$test} )
      || ( $opts{$test} =~ m/\+/ && $table->{$prop} lt $time_for{$test} )
      || (                          $table->{$prop} eq $time_for{$test} ));
}

# Checks the given property of the given table to see if it passes the test
sub test_regex {
   my ( $table, $prop, $test ) = @_;
   if ( $opts{'case-insensitive'} ) {
      $test = "(?i)$test";
   }
   return defined $table->{$prop} && $table->{$prop} =~ m/$test/;
}

# Does string-interpolation and stuff.  Returns the string and a list of the
# properties that go into the resulting placeholders.
sub interpolate {
   my ( $str, $is_sql ) = @_;
   my @arg_names;

   # Replace arguments and keep track of which table properties go in which
   # placeholder.
   if ( $is_sql ) {
   # # TODO this is for sql $sql =~ s/%(.)/(exists $arg_for{$1} && push @arg_names, $1 ) ? '?' : "%$1"/xge;
   }
   else {
      $str =~ s/%(.)/(exists $arg_for{$1} && push @arg_names, $arg_for{$1} ) ? '\%s' : "%$1"/xge;
   }

   # Get Perl to interpolate escape sequences
   $str =~ s/(?<!\\)"/\\"/g;
   $str = eval qq{"$str"};
   return ( $str, \@arg_names );
}

sub expand {
   my ( $test ) = @_;
   my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
   my ($pre, $num, $factor) = $test =~ m/([+-])?(\d+)([kMG])?/;
   if ( $factor ) {
      $num *= $factor_for{$factor};
   }
   return "$pre$num";
}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-find - Foo foo

=head1 DESCRIPTION

=head1 OUTPUT

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI and DBD::mysql.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
