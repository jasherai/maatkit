#!/usr/bin/perl

# This is mysql-find, a program that searches for MySQL tables and takes actions
# like GNU find.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# TODO: Can I make % directives be replaced by %whatever while preserving
# formatting instructions?

# ############################################################################
# Get configuration information.
# ############################################################################

# 'y' is the 'tYpe' of the option ('t' is generated later and used for something
# else).
my @opt_spec = (
   { s => 'case-insensitive',  y => 'o', d => 'Regular expression patterns ignore case' },
   { s => 'daystart',          y => 'o', d => 'Measure times from the beginning of the day' },
   { s => 'defaults-file|F=s', y => 'o', d => 'Only read default options from the given file' },
   { s => 'help',              y => 'o', d => 'Show this help message' },
   { s => 'or',                y => 'o', d => 'Combine tests with OR, not AND' },
   { s => 'password|p=s',      y => 'o', d => 'Password to use when connecting' },
   { s => 'port|P=i',          y => 'o', d => 'Port number to use for connection' },
   { s => 'quote!',            y => 'o', d => 'Quote database and table names (default)' },
   { s => 'socket|S=s',        y => 'o', d => 'Socket file to use for connection' },
   { s => 'user|u=s',          y => 'o', d => 'User for login if not current user' },

   { s => 'autoinc=s',         y => 't', d => 'Table next AUTO_INCREMENT is n' },
   { s => 'avgrowlen=s',       y => 't', d => 'Table avg row len is n bytes' },
   { s => 'checksum=s',        y => 't', d => 'Table checksum is n' },
   { s => 'cmin=s',            y => 't', d => 'Table was created n minutes ago' },
   { s => 'collation=s',       y => 't', d => 'Table collation matches pattern' },
   { s => 'comment=s',         y => 't', d => 'Table comment matches pattern' },
   { s => 'createopts=s',      y => 't', d => 'Table create option matches pattern' },
   { s => 'ctime=s',           y => 't', d => 'Table was created n days ago' },
   { s => 'datasize=s',        y => 't', d => 'Table data uses n bytes of space' },
   { s => 'datafree=s',        y => 't', d => 'Table has n bytes of free space' },
   { s => 'dblike=s',          y => 't', d => 'Database name matches SQL LIKE pattern' },
   { s => 'dbregex=s',         y => 't', d => 'Database name matches this pattern' },
   { s => 'empty',             y => 't', d => 'Table has no rows' },
   { s => 'engine=s',          y => 't', d => 'Table storage engine matches this pattern' },
   { s => 'indexsize=s',       y => 't', d => 'Table indexes use n bytes of space' },
   { s => 'kmin=s',            y => 't', d => 'Table was checked n minutes ago' },
   { s => 'ktime=s',           y => 't', d => 'Table was checked n days ago' },
   { s => 'mmin=s',            y => 't', d => 'Table was last modified n minutes ago' },
   { s => 'mtime=s',           y => 't', d => 'Table was last modified n days ago' },
   { s => 'pid=s',             y => 't', d => 'Table name has nonexistent MySQL connection ID' },
   { s => 'rows=s',            y => 't', d => 'Table has n rows' },
   { s => 'rowformat=s',       y => 't', d => 'Table row format matches pattern' },
   { s => 'tablesize=s',       y => 't', d => 'Table (data+index) uses n bytes of space' },
   { s => 'tbllike=s',         y => 't', d => 'Table name matches SQL LIKE pattern' },
   { s => 'tblregex=s',        y => 't', d => 'Table name matches this pattern' },
   { s => 'version=s',         y => 't', d => 'Table version is n' },

   { s => 'exec=s',            y => 'a', d => 'Execute this SQL with each item found' },
   { s => 'exec_plus=s',       y => 'a', d => 'Execute this SQL with all items at once' },
   { s => 'print',             y => 'a', d => 'Print the database and table name' },
   { s => 'printf=s',          y => 'a', d => 'Print format, with escapes and directives' },

);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ( quote => 1 );

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# ############################################################################
# Validate and expand arguments
# ############################################################################
foreach my $option (
      grep { defined $opts{$_} }
      qw(cmin ctime datasize indexsize kmin ktime mmin mtime rows tablesize version) )
{
   if ( $opts{$option} && $opts{$option} !~ m/^[+-]?\d+[kMG]?$/ ) {
      warn "Invalid argument to --$option\n";
      $opts{help} = 1;
   }
   $opts{$option} = expand($opts{$option});
}

if ( $opts{pid} && $opts{pid} !~ m/\(\\d\+\)/ ) { # Ensure there is a capture group
   warn "--pid regex doesn't capture digits with (\\d+)\n";
   $opts{help} = 1;
}

my %arg_for = (
   a => 'Auto_increment',
   A => 'Avg_row_length',
   c => 'Checksum',
   C => 'Create_time',
   D => 'Database',
   d => 'Data_length',
   E => 'Engine',
   F => 'Data_free',
   f => 'Innodb_free',
   I => 'Index_length',
   K => 'Check_time',
   L => 'Collation',
   M => 'Max_data_length',
   N => 'Name',
   O => 'Comment',
   P => 'Create_options',
   R => 'Row_format',
   S => 'Rows',
   T => 'Table_length',
   U => 'Update_time',
   V => 'Version',
);

# Interpolate strings for printf and exec.  At the same time discover whether
# I must use SHOW TABLE STATUS (slower than SHOW TABLES) to fetch data.
my %fmt_for;  # Interpolated strings
my $showstat
   = grep { $opts{$_} } qw( 
      autoinc avgrowlen checksum cmin collation comment createopts ctime
      datasize datafree empty engine indexsize kmin ktime mmin mtime rows
      rowformat tablesize version);
foreach my $thing (qw(exec printf)) {
   next unless $opts{$thing};
   my ($str, $arg_names) = interpolate($opts{$thing});
   $fmt_for{$thing} = { str => $str, arg_names => $arg_names };
   if ( grep { $_ !~ m/^(Database|Name)$/ } @$arg_names ) {
      $showstat = 1;
   }
}

if ( $opts{help} ) {
   print "Usage: mysql-find [option]... [database...]\n";
   my %sections = ( o => 'Options', t => 'Tests', a => 'Actions' );
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   foreach my $section ( qw(o t a) ) {
      print "\n$sections{$section}:\n";
      foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
         next unless $spec->{y} eq $section;
         my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
         my $short = $spec->{t} ? "-$spec->{t}" : '';
         printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
      }
   }

   print <<USAGE;

mysql-find searches for MySQL tables and executes actions, like GNU find.  The
default action is to print the database and table name.  Connection options are
read from MySQL option files.  For more details, please read the documentation:

   perldoc mysql-find

USAGE
   exit(1);
}

# ############################################################################
# Lookup tables and global variables
# ############################################################################
my %time_for;     # Holds time constants for mmin, mtime etc
my %connections;  # Holds a list of thread IDs connected
my $dbh;          # This program's $dbh
my $this_pid;     # The thread ID of this program's $dbh

# Functions to call while evaluating tests.
my %test_for = (
   autoinc => sub {
      my ( $table ) = @_;
      return test_number($table, 'Auto_increment', $opts{autoinc});
   },
   avgrowlen => sub {
      my ( $table ) = @_;
      return test_number($table, 'Avg_row_length', $opts{avgrowlen});
   },
   checksum => sub {
      my ( $table ) = @_;
      return test_number($table, 'Checksum', $opts{checksum});
   },
   cmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Create_time', 'cmin');
   },
   collation => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Collation', $opts{collation});
   },
   comment => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Comment', $opts{comment});
   },
   createopts => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Create_options', $opts{createopts});
   },
   ctime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Create_time', 'ctime');
   },
   datafree => sub {
      my ( $table ) = @_;
      return test_number($table, 'Data_free', $opts{datafree});
   },
   datasize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Data_length', $opts{datasize});
   },
   dbregex => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Database', $opts{dblike});
   },
   empty => sub {
      my ( $table ) = @_;
      return test_number($table, 'Rows', '0');
   },
   engine => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Engine', $opts{engine});
   },
   indexsize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Index_length', $opts{indexsize});
   },
   kmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Check_time', 'kmin');
   },
   ktime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Check_time', 'ktime');
   },
   mmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Update_time', 'mmin');
   },
   mtime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Update_time', 'mtime');
   },
   pid => sub {
      my ( $table ) = @_;
      my $test = $opts{'case-insensitive'} ? "(?i)$opts{pid}" : $opts{pid};
      my ( $pid ) = $table->{Name} =~ m/$test/;
      return $pid && $pid < $this_pid && !exists $connections{$pid};
   },
   rows => sub {
      my ( $table ) = @_;
      return test_number($table, 'Rows', $opts{rows});
   },
   rowformat => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Row_format', $opts{rowformat});
   },
   tablesize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Table_length', $opts{tablesize});
   },
   tblregex => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Name', $opts{tblregex});
   },
   version => sub {
      my ( $table ) = @_;
      return test_number($table, 'Version', $opts{version});
   },
);

# Functions to call when doing actions
my %action_for = (
   print => sub {
      my ( $table ) = @_;
      print "$table->{Database}.$table->{Name}\n";
   },
   exec => sub {
      my ( $table ) = @_;
      my $sql = sprintf($fmt_for{exec}->{str},
         map { defined $_ ? $_ : '' }
         @{$table}{@{$fmt_for{exec}->{arg_names}}});
      $dbh->do($sql);
   },
   printf => sub {
      my ( $table ) = @_;
      printf($fmt_for{printf}->{str},
         map { defined $_ ? $_ : '' }
         @{$table}{@{$fmt_for{printf}->{arg_names}}});
   },
);

# Sanity check to catch misspellings...
foreach my $test ( keys %test_for, keys %action_for ) {
   die "No such option $test" unless grep { $_->{k} eq $test } @opt_spec;
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(F h P S))
   . ';mysql_read_default_group=mysql';
$dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

# If no other action was given, the default action is to print.
if ( !grep { $opts{$_} } qw( exec exec_plus print printf ) ) {
   $opts{print} = 1;
}

# Figure out the time referred to by date/time options
my $basetime;
foreach my $option ( grep { defined $opts{$_} } qw(cmin ctime kmin ktime mmin mtime) ) {
   # Initialize a consistent point in time
   $basetime ||=
      $dbh->selectcol_arrayref(
         "SELECT " . ($opts{daystart} ? 'CURRENT_DATE' : 'CURRENT_TIMESTAMP')
      )->[0];

   my ($val) = $opts{$option} =~ m/(\d+)/;
   my $inter = $option =~ m/min/ ? 'MINUTE' : 'DAY';
   my $query = "SELECT DATE_SUB('$basetime', INTERVAL $val $inter)";
   $time_for{$option} = $dbh->selectcol_arrayref($query)->[0];
}

# Fetch and save a list of processes currently running.
if ( $opts{pid} ) {
   # Ensure I have the PROCESS privilege.
   my $proc =
      grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
      @{$dbh->selectcol_arrayref('SHOW GRANTS')};
   if ( !$proc ) {
      die "--pid requires the PROCESS privilege for safety.\n";
   }

   # Get the data
   $this_pid    = $dbh->{mysql_thread_id};
   %connections = map { $_ => 1 }
      @{$dbh->selectcol_arrayref('SHOW FULL PROCESSLIST')};
}

# ############################################################################
# Go do it.
# ############################################################################
my @databases = @ARGV         ? @ARGV
              : $opts{dblike} ? @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE ?', {}, $opts{dblike})}
              :                 @{$dbh->selectcol_arrayref('SHOW DATABASES')};

my @exec_plus;
DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if $database =~ m/^(?:information_schema|lost\+found)$/mi;

   my $sta = $showstat ? ' STATUS' : 'S';
   my $sth = $opts{tbllike}
           ? $dbh->prepare("SHOW TABLE$sta FROM `$database` LIKE ?")
           : $dbh->prepare("SHOW TABLE$sta FROM `$database`");

   $sth->execute($opts{tbllike} || ());
   my @tables = @{$sth->fetchall_arrayref({})};

   # Make results uniform across MySQL versions, and generate additional
   # properties.
   foreach my $table ( @tables ) {
      if ( $showstat ) {
         my ($ib_free)            = $table->{Comment} && $table->{Comment} =~ m/InnoDB free: (\d+) kB/;
         $table->{Engine}       ||= $table->{Type};
         $table->{Table_length}   = ($table->{Index_length} || 0) + ($table->{Data_length} || 0);
         $table->{Innodb_free}    = $ib_free ? 1_024 * $ib_free : undef;
         delete $table->{Type};
      }
      else {
         my ($name) = values %$table;
         $table = { Name => $name };
      }
      $table->{Database} = $database;
   }

   # Apply the tests to find the matching tables
   @tables = grep {
      my $table = $_;
      my @tests = grep { $opts{$_} } keys %test_for;
      !@tests || ($opts{or} ? any($table, @tests) : all($table, @tests));
   } @tables;

   # Quote database and table names if desired
   if ( $opts{quote} ) {
      foreach my $table ( @tables ) {
         $table->{Database} = $dbh->quote_identifier($table->{Database});
         $table->{Name}     = $dbh->quote_identifier($table->{Name});
      }
   }

   foreach my $table ( @tables ) {
      my @actions = grep { $opts{$_} } keys %action_for;
      foreach my $action ( @actions ) {
         $action_for{$action}->($table);
      }
   }

   push @exec_plus, @tables;
}

# Handle exec_plus
if ( $opts{exec_plus} ) {
   my $table_list = join(', ', map { "$_->{Database}.$_->{Name}" } @exec_plus);
   (my $sql = $opts{exec_plus}) =~ s/%s/$table_list/g;
   $dbh->do($sql);
}

# ############################################################################
# Subroutines
# ############################################################################

# One test is true
sub any {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 1 if $test_for{$test}->($table);
   }
   return 0;
}

# All tests are true
sub all {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 0 unless $test_for{$test}->($table);
   }
   return 1;
}

# Checks the given property of the given table to see if it passes the test
sub test_number {
   my ( $table, $prop, $test ) = @_;
   my ($num) = $test =~ m/(\d+)/;
   return defined $table->{$prop} && (
         ( $test =~ m/-/  && $table->{$prop} < $num )
      || ( $test =~ m/\+/ && $table->{$prop} > $num )
      || (                   $table->{$prop} == $num ));
}

# Checks the given property of the given table to see if it passes the test
sub test_date {
   my ( $table, $prop, $test ) = @_;
   return defined $table->{$prop} && (
         ( $opts{$test} =~ m/-/  && $table->{$prop} gt $time_for{$test} )
      || ( $opts{$test} =~ m/\+/ && $table->{$prop} lt $time_for{$test} )
      || (                          $table->{$prop} eq $time_for{$test} ));
}

# Checks the given property of the given table to see if it passes the test
sub test_regex {
   my ( $table, $prop, $test ) = @_;
   if ( $opts{'case-insensitive'} ) {
      $test = "(?i)$test";
   }
   return defined $table->{$prop} && $table->{$prop} =~ m/$test/;
}

# Does string-interpolation and stuff.  Returns the string and a list of the
# properties that go into the resulting placeholders.
sub interpolate {
   my ( $str ) = @_;
   my @arg_names;

   # Replace % directives
   $str =~ s/%(.)/(exists $arg_for{$1} && push @arg_names, $arg_for{$1} ) ? '\%s' : "%$1"/xge;

   # Get Perl to interpolate escape sequences
   $str =~ s/(?<!\\)"/\\"/g;
   $str = eval qq{"$str"};
   return ( $str, \@arg_names );
}

sub expand {
   my ( $test ) = @_;
   my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
   my ($pre, $num, $factor) = $test =~ m/([+-])?(\d+)([kMG])?/;
   if ( $factor ) {
      $num *= $factor_for{$factor};
   }
   return "$pre$num";
}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-find - Find MySQL tables and execute actions, like GNU find.

=head1 DESCRIPTION

mysql-find looks for MySQL tables that pass the tests you specify, and executes
the actions you specify.  The default action is to print the database and table
name to STDOUT.

mysql-find is not as complicated as GNU find.  It doesn't allow you to specify
complicated expressions on the command line.  This is a good thing, in my
opinion.  I tried to make it useful AND usable.

Right now mysql-find only looks for and processes tables.  If you need it to do
other things, like triggers or columns, file a bug report and I'll add the
features.

mysql-find uses SHOW TABLES when possible, and SHOW TABLE STATUS when needed.

=head1 OPTIONS

There are three kinds of options: normal options, which determine some behavior
or setting; tests, which determine whether a table should be included in the
list of tables found; and actions, which do something to the tables mysql-find
finds.

=head2 OPTIONS

mysql-find uses standard Getopt::Long option parsing, so you should use double
dashes in front of long option names, unlike GNU find.

=over

=item --case-insensitive

Specifies that all regular expression searches are case-insensitive.

=item --daystart

Measure times (for --mmin, etc) from the beginning of today rather than from the
current time.

=item --defaults-file

If you specify this option, only this file is read for MySQL default options;
otherwise all the default files will be read.

=item --or

By default, tests are evaluated as though there were an AND between them.  This
option switches it to OR.

Option parsing is not implemented by mysql-find itself, so you cannot specify
complicated expressions with parentheses and mixtures of OR and AND.

=item --password

The password to use when connecting.

=item --port

The port number to use for the connection.

=item --quote

This option is enabled by default.  It quotes MySQL identifier names with
MySQL's standard backtick character.  Quoting happens after tests are run, and
before actions are run.

=item --socket

The socket file to use for the connection.

=item --user

The user for login if not the current user.

=back

=head2 TESTS

Most tests check some criterion against a column of SHOW TABLE STATUS output.
Numeric arguments can be specified as +n for greater than n, -n for less than n,
and n for exactly n.  All numeric options can take an optional suffix multiplier
of k, M or G (1_024, 1_048_576, and 1_073_741_824 respectively).  All patterns
are Perl regular expressions (see 'man perlre') unless specified as SQL LIKE
patterns.

Dates and times are all measured relative to the same instant, when mysql-find
first asks the database server what time it is.  All date and time manipulation
is done in SQL, so if you say to find tables modified 5 days ago, that
translates to SELECT DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 5 DAY).  If you
specify --daystart, if course it's relative to CURRENT_DATE instead.

However, table sizes and so forth are not consistent at an instant in time.  It
can take some time for MySQL to process all the SHOW TABLE STATUS queries, and
mysql-find can't do anything about that.  These measurements are as of the time
they're taken.

If you need some other tests, file a bug report and I'll enhance mysql-find for
you.

=over

=item --autoinc

Table's next AUTO_INCREMENT is n.  This tests the Auto_increment column.

=item --avgrowlen

Table avg row len is n bytes.  This tests the Avg_row_length column.

=item --checksum

Table checksum is n.  This tests the Checksum column.

=item --cmin

Table was created n minutes ago.  This tests the Create_time column.

=item --collation

Table collation matches pattern.  This tests the Collation column.

=item --comment

Table comment matches pattern.  This tests the Comment column.

=item --createopts

Table create option matches pattern.  This tests the Create_options column.

=item --ctime

Table was created n days ago.  This tests the Create_time column.

=item --datasize

Table data uses n bytes of space.  This tests the Data_length column.

=item --datafree

Table has n bytes of free space.  This tests the Data_free column.

=item --dblike

Database name matches SQL LIKE pattern.

=item --dbregex

Database name matches this pattern.

=item --empty

Table has no rows.  This tests the Rows column.

=item --engine

Table storage engine matches this pattern.  This tests the Engine column, or in
earlier versions of MySQL, the Type column.

=item --indexsize

Table indexes use n bytes of space.  This tests the Index_length column.

=item --kmin

Table was checked n minutes ago.  This tests the Check_time column.

=item --ktime

Table was checked n days ago.  This tests the Check_time column.

=item --mmin

Table was last modified n minutes ago.  This tests the Update_time column.

=item --mtime

Table was last modified n days ago.  This tests the Update_time column.

=item --pid

Table name has nonexistent MySQL connection ID.  This tests the table name for a
pattern.  The argument to this test must be a Perl regular expression that
captures digits like this: (\d+).  If the table name matches the pattern, these
captured digits are taken to be the MySQL connection ID of some process.  If the
connection is gone according to SHOW FULL PROCESSLIST, the test returns true.
If the connection ID is greater than mysql-find's own connection ID, mysql-find
ignores that table for safety.

Why would you want to do this?  If you use MySQL statement-based replication,
you probably know the trouble temporary tables can cause.  You might choose to
work around this by creating real tables with unique names, instead of temporary
tables.  One way to do this is to append your connection ID to the end of the
table, thusly: scratch_table_12345.  This assures that the table name is unique
and lets you have a way to find which connection it was associated with.  And
perhaps most importantly, if that connection no longer exists, you can assume
that the connection died without cleaning up its tables, and this table is a
candidate for removal.

This is the way I manage scratch tables, and that's why I included this test in
mysql-find.

The argument I use to --pid is "\D_(\d+)$".  That finds tables with a series of
numbers at the end, preceded by an underscore and some non-number character (the
latter criterion prevents me from examining tables with a date at the end, which
people tend to do: baron_scratch_2007_05_07 for example).  It's better to keep
the scratch tables separate of course.

If you do this, make sure the user mysql-find runs as has the PROCESS privilege!
Otherwise it will only see connections from the same user, and might think some
tables are ready to remove when they're still in use.  For safety, mysql-find
checks this for you.

=item --rows

Table has n rows.  This tests the Rows column.

=item --rowformat

Table row format matches pattern.  This tests the Row_format column.

=item --tablesize

Table (data+index) uses n bytes of space.  This tests the sum of the Data_length
and Index_length columns.

=item --tbllike

Table name matches SQL LIKE pattern.

=item --tblregex

Table name matches this pattern.

=item --version

Table version is n.  This tests the Version column.

=back

=head2 ACTIONS

Actions happen in an indeterminate order.  If you need determinism, file a bug
report and I'll add this feature.

=over

=item --exec

Execute this SQL with each item found.  The SQL can contain escapes and
formatting directives (see --printf).

=item --exec_plus

Execute this SQL with all items at once.  This option is unlike --exec.  There
are no escaping or formatting directives; there is only one special placeholder
for the list of database and table names, %s.  The list of tables found will be
joined together with commas and substituted wherever you place %s.

You might use this, for example, to drop all the tables you found:

   DROP TABLE %s

This is sort of like GNU find's "-exec command {} +" syntax.  Only it's not
totally cryptic.  And it doesn't require me to write a command-line parser.

=item --print

Print the database and table name, followed by a newline.  This is the default
action if no other action is specified.

=item --printf

Print format on the standard output, interpreting '\' escapes and '%'
directives.  Escapes are backslashed characters, like \n and \t.  Perl
interprets these, so you can use any escapes Perl knows about.  Directives are
replaced by %s, and as of this writing, you can't add any special formatting
instructions, like field widths or alignment (though I'm musing over ways to do
that).

Here is a list of the directives.  Note that most of them simply come from
columns of SHOW TABLE STATUS.  If the column is NULL or doesn't exist, you get
an empty string in the output.

   CHAR DATA SOURCE        NOTES
   ---- ------------------ ------------------------------------------
   a    Auto_increment
   A    Avg_row_length
   c    Checksum
   C    Create_time
   D    Database           The database name in which the table lives
   d    Data_length
   E    Engine             In older versions of MySQL, this is Type
   F    Data_free
   f    Innodb_free        Parsed from the Comment field
   I    Index_length
   K    Check_time
   L    Collation
   M    Max_data_length
   N    Name
   O    Comment
   P    Create_options
   R    Row_format
   S    Rows
   T    Table_length       Data_length+Index_length
   U    Update_time
   V    Version

=back

=head1 EXAMPLES

Find all tables created more than a day ago, which use the MyISAM engine, and
print their names:

  mysql-find --ctime +1 --engine MyISAM

Find InnoDB tables that haven't been updated in a month, and convert them to
MyISAM storage engine (data warehousing, anyone?):

  mysql-find --mtime +30 --engine InnoDB --exec "ALTER TABLE %D.%N ENGINE=MyISAM"

Find tables created by a process that no longer exists, following the name_pid
naming convention, and remove them.

  mysql-find --pid '\D_(\d+)$' --exec_plus "DROP TABLE %s"

Find empty tables in the test and junk databases, and delete them:

  mysql-find --empty junk test --exec_plus "DROP TABLE %s"

Find tables more than five gigabytes in total size:

  mysql-find --tablesize +5G

Find all tables and print their total data and index size, and sort largest
tables first (sort is a different program, by the way).

  mysql-find --printf "%T\t%D.%N\n" | sort -rn

As above, but this time, insert the data back into the database for posterity:

  mysql-find --noquote --exec "INSERT INTO sysdata.tblsize(db, tbl, size) VALUES('%D', '%N', %T)"

=head1 BUGS

Please report bugs, request features, discuss etc via the mailing lists, forums
and other tools at http://sourceforge.net/projects/mysqltoolkit.

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI and DBD::mysql.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
