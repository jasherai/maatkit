#!/usr/bin/perl

#            Name: t                                Name: foo
#          Engine: InnoDB                           Type: MyISAM
#         Version: 10
#      Row_format: Compact                    Row_format: Fixed
#            Rows: 0                                Rows: 0
#  Avg_row_length: 0                      Avg_row_length: 0
#     Data_length: 16384                     Data_length: 0
# Max_data_length: 0                     Max_data_length: 21474836479
#    Index_length: 0                        Index_length: 1024
#       Data_free: 0                           Data_free: 0
#  Auto_increment: NULL                   Auto_increment: NULL
#     Create_time: 2007-05-06 17:42:01       Create_time: 2007-04-08 17:23:29
#     Update_time: NULL                      Update_time: 2007-04-08 17:23:29
#      Check_time: NULL                       Check_time: NULL
#       Collation: latin1_swedish_ci
#        Checksum: NULL
#  Create_options:                        Create_options:
#         Comment: InnoDB free: 4096 kB          Comment:

# This is mysql-find, a program to find tables and take actions like GNU find.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my @opt_spec = (
   { s => 'daystart',          t => 'o', d => 'Measure times from the beginning of the day' },
   { s => 'defaults-file|F=s', t => 'o', d => 'Only read default options from the given file' },
   { s => 'help',              t => 'o', d => 'Show this help message' },
   { s => 'password|p=s',      t => 'o', d => 'Password to use when connecting' },
   { s => 'port|P=i',          t => 'o', d => 'Port number to use for connection' },
   { s => 'socket|S=s',        t => 'o', d => 'Socket file to use for connection' },
   { s => 'user|u=s',          t => 'o', d => 'User for login if not current user' },

   { s => 'empty',             t => 'c', d => 'Table has no rows' },
   { s => 'engine=s',          t => 'c', d => 'Table storage engine matches this pattern' },
   { s => 'tbllike=s',         t => 'c', d => 'Table name matches SQL LIKE pattern' },
   { s => 'dblike=s',          t => 'c', d => 'Database name matches SQL LIKE pattern' },
   { s => 'mmin=s',            t => 'c', d => 'Table was last modified n minutes ago' },
   { s => 'mtime=s',           t => 'c', d => 'Table was last modified n days ago' },
   { s => 'pid=s',             t => 'c', d => 'Table name has nonexistent MySQL connection ID' },
   { s => 'tblregex=s',        t => 'c', d => 'Table name matches this pattern' },
   { s => 'dbregex=s',         t => 'c', d => 'Database name matches this pattern' },
   { s => 'tablesize=s',       t => 'c', d => 'Table (data+index) uses n bytes of space' },
   { s => 'datasize=s',        t => 'c', d => 'Table (data+index) uses n bytes of space' },
   { s => 'indexsize=s',       t => 'c', d => 'Table (data+index) uses n bytes of space' },
   { s => 'rows=s',            t => 'c', d => 'Table (data+index) uses n bytes of space' },

   { s => 'exec=s',            t => 'a', d => 'Execute this SQL against each table' },
   { s => 'exec_plus=s',       t => 'a', d => 'Execute this SQL against all tables at once' },
   { s => 'print',             t => 'a', d => 'Print the database and table name' },

   { s => 'and',               t => 'e', d => 'AND conditions together' },
   { s => 'or',                t => 'e', d => 'OR conditions together' },
);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ();

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

if ( $opts{help} ) {
   print "Usage: mysql-find [option]... [database...]\n\n";
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

mysql-find finds MySQL tables and executes actions, like GNU find.  The default
action is to print the database and table name.  Connection options are read
from MySQL option files.  For more details, please read the documentation:

   perldoc mysql-find

USAGE
   exit(1);
}

# Post-post-process.
# If no other action was given, the default action is to print.
if ( !$opts{exec} && !$opts{exec_plus} ) {
   $opts{print} = 1;
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(F h P S))
   . ';mysql_read_default_group=mysql';
my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

my @databases = @ARGV         ? @ARGV
              : $opts{dblike} ? @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE ?', {}, $opts{dblike})}
              :                 @{$dbh->selectcol_arrayref('SHOW DATABASES')};

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if $database =~ m/^(?:information_schema|lost\+found)$/mi;

   my $sth = $opts{tbllike}
           ? $dbh->prepare("SHOW TABLE STATUS FROM `$database` LIKE ?")
           : $dbh->prepare("SHOW TABLE STATUS FROM `$database`");

   $sth->execute($opts{tbllike} || ());
   my @tables = @{$sth->fetchall_arrayref({})};

   # Make results uniform across MySQL versions
   foreach my $table ( @tables ) {
      $table->{Database}    = $dbh->quote_identifier($database);
      $table->{Name}        = $dbh->quote_identifier($table->{Name});
      $table->{Engine}    ||= $table->{Type};
      $table->{Collation} ||= 'latin1_swedish_ci';
      delete $table->{Type};
   }

   # TODO: apply matching rules
   do_actions(@tables);
}

sub do_actions {
   my ( @tables ) = @_;
   foreach my $table ( @tables ) {
      $opts{print} && do_print($table);
   }
}

sub do_print {
   my ( $table ) = @_;
   print "$table->{Database}.$table->{Name}\n";
}

__DATA__
   next DATABASE unless @tables;

   my %info_for;
   TABLE:
   foreach my $table ( @tables ) {
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || ( $opts{R} && $opts{R} eq "$database.$table" )
         || exists $opts{n}->{$table};

      # Get the table type, and a query to generate a checksum for it.
      my ( $engine, $query ) = checksum_query( $main_dbh, $database, $table );

      # Skip views, and tables of the wrong engine.
      next TABLE if
         $engine eq 'VIEW'
         || ( $opts{e} && !exists $opts{e}->{lc($engine)});
      $info_for{$table} = {
         database => $database,
         table    => $table,
         engine   => $engine,
         query    => $query,
      };

   }

   next DATABASE unless %info_for;

   # Design and print header
   my $hdr;
   if ( $opts{b} ) {
      $hdr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n";
   }
   else {
      my $max_tbl  = max(5, map { length($_) } keys %info_for);
      my $max_db   = max(8, length($database));
      my $max_host = max(4, map { length($_) } @hosts);
      $hdr         = "%-${max_db}s %-${max_tbl}s %-${max_host}s %-6s %10s %${crc_wid}s %4s %4s %4s %4s\n";
   }
   my @hdr_args = qw(DATABASE TABLE HOST ENGINE COUNT CHECKSUM TIME WAIT STAT LAG);
   printf($hdr, @hdr_args);

   TABLE:
   foreach my $table ( sort keys %info_for ) {

      if ( $opts{R} ) { # We're in --replicate mode.
         eval {
            do_tbl_replicate($hosts[0], $info_for{$table}, $hdr);
         };
         if ( $EVAL_ERROR ) {
            print STDERR $EVAL_ERROR, "\n";
            $exit_status = 1;
         }
         next TABLE;
      }

      # Lock table and get master position on the master, if applicable.
      $main_dbh->do("LOCK TABLES `$database`.`$table` READ") if $opts{k};
      if ( defined $opts{w} ) {
         my $master_status = $main_dbh->selectrow_hashref('SHOW MASTER STATUS');
         @{$info_for{$table}}{keys %$master_status} = values %$master_status;
      }

      my %children;
      foreach my $host ( @hosts ) {
         my $pid = @hosts > 1 ? fork() : undef;
         if ( @hosts == 1 || (defined($pid) && $pid == 0) ) { # I am a child
            eval {
               do_tbl($host, $info_for{$table}, $host eq $hosts[0], $hdr);
            };
            if ( $EVAL_ERROR ) {
               print STDERR $EVAL_ERROR, "\n";
               exit(1); # die, even if only a single host
            }
            exit(0) if @hosts > 1; # exit only if I'm a child
         }
         elsif ( @hosts > 1 && !defined($pid) ) {
            die("Unable to fork!");
         }
         # I already exited if I'm a child, so I'm the parent.
         $children{$host} = $pid if @hosts > 1;
      }

      # Wait for the children to exit.
      foreach my $host ( keys %children ) {
         my $pid = waitpid($children{$host}, 0);
         $exit_status = $CHILD_ERROR;
      }
      $main_dbh->do("UNLOCK TABLES") if $opts{k};
   }
}

   # Get a list of active connections
   my $processes = $dbh->selectall_hashref("show processlist", 'Id');
         # We only want tables whose name ends in digits NOT preceded by other
         # digits (for example, barontest_2006_12_06 should not be dropped).
         my ( $process ) = $tbl =~ m/\D_(\d+)$/;
         next unless $process;
         # If the process doesn't exist anymore, the table isn't in use.
         if ( !exists($processes->{$process} ) ) {
            print "Dropping table $db.$tbl\n" if $ENV{RKGDEBUG};
            $dbh->do("drop table if exists $db.$tbl");
         }
      }
   }


# ############################################################################
# Subroutines
# ############################################################################

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-stale-table-sniper - Find and possibly remove stale MySQL tables.

=head1 DESCRIPTION

=head1 OUTPUT

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI and DBD::mysql.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
