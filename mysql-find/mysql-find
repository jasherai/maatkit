#!/usr/bin/perl

#            Name: t                                Name: foo
#          Engine: InnoDB                           Type: MyISAM
#         Version: 10
#      Row_format: Compact                    Row_format: Fixed
#            Rows: 0                                Rows: 0
#  Avg_row_length: 0                      Avg_row_length: 0
#     Data_length: 16384                     Data_length: 0
# Max_data_length: 0                     Max_data_length: 21474836479
#    Index_length: 0                        Index_length: 1024
#       Data_free: 0                           Data_free: 0
#  Auto_increment: NULL                   Auto_increment: NULL
#     Create_time: 2007-05-06 17:42:01       Create_time: 2007-04-08 17:23:29
#     Update_time: NULL                      Update_time: 2007-04-08 17:23:29
#      Check_time: NULL                       Check_time: NULL
#       Collation: latin1_swedish_ci
#        Checksum: NULL
#  Create_options:                        Create_options:
#         Comment: InnoDB free: 4096 kB          Comment:

# This is mysql-find, a program to find tables and take actions like GNU find.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my @opt_spec = (
   { s => 'daystart',          t => 'o', d => 'Measure times from the beginning of the day' },
   { s => 'defaults-file|F=s', t => 'o', d => 'Only read default options from the given file' },
   { s => 'help',              t => 'o', d => 'Show this help message' },
   { s => 'password|p=s',      t => 'o', d => 'Password to use when connecting' },
   { s => 'port|P=i',          t => 'o', d => 'Port number to use for connection' },
   { s => 'socket|S=s',        t => 'o', d => 'Socket file to use for connection' },
   { s => 'user|u=s',          t => 'o', d => 'User for login if not current user' },
   { s => 'or',                t => 'o', d => 'OR conditions together' },

   { s => 'empty',             t => 'c', d => 'Table has no rows' },
   { s => 'engine=s',          t => 'c', d => 'Table storage engine matches this pattern' },
   { s => 'tbllike=s',         t => 'c', d => 'Table name matches SQL LIKE pattern' },
   { s => 'dblike=s',          t => 'c', d => 'Database name matches SQL LIKE pattern' },
   { s => 'mmin=s',            t => 'c', d => 'Table was last modified n minutes ago' },
   { s => 'mtime=s',           t => 'c', d => 'Table was last modified n days ago' },
   { s => 'pid=s',             t => 'c', d => 'Table name has nonexistent MySQL connection ID' },
   { s => 'tblregex=s',        t => 'c', d => 'Table name matches this pattern' },
   { s => 'dbregex=s',         t => 'c', d => 'Database name matches this pattern' },
   { s => 'tablesize=s',       t => 'c', d => 'Table (data+index) uses n bytes of space' },
   { s => 'datasize=s',        t => 'c', d => 'Table (data+index) uses n bytes of space' },
   { s => 'indexsize=s',       t => 'c', d => 'Table (data+index) uses n bytes of space' },
   { s => 'rows=s',            t => 'c', d => 'Table (data+index) uses n bytes of space' },

   { s => 'exec=s',            t => 'a', d => 'Execute this SQL against each table' },
   { s => 'exec_plus=s',       t => 'a', d => 'Execute this SQL against all tables at once' },
   { s => 'print',             t => 'a', d => 'Print the database and table name' },

);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ();

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# ############################################################################
# Validate arguments
# ############################################################################
foreach my $option ( qw(mmin mtime tablesize datasize indexsize rows) ) {
   if ( $opts{$option} && $opts{$option} !~ m/^[+-]?\d+[kMG]?$/ ) {
      warn "Invalid argument to --$option\n";
      $opts{help} = 1;
   }
}

if ( $opts{help} ) {
   print "Usage: mysql-find [option]... [database...]\n\n";
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

mysql-find finds MySQL tables and executes actions, like GNU find.  The default
action is to print the database and table name.  Connection options are read
from MySQL option files.  For more details, please read the documentation:

   perldoc mysql-find

USAGE
   exit(1);
}

# ############################################################################
# Lookup tables
# ############################################################################
my %time_for;

# Functions to call while evaluating tests.
my %test_for = (
   mmin => sub {
      my ( $table ) = @_;
      return defined $table->{Update_time} && (
            ( $opts{mmin} =~ m/-/ && $table->{Update_time} gt $time_for{mmin} )
         || ( $opts{mmin} =~ m/\+/ && $table->{Update_time} lt $time_for{mmin} )
         || ( $table->{Update_time} lt $time_for{mmin} ));
   },
);

# Functions to call when doing actions
my %action_for = (
   print => sub {
      my ( $table ) = @_;
      print "$table->{Database}.$table->{Name}\n";
   },
);

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(F h P S))
   . ';mysql_read_default_group=mysql';
my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

# If no other action was given, the default action is to print.
if ( !$opts{exec} && !$opts{exec_plus} ) {
   $opts{print} = 1;
}

# Figure out the time referred to by --mmin and --mtime options
foreach my $option ( grep { defined $opts{$_} } qw(mmin mtime) ) {
   my ($val) = $opts{$option} =~ m/(\d+)/;
   my $start = $opts{daystart}   ? 'CURRENT_DATE' : 'CURRENT_TIMESTAMP';
   my $inter = $option =~ m/min/ ? 'MINUTE'       : 'DAY';
   my $query = "SELECT DATE_SUB($start, INTERVAL $val $inter)";
   $time_for{$option} = $dbh->selectcol_arrayref($query)->[0];
}

my @databases = @ARGV         ? @ARGV
              : $opts{dblike} ? @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE ?', {}, $opts{dblike})}
              :                 @{$dbh->selectcol_arrayref('SHOW DATABASES')};

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if $database =~ m/^(?:information_schema|lost\+found)$/mi;

   my $sth = $opts{tbllike}
           ? $dbh->prepare("SHOW TABLE STATUS FROM `$database` LIKE ?")
           : $dbh->prepare("SHOW TABLE STATUS FROM `$database`");

   $sth->execute($opts{tbllike} || ());
   my @tables = @{$sth->fetchall_arrayref({})};

   # Make results uniform across MySQL versions
   foreach my $table ( @tables ) {
      $table->{Database}    = $dbh->quote_identifier($database);
      $table->{Name}        = $dbh->quote_identifier($table->{Name});
      $table->{Engine}    ||= $table->{Type};
      $table->{Collation} ||= 'latin1_swedish_ci';
      delete $table->{Type};
   }

   # Apply the tests to find the matching tables
   @tables = grep {
      my $table = $_;
      my @tests = grep { $opts{$_} } keys %test_for;
      !@tests || ($opts{or} ? any($table, @tests) : all($table, @tests));
   } @tables;

   foreach my $table ( @tables ) {
      foreach my $action ( keys %action_for ) {
         $action_for{$action}->($table);
      }
   }
}

# One test is true (see List::Util man page)
sub any {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 1 if $test_for{$test}->($table);
   }
   return 0;
}

# All tests are true (see List::Util man page)
sub all {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 0 unless $test_for{$test}->($table);
   }
   return 1;
}

__DATA__

   # Get a list of active connections
   my $processes = $dbh->selectall_hashref("show processlist", 'Id');
         # We only want tables whose name ends in digits NOT preceded by other
         # digits (for example, barontest_2006_12_06 should not be dropped).
         my ( $process ) = $tbl =~ m/\D_(\d+)$/;
         next unless $process;
         # If the process doesn't exist anymore, the table isn't in use.
         if ( !exists($processes->{$process} ) ) {
            print "Dropping table $db.$tbl\n" if $ENV{RKGDEBUG};
            $dbh->do("drop table if exists $db.$tbl");
         }
      }
   }


# ############################################################################
# Subroutines
# ############################################################################

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-stale-table-sniper - Find and possibly remove stale MySQL tables.

=head1 DESCRIPTION

=head1 OUTPUT

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI and DBD::mysql.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
