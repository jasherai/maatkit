#!/usr/bin/perl

# This is mysql-find, a program to find tables and take actions like GNU find.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# TODO
# ############################################################################
# The following properties can be put into conditions too:
#         Version: 10
#      Row_format: Compact                    Row_format: Fixed
#  Avg_row_length: 0                      Avg_row_length: 0
#       Data_free: 0                           Data_free: 0
#  Auto_increment: NULL                   Auto_increment: NULL
#       Collation: latin1_swedish_ci
#        Checksum: NULL
#         Comment: InnoDB free: 4096 kB          Comment:

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my @opt_spec = (
   { s => 'case-insensitive',  t => 'o', d => 'Regular expression patterns ignore case' },
   { s => 'daystart',          t => 'o', d => 'Measure times from the beginning of the day' },
   { s => 'defaults-file|F=s', t => 'o', d => 'Only read default options from the given file' },
   { s => 'help',              t => 'o', d => 'Show this help message' },
   { s => 'password|p=s',      t => 'o', d => 'Password to use when connecting' },
   { s => 'port|P=i',          t => 'o', d => 'Port number to use for connection' },
   { s => 'quote!',            t => 'o', d => 'Quote database and table names (default)' },
   { s => 'socket|S=s',        t => 'o', d => 'Socket file to use for connection' },
   { s => 'user|u=s',          t => 'o', d => 'User for login if not current user' },
   { s => 'or',                t => 'o', d => 'Combine conditions with OR, not AND' },

   { s => 'cmin=s',            t => 'c', d => 'Table was created n minutes ago' },
   { s => 'ctime=s',           t => 'c', d => 'Table was created n days ago' },
   { s => 'datasize=s',        t => 'c', d => 'Table data uses n bytes of space' },
   { s => 'dblike=s',          t => 'c', d => 'Database name matches SQL LIKE pattern' },
   { s => 'dbregex=s',         t => 'c', d => 'Database name matches this pattern' },
   { s => 'empty',             t => 'c', d => 'Table has no rows' },
   { s => 'engine=s',          t => 'c', d => 'Table storage engine matches this pattern' },
   { s => 'indexsize=s',       t => 'c', d => 'Table indexes use n bytes of space' },
   { s => 'kmin=s',            t => 'c', d => 'Table was checked n minutes ago' },
   { s => 'ktime=s',           t => 'c', d => 'Table was checked n days ago' },
   { s => 'mmin=s',            t => 'c', d => 'Table was last modified n minutes ago' },
   { s => 'mtime=s',           t => 'c', d => 'Table was last modified n days ago' },
   { s => 'pid=s',             t => 'c', d => 'Table name has nonexistent MySQL connection ID' },
   { s => 'rows=s',            t => 'c', d => 'Table has n rows' },
   { s => 'tablesize=s',       t => 'c', d => 'Table (data+index) uses n bytes of space' },
   { s => 'tbllike=s',         t => 'c', d => 'Table name matches SQL LIKE pattern' },
   { s => 'tblregex=s',        t => 'c', d => 'Table name matches this pattern' },

   { s => 'exec=s',            t => 'a', d => 'Execute this SQL against each table' },
   { s => 'exec_plus=s',       t => 'a', d => 'Execute this SQL against all tables at once' },
   { s => 'print',             t => 'a', d => 'Print the database and table name' },

);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ( quote => 1 );

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# ############################################################################
# Validate and expand arguments
# ############################################################################
foreach my $option (
      grep { defined $opts{$_} }
      qw(cmin ctime datasize indexsize kmin ktime mmin mtime rows tablesize) )
{
   if ( $opts{$option} && $opts{$option} !~ m/^[+-]?\d+[kMG]?$/ ) {
      warn "Invalid argument to --$option\n";
      $opts{help} = 1;
   }
   $opts{$option} = expand($opts{$option});
}

if ( $opts{pid} && $opts{pid} !~ m/\(\\d\+\)/ ) { # Ensure there is a capture group
   warn "--pid regex doesn't capture digits with (\\d+)\n";
   $opts{help} = 1;
}

if ( $opts{help} ) {
   print "Usage: mysql-find [option]... [database...]\n\n";
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

mysql-find finds MySQL tables and executes actions, like GNU find.  The default
action is to print the database and table name.  Connection options are read
from MySQL option files.  For more details, please read the documentation:

   perldoc mysql-find

USAGE
   exit(1);
}

# ############################################################################
# Lookup tables
# ############################################################################
my %time_for;
my %connections;
my $this_pid;

# Functions to call while evaluating tests.
my %test_for = (
   cmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Create_time', 'cmin');
   },
   ctime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Create_time', 'ctime');
   },
   datasize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Data_length', $opts{datasize});
   },
   dbregex => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Database', $opts{dblike});
   },
   empty => sub {
      my ( $table ) = @_;
      return test_number($table, 'Rows', '0');
   },
   engine => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Engine', $opts{engine});
   },
   indexsize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Index_length', $opts{indexsize});
   },
   kmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Check_time', 'kmin');
   },
   ktime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Check_time', 'ktime');
   },
   mmin => sub {
      my ( $table ) = @_;
      return test_date($table, 'Update_time', 'mmin');
   },
   mtime => sub {
      my ( $table ) = @_;
      return test_date($table, 'Update_time', 'mtime');
   },
   pid => sub {
      my ( $table ) = @_;

      #TODO my ( $process ) = $tbl =~ m/\D_(\d+)$/;
      my $test = $opts{'case-insensitive'} ? "(?i)$opts{pid}" : $opts{pid};
      my ( $pid ) = $table->{Name} =~ m/$test/;
      return $pid && $pid < $this_pid && !exists $connections{$pid};
   },
   rows => sub {
      my ( $table ) = @_;
      return test_number($table, 'Rows', $opts{rows});
   },
   tablesize => sub {
      my ( $table ) = @_;
      return test_number($table, 'Table_length', $opts{tablesize});
   },
   tblregex => sub {
      my ( $table ) = @_;
      return test_regex($table, 'Name', $opts{tblregex});
   },
);

# Functions to call when doing actions
my %action_for = (
   print => sub {
      my ( $table ) = @_;
      print "$table->{Database}.$table->{Name}\n";
   },
);

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(F h P S))
   . ';mysql_read_default_group=mysql';
my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

# If no other action was given, the default action is to print.
if ( !$opts{exec} && !$opts{exec_plus} ) {
   $opts{print} = 1;
}

# Figure out the time referred to by date/time options
my $basetime;
foreach my $option ( grep { defined $opts{$_} } qw(cmin ctime kmin ktime mmin mtime) ) {
   # Initialize a consistent point in time
   $basetime ||=
      $dbh->selectcol_arrayref(
         "SELECT " . ($opts{daystart} ? 'CURRENT_DATE' : 'CURRENT_TIMESTAMP')
      )->[0];

   my ($val) = $opts{$option} =~ m/(\d+)/;
   my $inter = $option =~ m/min/ ? 'MINUTE' : 'DAY';
   my $query = "SELECT DATE_SUB('$basetime', INTERVAL $val $inter)";
   $time_for{$option} = $dbh->selectcol_arrayref($query)->[0];
}

if ( $opts{pid} ) { # Fetch and save a list of processes currently running.
   $this_pid    = $dbh->{mysql_thread_id};
   %connections = map { $_ => 1 }
      @{$dbh->selectcol_arrayref('SHOW FULL PROCESSLIST')};
}

# ############################################################################
# Go do it.
# ############################################################################
my @databases = @ARGV         ? @ARGV
              : $opts{dblike} ? @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE ?', {}, $opts{dblike})}
              :                 @{$dbh->selectcol_arrayref('SHOW DATABASES')};

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if $database =~ m/^(?:information_schema|lost\+found)$/mi;

   my $sth = $opts{tbllike}
           ? $dbh->prepare("SHOW TABLE STATUS FROM `$database` LIKE ?")
           : $dbh->prepare("SHOW TABLE STATUS FROM `$database`");

   $sth->execute($opts{tbllike} || ());
   my @tables = @{$sth->fetchall_arrayref({})};

   # Make results uniform across MySQL versions
   foreach my $table ( @tables ) {
      $table->{Database}       = $database;
      $table->{Engine}       ||= $table->{Type};
      $table->{Collation}    ||= 'latin1_swedish_ci';
      $table->{Table_length}   = ($table->{Index_length} || 0) + ($table->{Data_length} || 0);
      delete $table->{Type};
   }

   # Apply the tests to find the matching tables
   @tables = grep {
      my $table = $_;
      my @tests = grep { $opts{$_} } keys %test_for;
      !@tests || ($opts{or} ? any($table, @tests) : all($table, @tests));
   } @tables;

   # Quote database and table names if desired
   if ( $opts{quote} ) {
      foreach my $table ( @tables ) {
         $table->{Database} = $dbh->quote_identifier($table->{Database});
         $table->{Name}     = $dbh->quote_identifier($table->{Name});
      }
   }

   foreach my $table ( @tables ) {
      foreach my $action ( keys %action_for ) {
         $action_for{$action}->($table);
      }
   }
}

# ############################################################################
# Subroutines
# ############################################################################

# One test is true
sub any {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 1 if $test_for{$test}->($table);
   }
   return 0;
}

# All tests are true
sub all {
   my ( $table, @tests ) = @_;
   foreach my $test ( @tests ) {
      return 0 unless $test_for{$test}->($table);
   }
   return 1;
}

# Checks the given property of the given table to see if it passes the test
sub test_number {
   my ( $table, $prop, $test ) = @_;
   my ($num) = $test =~ m/(\d+)/;
   return defined $table->{$prop} && (
         ( $test =~ m/-/  && $table->{$prop} > $num )
      || ( $test =~ m/\+/ && $table->{$prop} < $num )
      || (                   $table->{prop} == $num ));
}

# Checks the given property of the given table to see if it passes the test
sub test_date {
   my ( $table, $prop, $test ) = @_;
   return defined $table->{$prop} && (
         ( $opts{$test} =~ m/-/ &&  $table->{$prop} gt $time_for{$test} )
      || ( $opts{$test} =~ m/\+/ && $table->{$prop} lt $time_for{$test} )
      || (                          $table->{$prop} eq $time_for{$test} ));
}

# Checks the given property of the given table to see if it passes the test
sub test_regex {
   my ( $table, $prop, $test ) = @_;
   if ( $opts{'case-insensitive'} ) {
      $test = "(?i)$test";
   }
   return defined $table->{$prop} && $table->{$prop} =~ m/$test/;
}

{
   my %factor_for = (
      k => 1_024,
      M => 1_048_576,
      G => 1_073_741_824,
   );

   sub expand {
      my ( $test ) = @_;
      my ($pre, $num, $factor) = $test =~ m/([+-])?(\d+)([kMG])?/;
      if ( $factor ) {
         $num *= $factor_for{$factor};
      }
      return "$pre$num";
   }
}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-find - Foo foo

=head1 DESCRIPTION

=head1 OUTPUT

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI and DBD::mysql.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
