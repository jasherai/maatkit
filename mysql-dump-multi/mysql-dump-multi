#!/usr/bin/perl

# This is a program to run more than one thread of mysqldump in parallel.
#
# This program is copyright (c) 2007 Baron Schwartz.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use File::Basename qw(dirname);
use File::Spec;
use Getopt::Long;
use List::Util qw(max);
use POSIX;
use Term::ReadKey;

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", q$Revision: 859 $ =~ m/(\d+)/g);

# ############################################################################
# Get configuration information.
# ############################################################################

# TODO:
# flush-logs
# read sets of tables together from a table.
# Check a table for last-modified for each table.

my @opt_spec = (
   { s => 'basedir=s',         d => 'Base directory for files (default cwd)' },
   { s => 'binlogpos|b!',      d => 'Dump the master/slave position (default)' },
   { s => 'csv',               d => 'Dump data in CSV format (implies --schema --umask 0)' },
   { s => 'databases|d=s',     d => 'Only do this comma-separated list of databases' },
   { s => 'dbregex=s',         d => 'Database name matches this pattern' },
   { s => 'defaults-file|F=s', d => 'Only read default options from the given file' },
   { s => 'gzip!',             d => 'Compress files with gzip (default on non-Win32)' },
   { s => 'host|h=s',          d => 'Connect to host' },
   { s => 'help',              d => 'Show this help message' },
   { s => 'ignoredb|g=s',      d => 'Ignore this comma-separated list of databases' },
   { s => 'ignoretbl|n=s',     d => 'Ignore this comma-separated list of tables' },
   { s => 'lock|k!',           d => 'Use FLUSH TABLES WITH READ LOCK (default)' },
   { s => 'numthread|m=i',     d => 'Number of threads (default 2, or #CPUs on Linux)' },
   { s => 'opt!',              d => 'Use sensible mysqldump options (enabled by default)' },
   { s => 'password|p=s',      d => 'Password to use when connecting' },
   { s => 'port|P=i',          d => 'Port number to use for connection' },
   { s => 'quiet|q',           d => 'Do not print checksum results' },
   { s => 'schema!',           d => 'Dump schema separately' },
   { s => 'socket|S=s',        d => 'Socket file to use for connection' },
   { s => 'tables|t=s',        d => 'Only do this comma-separated list of tables' },
   { s => 'test',     ,        d => 'Print commands instead of executing them' },
   { s => 'tblregex=s',        d => 'Table name matches this pattern' },
   { s => 'umask=s',           d => 'Umask value, in octal' },
   { s => 'user|u=s',          d => 'User for login if not current user' },
   { s => 'version',           d => 'Output version information and exit' },
);

# Holds command-line options.
my %opts = (
   m       => 2,
   k       => 1,
   b       => 1,
   opt     => 1,
   gzip    => $OSNAME !~ m/Win32/,
   basedir => File::Spec->curdir(),
);

# Try to read --numthread from the number of CPUs in /proc/cpuinfo.  This only
# works on Linux.
eval {
   open my $file, "<", "/proc/cpuinfo"
      or die $OS_ERROR;
   local $INPUT_RECORD_SEPARATOR = undef;
   my $contents = <$file>;
   close $file;
   $opts{m} = scalar( map { $_ } $contents =~ m/(processor)/g );
};

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

my @mysqldump_args;
if ( grep { $_ eq '--' } @ARGV ) {
   # Remove options we DO NOT want THIS program to interpret.
   my $i = 0;
   while ( $i < @ARGV ) {
      last if $ARGV[$i++] eq '--';
   }

   @mysqldump_args = @ARGV[$i .. $#ARGV];
   pop @ARGV;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

$opts{basedir} = File::Spec->rel2abs($opts{basedir});

if ( $opts{csv} ) {
   if ( !defined $opts{schema} ) {
      $opts{schema} = 1;
   }
   if ( !defined $opts{umask} ) {
      $opts{umask} = 0;
   }
}

if ( defined $opts{umask} ) {
   umask oct($opts{umask});
}

# Decide on options to mysqldump.
if ( $opts{opt} && !@mysqldump_args ) {
   # Sensible defaults.
   @mysqldump_args = qw(
      --add-drop-table
      --add-locks
      --allow-keywords
      --comments
      --complete-insert
      --create-options
      --disable-keys
      --extended-insert
      --quick
      --quote-names
      --set-charset
      --skip-lock-tables
      --triggers
      --tz-utc
      %D
      %N
   );
   if ( $opts{gzip} ) {
      push @mysqldump_args, qw( | gzip -c - > ),
         filename('%D', "%N.sql.gz");
   }
   else {
      push @mysqldump_args,
         '--result-file=' . filename('%D', "%N.sql");
   }
}
elsif ( !@mysqldump_args ) {
   # If there was no -- marker in the arguments, whatever arguments are left go
   # to mysqldump.
   @mysqldump_args = @ARGV;
}

if ( $opts{version} ) {
   print "mysql-dump-multi  Ver $VERSION Distrib $DISTRIB Changeset $SVN_REV\n";
   exit(0);
}

if ( $opts{help} ) {
   print "Usage: mysql-dump-multi <options> [--] <mysqldump args>\n\n";
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
   }
   (my $usage = <<"   USAGE") =~ s/^      //gm;

      mysql-dump-multi does something or other.

      If possible, database options are read from your .my.cnf file.
      For more details, please read the documentation:

         perldoc mysql-dump-multi

   USAGE
   print $usage;
   exit(0);
}

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g} || '') };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n} || '') };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}

# ############################################################################
# Connect.
# ############################################################################
my %conn = (
   F => 'mysql_read_default_file',
   h => 'host',
   P => 'port',
   S => 'mysql_socket'
);

my $dbh = get_dbh();
$dbh->{InactiveDestroy} = 1; # Can't be set in $db_options
$dbh->{FetchHashKeyName} = 'NAME_lc'; # Lowercases all column names for fetchrow_hashref

# ############################################################################
# Lock the whole server.
# ############################################################################
if ( $opts{k} && !$opts{test} ) {
   $dbh->do('FLUSH TABLES WITH READ LOCK');
}

# ############################################################################
# Get the master position.
# ############################################################################
if ( $opts{b} && !$opts{test} ) {
   my $filename = filename('00_master_data.sql');
   makedir($filename);
   open my $file, ">", $filename or die $OS_ERROR;
   my %wanted = map { $_ => 1 }
      qw(file position master_host master_port master_log_file
      read_master_log_pos relay_log_file relay_log_pos relay_master_log_file
      exec_master_log_pos);

   my ( $master_pos, $slave_pos );
   eval {
      $master_pos = $dbh->selectrow_hashref('SHOW MASTER STATUS');
   };
   eval {
      $slave_pos = $dbh->selectrow_hashref('SHOW SLAVE STATUS');
      print $file "CHANGE MASTER TO MASTER_HOST='$slave_pos->{master_host}', "
                . "MASTER_LOG_FILE='$slave_pos->{master_log_file}', "
                . "MASTER_LOG_POS=$slave_pos->{read_master_log_pos}\n";
   };
   my %hash;
   foreach my $thing ( $master_pos, $slave_pos ) {
      next unless $thing;
      foreach my $key ( grep { $wanted{$_} } sort keys %$thing ) {
         print $file "-- $key $thing->{$key}\n";
      }
   }
   close $file or die $OS_ERROR;
}

my @databases = @{$dbh->selectcol_arrayref('SHOW DATABASES')};
my @work_to_do;
my %tables_for;

# ############################################################################
# Collect the list of databases and tables to do.
# ############################################################################
DATABASE:
foreach my $database ( @databases ) {
   $tables_for{$database} = [];
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || ( $opts{dbregex} && $database !~ m/$opts{dbregex}/ )
      || $database =~ m/^(information_schema|lost\+found)$/mi
      || exists $opts{g}->{$database};

   my @tables = @{$dbh->selectcol_arrayref("SHOW TABLES FROM `$database`")};
   next DATABASE unless @tables;

   TABLE:
   foreach my $table ( @tables ) {
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || ( $opts{tblregex} && $table !~ m/$opts{tblregex}/ )
         || ( $opts{R} && $opts{R} eq "$database.$table" )
         || exists $opts{n}->{$table};
      push @work_to_do, { D => $database, N => $table };
      push @{$tables_for{$database}}, $table;
   }
}

# Design header
my ( $maxdb, $maxtbl );
$maxdb  = max(8, map { length($_->{D}) } @work_to_do);
$maxtbl = max(5, map { length($_->{N}) } @work_to_do);
my $header = "%-${maxdb}s %-${maxtbl}s %5s %6s\n";
printf($header, qw(DATABASE TABLE TIME STATUS))
   unless $opts{q} || $opts{test};

# This signal handler will do nothing but wake up the sleeping parent process.
$SIG{CHLD} = sub {};

if ( $opts{schema} ) {
   # Dump the schema separately
   foreach my $database ( @databases ) {
      my @tables = @{$tables_for{$database}};
      next unless @tables;
      my @cmd = qw(
         mysqldump
         --no-data
         --add-drop-table
         --allow-keywords
         --comments
         --complete-insert
         --create-options
         --disable-keys
         --extended-insert
         --quick
         --quote-names
         --routines
         --set-charset
         --skip-lock-tables
         --triggers
         --tz-utc
      );
      push @cmd, $database, @tables;
      if ( $opts{gzip} ) {
         push @cmd, qw( | gzip -c - > );
         my $filename = filename($database, '00_schema.sql.gz');
         makedir($filename);
         push @cmd, $filename;
      }
      else {
         my $filename = filename($database, '00_schema.sql');
         makedir($filename);
         push @cmd, "--result-file=$filename";
      }

      if ( $opts{test} ) {
         print join(' ', @cmd), "\n";
      }
      else {
         system(join(' ', @cmd));
      }

   }
}

# ############################################################################
# Assign the work to child processes.  Initially just start --numthreads number
# of children.  Each child that exits will trigger a new one to start after
# that.  This is really a terrible hack -- I wish Perl had decent threading
# support so I could just queue work for a fixed pool of worker threads!
# ############################################################################
my %kids;
while ( @work_to_do || %kids ) {
   while ( @work_to_do && $opts{m} > keys %kids ) {
      my $todo = shift @work_to_do;
      $todo->{time} = time;
      my $pid = fork();
      die "Can't fork: $OS_ERROR" unless defined $pid;
      if ( $pid ) {
         # I'm the parent
         $kids{$pid} = $todo;
      }
      else {
         # I'm the child
         do_table($todo);
         exit(0);
      }
   }

   # Possibly wait for child, or just skip and start another
   my $reaped = 0;
   foreach my $pid ( keys %kids ) {
      my $kid = waitpid($pid, POSIX::WNOHANG);
      if ( $kid ) { # I reaped a child.
         my $stat = $CHILD_ERROR;
         my $todo = $kids{$kid};
         delete $kids{$kid};
         printf($header, $todo->{D}, $todo->{N}, (time - $todo->{time}), $stat)
            unless $opts{q} || $opts{test};
         $reaped = 1;
      }
   }

   if ( !$reaped ) {
      # Don't busy-wait.  But don't wait forever either, as a child may exit
      # and signal while we're not sleeping, so if we sleep forever we may
      # not get the signal.
      sleep(1);
   }
}

# ############################################################################
# Subroutines
# ############################################################################
sub do_table {
   my ( $todo ) = @_;
   if ( $opts{csv} ) {
      my $dbh  = get_dbh();
      my $filename = filename($todo->{D}, "$todo->{N}.csv");
      makedir($filename);
      my $sql  = qq{SELECT * INTO OUTFILE '$filename' }
               . qq{FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\\"' }
               . qq{LINES TERMINATED BY '\\n' FROM $todo->{D}.$todo->{N}};
      if ( $opts{test} ) {
         print $sql, "\n";
         if ( $opts{gzip} ) {
            print "gzip $filename\n";
         }
      }
      else {
         $dbh->do($sql);
         if ( $opts{gzip} ) {
            system("gzip $filename");
         }
      }
   }
   else {
      my @args = map { s/%([DN])/$todo->{$1}/g; $_; } @mysqldump_args;
      if ( @args && $args[0] !~ m/mysqldump/ ) {
         unshift @args, 'mysqldump';
      }
      if ( $opts{test} ) {
         print join(' ', @args), "\n";
      }
      else {
         system(join(' ', @args));
      }
   }
}

# Makes a filename.
sub filename {
   my $filename = File::Spec->catfile($opts{basedir}, @_);
   return $filename;
}

{
   # Memoize...
   my %dirs;

   # If the directory doesn't exist, makes the directory.
   sub makedir {
      my ( $filename ) = @_;
      my @dirs = File::Spec->splitdir(dirname($filename));
      foreach my $i ( 0 .. $#dirs ) {
         my $dir = File::Spec->catdir(@dirs[0 .. $i]);
         if ( !$dirs{$dir} ) {
            if ( ! -d $dir ) {
               mkdir($dir, 0777);
            }
            $dirs{$dir}++;
         }
      }
   }
}

sub get_dbh {
   my $dsn = 'DBI:mysql:;'
      . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(F h P S))
      . ';mysql_read_default_group=mysql';
   my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 0 } );
   return $dbh;
}

=pod

=head1 SYNOPSIS

  mysql-dump-multi -- '%D' '%N' \| gzip -c - \> '%D.%N.gz'

=head1 OUTPUT

  DATABASE TABLE                       TIME STATUS
  mysql    db                             0      0
  mysql    columns_priv                   0      0
  mysql    help_category                  0      0

=cut
