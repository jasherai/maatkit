The following items are unimplemented at this time:

   General:
      * add a --sudo option.  If commands such as dmidecode don't work, this
        option makes them retry with sudo.
   Operating System:
      * Are we inside a Virtual Machine like VMWare or VirtualBox?
      * Some Linux-specific parameters that we commonly check/tweak:
        - (others?)
      * use ethtool, ip, etc to discover nics, IP addresses and network speed
   Hardware
      * raid status: (is this working? over info to caputre?)
         - parse multiple adapters
      * check where MySQL data is stored, and make sure that filesystem is
        mounted with noatime.
   Operating System
      * vmstat samples
      * iostat usage if possible
   MySQL
      * for each instance, do:
         * run mysqld --help --verbose and make sure config file is valid
         * --log-warnings being defined is cause for an alert
         * Alert if the version is really old, or end-of-life.  3.x and 4.x are
           EOL now, and 4.1 should at least be >= 4.1.20 (the EOL and really-old
           warnings should be separate).  5.0.37 is the minimum useful 5.0
           version.
      * Data and schema
         * filefrag on data files?
         * verbose option: 
            produce a detailed per-db, per-tbl schema report showing size, index
            size, engine, number of indexes, number of columns etc for each
            table.  Maybe also mention unusual data types in the table, or a
            summary of the data types.  Also show triggers.
            * for datetime columns, check a naming convention and guess whether
            they can be timestamp instead.  'ts', 'created_at', 'last_updated'
            * For each table with an auto-inc PK and a timestamp, try to guess
               how many rows/day it grows, both overall and more recently, by
               splitting up and getting the timestamps at various points in th
               table.
            * Draw a histogram of these values.
      * Indexes:
         * Top N tables with the most/least indexes
         * Compute indexes that are not very selective
      * Storage engines
         * views
         * merge tables (how many are broken)
            * check if MERGE tables sum up the size of their contained tables in
              SHOW TABLE STATUS
            * look for this error in SHOW TABLE STATUS: Unable to open
              underlying table
         * partitioned tables
            * count of partitioned tables
            * look for partitioned tables that don't have many future partitions:
              ) ENGINE=InnoDB DEFAULT CHARSET=latin1 /*!50100 PARTITION BY RANGE
              (YEAR(day)) (PARTITION p_2006 VALUES LESS THAN (2007) ENGINE = InnoDB,
              PARTITION p_2007 VALUES LESS THAN (2008) ENGINE = InnoDB, PARTITION p_2008
              VALUES LESS THAN (2009) ENGINE = InnoDB, PARTITION p_catchall VALUES LESS
              THAN MAXVALUE ENGINE = InnoDB) */
      * Status
         * small innodb log files, large innodb_additional_mem_pool
         * on a slave, innodb_flush_log_at_trx_commit doesn't need to be 1
         * Watch prepared statements and compare to max
         * Watch for "bad query patterns" such as RAND() or storing IP addresses
         as varchar or using TO_DAYS(column) < TO_DAYS(NOW()) - 5
         * Actually, DATE_FORMAT(), or TO_DAYS() are just red flags
      * Connections and users
         * report anonymous users
         * report obsolete privileges (privs that refer to dbs or tables that
           don't exist)
         * aggregate a few processlist snapshots.  Print aggregates by Command
           and State, and by host.  Look for interesting things like
            * insert delayed
         * aggregate SHOW INNODB STATUS the same way.  A note on issue 1028 is a
         good example.
         * report master/slave status, how many slaves are attached and from
            where
      * After all the above, look at the error log and see if there are any
        errors caused by (for example) running SHOW STATUS.  Here is one
        possible error:
        080816  7:53:17080816  7:53:17 [ERROR] Cannot find table
        exampledb/exampletable from the internal data dictionary
        of InnoDB though the .frm file for the table exists. Maybe you
        have deleted and recreated InnoDB data files but have forgotten
        to delete the corresponding .frm files of InnoDB tables, or you
        have moved .frm files to another database?
        See http://dev.mysql.com/doc/refman/5.0/en/innodb-troubleshooting.html
        how you can resolve the problem.


   * Look at SHOW MASTER LOGS.  If there are any with 0 size, the user is
     deleting binlogs manually and that will screw up MySQL, warn about that.
   * Look for authenticating connections, extract the hostname, try to reverse
     lookup the DNS
   * Advise to use skip-name-resolve regardless...
   * tmp_table_size larger than max_heap_table_size is probably a mistake
   * look for innoDB free space vs. real space on disk to figure out how much is
     used.  Compare this to config file setting for buffer pool.
   * add mysqladmin -ext -i60 and put several samples side by side
   * add timestamps to all snapshots
   * check if if key_buffer and innodb_buffer_pool too big (big % of available
     memory or a lot of unused buffers).
   * check redundant indexes
   * alerts on COUNT(*) .. queries. 
   * guess from column names how they are related to other tables.  account_id
     can mean this column is a FK to an account table.  If so, check for
     NULL-ability vs. presence of NULL in the table
   * Look for tables that have silly schema, like a lot of varchar(255) Other
     common auto-generated length is varchar(50).  If many varchar have the same
     length, raise an alarm.  In fact, a schema-wide summary of data types and
     lengths, and the number of each, would be very useful.
   * Look for non-recommended data types, like float(M,N) and BIT.  Also any
     type that has a non-default display width: int([^11]) is a warning sign
     that they don't understand the display widths
   * If a table has two potential FK columns, like post_id and author_id, and at
     the same time has an autoinc PK, raise a notice that maybe the PK should be
     post_id,author_id.
   * if a table has one autoinc PK and another int UNIQUE, raise a notice that
     maybe it should drop the autoinc and promote the UNIQUE to PK.
   * for InnoDB tables, a key that has the PK appended is redundant.
   * pack_keys=1 is probably a mistake
   * tables that have only primary, unique, and one other key with many values
     are probably a mistake: the user probably thinks a key on (a,b,c) is enough
     for queries on any of those columns.
   * look for columns named UUID or GUID or session_id which may contain hex
     data stored as strings, which would be better stored unhexed in binary
   * Look for nullable columns that contain no NULLs, especially indexed columns
   * Automatically run PROCEDURE ANALYSE on tables that look bad.
   * Determine the thoroughness of the search by how large the DB/table is.
   * watch how much data InnoDB writes to the log files per second, recommend
     log buffer size.
   * report master/slave info: how many slaves are connected, what the master is
   * ondisk temp tables are min(temp_table_size, heap_table_size)
   * Figure out whether key_buffer is as big as it can be already, and alert
     that multiple buffers will have to be used.
   * Replication:
      * Look for temporary tables and warn about this (tmp table variable on a
        slave, or tmp table queries in the processlist).
      * Look for unsafe settings: binlog_do_db or binlog_ignore_db
      * Check for expire_logs_days policy
      * Check that the binlog.index file matches what's on disk
   * Parse db.tbl names out of statements in the processlist and make a list of
   the most popular dbs and tbls, in the format of a table, with the columns
   being ins/upd/del/sel/rep/other
   * deconstruct sprocs and explain them -- convert vars int @variables
   * Look for derived tables that have no aggregation inside them
   * Look for explain plans that have a bad ref type or not-full key usage or
   high number of rows or no 'ref'
   * Look for auto-increment locking in Innodb:
      *** (2) WAITING FOR THIS LOCK TO BE GRANTED:
      TABLE LOCK table `foo/bar` trx id 0 1313586251 lock mode AUTO-INC waiting
      TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH
