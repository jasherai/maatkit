The following items are unimplemented at this time:

   General:
      * add a --sudo option.  If commands such as dmidecode don't work, this
        option makes them retry with sudo.
   Operating System:
      * Are we inside a Virtual Machine like VMWare or VirtualBox?
      * Some Linux-specific parameters that we commonly check/tweak:
        - (others?)
      * use ethtool, ip, etc to discover nics, IP addresses and network speed
   Hardware
      * raid status: (is this working? over info to caputre?)
         - parse multiple adapters
      * check where MySQL data is stored, and make sure that filesystem is
        mounted with noatime.
   Operating System
      * vmstat samples
      * iostat usage if possible
   MySQL
      * for each instance, do:
         * run mysqld --help --verbose and make sure config file is valid
         * --log-warnings being defined is cause for an alert
      * Data and schema
         * filefrag on data files?
         * verbose option: 
            produce a detailed per-db, per-tbl schema report showing size, index
            size, engine, number of indexes, number of columns etc for each
            table.  Maybe also mention unusual data types in the table, or a
            summary of the data types.  Also show triggers.
            * for datetime columns, check a naming convention and guess whether
            they can be timestamp instead.  'ts', 'created_at', 'last_updated'
            * For each table with an auto-inc PK and a timestamp, try to guess
               how many rows/day it grows, both overall and more recently, by
               splitting up and getting the timestamps at various points in th
               table.
            * Draw a histogram of these values.
      * Indexes:
         * Top N tables with the most/least indexes
         * Compute indexes that are not very selective
      * Storage engines
         * views
         * merge tables (how many are broken)
            * check if MERGE tables sum up the size of their contained tables in
              SHOW TABLE STATUS
            * look for this error in SHOW TABLE STATUS: Unable to open
              underlying table
         * partitioned tables
            * count of partitioned tables
            * look for partitioned tables that don't have many future partitions:
              ) ENGINE=InnoDB DEFAULT CHARSET=latin1 /*!50100 PARTITION BY RANGE
              (YEAR(day)) (PARTITION p_2006 VALUES LESS THAN (2007) ENGINE = InnoDB,
              PARTITION p_2007 VALUES LESS THAN (2008) ENGINE = InnoDB, PARTITION p_2008
              VALUES LESS THAN (2009) ENGINE = InnoDB, PARTITION p_catchall VALUES LESS
              THAN MAXVALUE ENGINE = InnoDB) */
      * Status
         * small innodb log files, large innodb_additional_mem_pool
         * on a slave, innodb_flush_log_at_trx_commit doesn't need to be 1
         * Watch prepared statements and compare to max
         * Watch for "bad query patterns" such as RAND() or storing IP addresses
         as varchar or using TO_DAYS(column) < TO_DAYS(NOW()) - 5
      * Connections and users
         * report anonymous users
         * report obsolete privileges (privs that refer to dbs or tables that
           don't exist)
         * aggregate a few processlist snapshots.  Print aggregates by Command
           and State, and by host.  Look for interesting things like
            * insert delayed
         * aggregate SHOW INNODB STATUS the same way.  A note on issue 1028 is a
         good example.
         * report master/slave status, how many slaves are attached and from
            where

   * Look for authenticating connections, extract the hostname, try to reverse
     lookup the DNS
   * Advise to use skip-name-resolve regardless...
   * look for innoDB free space vs. real space on disk to figure out how much is
     used.  Compare this to config file setting for buffer pool.
   * add mysqladmin -ext -i60 and put several samples side by side
   * add timestamps to all snapshots
   * check if if key_buffer and innodb_buffer_pool too big (big % of available
     memory or a lot of unused buffers).
   * check redundant indexes
   * alerts on COUNT(*) .. queries. 
   * guess from column names how they are related to other tables.  account_id
     can mean this column is a FK to an account table.  If so, check for
     NULL-ability vs. presence of NULL in the table
   * Look for tables that have silly schema, like a lot of varchar(255) Other
     common auto-generated length is varchar(50).  If many varchar have the same
     length, raise an alarm.  In fact, a schema-wide summary of data types and
     lengths, and the number of each, would be very useful.
   * Look for non-recommended data types, like float(M,N) and BIT
   * If a table has two potential FK columns, like post_id and author_id, and at
     the same time has an autoinc PK, raise a notice that maybe the PK should be
     post_id,author_id.
   * if a table has one autoinc PK and another int UNIQUE, raise a notice that
     maybe it should drop the autoinc and promote the UNIQUE to PK.
   * for InnoDB tables, a key that has the PK appended is redundant.
   * look for columns named UUID or GUID or session_id which may contain hex
     data stored as strings, which would be better stored unhexed in binary
   * Look for nullable columns that contain no NULLs, especially indexed columns
   * Automatically run PROCEDURE ANALYSE on tables that look bad.
   * Determine the thoroughness of the search by how large the DB/table is.
   * watch how much data InnoDB writes to the log files per second, recommend
     log buffer size.
   * report master/slave info: how many slaves are connected, what the master is
   * ondisk temp tables are min(temp_table_size, heap_table_size)
   * Figure out whether key_buffer is as big as it can be already, and alert
     that multiple buffers will have to be used.
   * Replication:
      * Look for temporary tables and warn about this (tmp table variable on a
        slave, or tmp table queries in the processlist).
      * Look for unsafe settings: binlog_do_db or binlog_ignore_db
      * Check for expire_logs_days policy
      * Check that the binlog.index file matches what's on disk
   * Parse db.tbl names out of statements in the processlist and make a list of
   the most popular dbs and tbls, in the format of a table, with the columns
   being ins/upd/del/sel/rep/other
   * deconstruct sprocs and explain them -- convert vars int @variables
   * Look for derived tables that have no aggregation inside them
   * Look for explain plans that have a bad ref type or not-full key usage or
   high number of rows or no 'ref'
   * Look for auto-increment locking in Innodb:
      *** (2) WAITING FOR THIS LOCK TO BE GRANTED:
      TABLE LOCK table `foo/bar` trx id 0 1313586251 lock mode AUTO-INC waiting
      TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH
