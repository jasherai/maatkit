Debugging output when daemonizing, like mk-slave-restart has.

a tool to load tables/indexes into cache by the techniques Peter mentioned:
http://www.mysqlperformanceblog.com/2008/05/01/quickly-preloading-innodb-tables-in-the-buffer-pool/

Make mk-table-checksum checksum only newly inserted rows (as defined by the
checksum table).  Make it able to read from a table that defines tables to
checksum and the desired strategies.

Add a --charset option to all tools, like mk-table-sync has.

Add a --setvars option to all tools, so one can set wait_timeout etc.
Make it set the wait_timeout by default.

mk-log-server: start a server that can serve the given log files.

mysqldiff: http://www.adamspiers.org/computing/mysqldiff/
http://www.mysqldiff.org/
(mk-schema-sync or similar tool should be in SVN history)

query sniper:
   * http://www.stillhq.com/mysql/000008.html
   * Allow up to max_connections-X connections
   * Specify users/hosts NOT to kill (by default root/localhost)
   * http://google-mysql-tools.googlecode.com/svn/trunk/mypgrep.py

Log parsing and coloring:

   Swallow a log file and output only the selected fields.  This could be
   piped to a colorizer or pushed into mk-query-profiler.

   We need to update our slow-log tool to tell us the most recent time a query
   was executed

   Query rewriter: collapse INSERT ... VALUES (), (), (), ()..... to reduce the
   number of VALUES lists to just one, with a (VALUES_LIST_REPEATED) token after
   that.

A script to copy files in parallel with netcat.

#!/bin/bash

set -e
set -u

# #######################################################################
# Arguments
# #######################################################################
SRC=$1
DST=$2
SDIR=$3
DDIR=$4
EXCL=$5

running=0
port=12345

function copyfile () {
   file=$1;
   port=$2;
   echo "$file, $port";
   #(sleep 10; touch forked)&
   #while [ ! -e forked ]; do
      #echo "sleeping";
      #sleep 1;
   #done
   #rm forked
}

for file in `ssh $SRC "du $SDIR/*" | grep -v "'$EXCL'" | sort -nr | awk '{print $2}'`; do
   let port=port+1;
   copyfile $file $port;
done

Progress calculations:
   *  Look at PROCESSLIST, grab the query, EXPLAIN it, watch handlers, do the
   * the problem is really it only works for some query types 
   * If second query would be Ref for example you would not find it
   because you can't see first table Ref from second table Ref
   * But in particular case of FT Scan + bunch of refs it is very helpful
   * Yes, true: but, you could calculate from the rows and access types
   how many of each type of Handler operation you expect to see for the whole
   query, right?
   * It would be very hard to do for subqueries, though :)
   * what about progress for mysqldump ?
   * and reverse - mysql < from_dump.sql

Make visual-explain tell which columns are used in the index.

Advisor:
   mk-advisor
   * Look at 32-bit OS on 64-bit CPU.
   * Look for anomalies in variables/status
   * tell how many DBs, how many tables, total data/index size, summary of
     storage engines.
     * produce a detailed schema report showing size, index size, engine, number
       of indexes, number of columns etc for each table.  Maybe also mention
       unusual data types in the table, or a summary of the data types.
   * look for anonymous users
   * aggregate a few processlist snapshots.
   * look for weird values of all status and variables, like innodb_flush_method
     not set to O_DIRECT.
   * Look for authenticating connections, extract the hostname, try to reverse
     lookup the DNS, check for skip-name-resolve.
   * look for innoDB free space vs. real space on disk to figure out how much is
     used.  Compare this to config file setting for buffer pool.
   * look at vmstat, iostat
   * add mysqladmin -ext -i60
   * add timestamps to all snapshots
   * check if if key_buffer and innodb_buffer_pool too big (big % of available
     memory or a lot of unused buffers).
   * check redundant indexes
   * alerts on COUNT(*) .. queries. 
   * check if online settings out of sync with config file
   * Info "Key Buffer May be Too Large"
     $key_buffer_size>max($total_myisam_size,32M)
   * How to figure out the actual physical RAM
     <Aurimas> Baron: I would use dmidecode :)
     <Mushu> Baron: dmesg | grep Memory   ? :)
     <Aurimas> Baron: btw, server was booted normaly I think
     <Mushu> cat /proc/meminfo ?
     <Mushu> but meminfo is probably using that information anyway
     <Aurimas> Mushu: sometimes dmesg gets full of audit messages :)
     <Mushu> yup
     <Mushu> boot can be often found in /var/log logs too
     <Aurimas> Baron: regarding server - I found it booted in normal mode, but I
     think that's default ubuntu cd boot loader behaviour anyway
     <Baron> /proc/meminfo doesn't show the full physical RAM either
     <Baron> Aurimas, right I forgot that...
     <Mushu> so go with dmidecode as Aurimas said :)
     <Aurimas> Mushu: though it typically works better if you need to know how
     much memory is actually installed in the server (for example 32-bit OS
     without PXE support may hide it)
   * check if MERGE tables sum up the size of their contained tables in SHOW
     TABLE STATUS
   * report interesting parameters about MySQL, such as datadir
   * check ps -eaf and look for number of MySQL instances running, report memory
     usage, show pid file location and socket location.
   * look for insert delayed: there will be several of these
      *************************** 10. row ***************************
      Id: 549
      User: DELAYED
      Host: localhost
      db: policyd
      Command: Delayed insert
      Time: 140
      State: Waiting for INSERT
      Info: 
   * Look for tables that have silly schema, like a lot of varchar(255)
   * Use SHOW INDEX to compute indexes that are not very selective.
   * Automatically run PROCEDURE ANALYSE on tables that look bad.
   * Determine the thoroughness of the search by how large the DB/table is.
   * look for this error in SHOW TABLE STATUS: Unable to open underlying table
   * look for partitioned tables that don't have many future partitions:
     ) ENGINE=InnoDB DEFAULT CHARSET=latin1 /*!50100 PARTITION BY RANGE
     (YEAR(day)) (PARTITION p_2006 VALUES LESS THAN (2007) ENGINE = InnoDB,
     PARTITION p_2007 VALUES LESS THAN (2008) ENGINE = InnoDB, PARTITION p_2008
     VALUES LESS THAN (2009) ENGINE = InnoDB, PARTITION p_catchall VALUES LESS
     THAN MAXVALUE ENGINE = InnoDB) */
   * watch how much data InnoDB writes to the log files per second, recommend
     log buffer size.
   * aggregate the processlist by the host.
   * report master/slave info: how many slaves are connected, what the master is
   * report obsolete privileges (privs that refer to dbs or tables that don't
     exist)
