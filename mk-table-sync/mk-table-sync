#!/usr/bin/perl

# This program synchronizes data efficiently between two MySQL tables, which
# can be on different servers.
#
# This program is copyright (c) 2007 Baron Schwartz.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

# ###########################################################################
# OptionParser package 1344
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package OptionParser;

use Getopt::Long;
use List::Util qw(max);
use English qw(-no_match_vars);

sub new {
   my ( $class, @opts ) = @_;
   my %key_seen;
   my %long_seen;
   my %key_for;
   my %defaults;
   my @mutex;
   my @atleast1;
   my %long_for;
   my %disables;
   my %copyfrom;
   unshift @opts,
      { s => 'debug',   d => 'Set ENV{MKDEBUG} and enable debugging output' },
      { s => 'help',    d => 'Show this help message' },
      { s => 'version', d => 'Output version information and exit' };
   foreach my $opt ( @opts ) {
      if ( ref $opt ) {
         my ( $long, $short ) = $opt->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
         $opt->{k} = $short || $long;
         $key_for{$long} = $opt->{k};
         $long_for{$opt->{k}} = $long;
         $long_for{$long} = $long;
         $opt->{l} = $long;
         die "Duplicate option $opt->{k}" if $key_seen{$opt->{k}}++;
         die "Duplicate long option $opt->{l}" if $long_seen{$opt->{l}}++;
         $opt->{t} = $short;
         $opt->{n} = $opt->{s} =~ m/!/;
         $opt->{g} ||= 'o';
         if ( (my ($y) = $opt->{s} =~ m/=([mdHhAaz])/) ) {
            $ENV{MKDEBUG} && _d("Option $opt->{k} type: $y");
            $opt->{y} = $y;
            $opt->{s} =~ s/=./=s/;
         }
         if ( $opt->{d} =~ m/required/ ) {
            $opt->{r} = 1;
            $ENV{MKDEBUG} && _d("Option $opt->{k} is required");
         }
         if ( (my ($def) = $opt->{d} =~ m/default(?: ([^)]+))?/) ) {
            $defaults{$opt->{k}} = defined $def ? $def : 1;
            $ENV{MKDEBUG} && _d("Option $opt->{k} has a default");
         }
         if ( (my ($dis) = $opt->{d} =~ m/(disables .*)/) ) {
            $disables{$opt->{k}} = [ $class->get_participants($dis) ];
            $ENV{MKDEBUG} && _d("Option $opt->{k} $dis");
         }
      }
      else { # It's an instruction.

         if ( $opt =~ m/at least one|mutually exclusive|one and only one/ ) {
            my @participants = map {
                  die "No such option '$_' in $opt" unless $long_for{$_};
                  $long_for{$_};
               } $class->get_participants($opt);
            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
               push @mutex, \@participants;
               $ENV{MKDEBUG} && _d(@participants, ' are mutually exclusive');
            }
            if ( $opt =~ m/at least one|one and only one/ ) {
               push @atleast1, \@participants;
               $ENV{MKDEBUG} && _d(@participants, ' require at least one');
            }
         }
         elsif ( $opt =~ m/default to/ ) {
            my @participants = map {
                  die "No such option '$_' in $opt" unless $long_for{$_};
                  $key_for{$_};
               } $class->get_participants($opt);
            $copyfrom{$participants[0]} = $participants[1];
            $ENV{MKDEBUG} && _d(@participants, ' copy from each other');
         }

      }
   }

   foreach my $dis ( keys %disables ) {
      $disables{$dis} = [ map {
            die "No such option '$_' while processing $dis" unless $long_for{$_};
            $long_for{$_};
         } @{$disables{$dis}} ];
   }

   return bless {
      specs => [ grep { ref $_ } @opts ],
      notes => [],
      instr => [ grep { !ref $_ } @opts ],
      mutex => \@mutex,
      defaults => \%defaults,
      long_for => \%long_for,
      atleast1 => \@atleast1,
      disables => \%disables,
      key_for  => \%key_for,
      copyfrom => \%copyfrom,
      strict   => 1,
      groups   => [ { k => 'o', d => 'Options' } ],
   }, $class;
}

sub get_participants {
   my ( $self, $str ) = @_;
   my @participants;
   foreach my $thing ( $str =~ m/(--?[\w-]+)/g ) {
      if ( (my ($long) = $thing =~ m/--(.+)/) ) {
         push @participants, $long;
      }
      else {
         foreach my $short ( $thing =~ m/([^-])/g ) {
            push @participants, $short;
         }
      }
   }
   $ENV{MKDEBUG} && _d("Participants for $str: ", @participants);
   return @participants;
}

sub parse {
   my ( $self, %defaults ) = @_;
   my @specs = @{$self->{specs}};
   my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);

   my %opt_seen;
   my %vals = %{$self->{defaults}};
   @vals{keys %defaults} = values %defaults;
   foreach my $spec ( @specs ) {
      $vals{$spec->{k}} = undef unless defined $vals{$spec->{k}};
      $opt_seen{$spec->{k}} = 1;
   }

   foreach my $key ( keys %defaults ) {
      die "Cannot set default for non-existent option '$key'\n"
         unless $opt_seen{$key};
   }

   Getopt::Long::Configure('no_ignore_case', 'bundling');
   GetOptions( map { $_->{s} => \$vals{$_->{k}} } @specs )
      or $self->error('Error parsing options');

   if ( $vals{version} ) {
      my $prog = $self->prog;
      printf("%s  Ver %s Distrib %s Changeset %s\n",
         $prog, $main::VERSION, $main::DISTRIB, $main::SVN_REV);
      exit(0);
   }

   if ( $vals{debug} ) {
      $ENV{MKDEBUG} = 1;
   }

   if ( @ARGV && $self->{strict} ) {
      $self->error("Unrecognized command-line options @ARGV");
   }

   foreach my $dis ( grep { defined $vals{$_} } keys %{$self->{disables}} ) {
      my @disses = map { $self->{key_for}->{$_} } @{$self->{disables}->{$dis}};
      $ENV{MKDEBUG} && _d("Unsetting options: ", @disses);
      @vals{@disses} = map { undef } @disses;
   }

   foreach my $spec ( grep { $_->{r} } @specs ) {
      if ( !defined $vals{$spec->{k}} ) {
         $self->error("Required option --$spec->{l} must be specified");
      }
   }

   foreach my $mutex ( @{$self->{mutex}} ) {
      my @set = grep { defined $vals{$self->{key_for}->{$_}} } @$mutex;
      if ( @set > 1 ) {
         my $note = join(', ',
            map { "--$self->{long_for}->{$_}" }
                @{$mutex}[ 0 .. scalar(@$mutex) - 2] );
         $note .= " and --$self->{long_for}->{$mutex->[-1]}"
               . " are mutually exclusive.";
         $self->error($note);
      }
   }

   foreach my $required ( @{$self->{atleast1}} ) {
      my @set = grep { defined $vals{$self->{key_for}->{$_}} } @$required;
      if ( !@set ) {
         my $note = join(', ',
            map { "--$self->{long_for}->{$_}" }
                @{$required}[ 0 .. scalar(@$required) - 2] );
         $note .= " or --$self->{long_for}->{$required->[-1]}";
         $self->error("Specify at least one of $note");
      }
   }

   foreach my $spec ( grep { $_->{y} && defined $vals{$_->{k}} } @specs ) {
      my $val = $vals{$spec->{k}};
      if ( $spec->{y} eq 'm' ) {
         my ( $num, $suffix ) = $val =~ m/(\d+)([smhd])$/;
         if ( $suffix ) {
            $val = $suffix eq 's' ? $num            # Seconds
                 : $suffix eq 'm' ? $num * 60       # Minutes
                 : $suffix eq 'h' ? $num * 3600     # Hours
                 :                  $num * 86400;   # Days
            $vals{$spec->{k}} = $val;
            $ENV{MKDEBUG} && _d("Setting option $spec->{k} to $val");
         }
         else {
            $self->error("Invalid --$spec->{l} argument");
         }
      }
      elsif ( $spec->{y} eq 'd' ) {
         $ENV{MKDEBUG} && _d("Parsing option $spec->{y} as a DSN");
         my $from_key = $self->{copyfrom}->{$spec->{k}};
         my $default = {};
         if ( $from_key ) {
            $ENV{MKDEBUG} && _d("Option $spec->{y} DSN copies from option $from_key");
            $default = $self->{dsn}->parse($self->{dsn}->as_string($vals{$from_key}));
         }
         $vals{$spec->{k}} = $self->{dsn}->parse($val, $default);
      }
      elsif ( $spec->{y} eq 'z' ) {
         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
         if ( defined $num ) {
            if ( $factor ) {
               $num *= $factor_for{$factor};
               $ENV{MKDEBUG} && _d("Setting option $spec->{y} to num * factor");
            }
            $vals{$spec->{k}} = ($pre || '') . $num;
         }
         else {
            $self->error("Invalid --$spec->{l} argument");
         }
      }
   }

   foreach my $spec ( grep { $_->{y} } @specs ) {
      $ENV{MKDEBUG} && _d("Treating option $spec->{k} as a list");
      my $val = $vals{$spec->{k}};
      if ( $spec->{y} eq 'H' || (defined $val && $spec->{y} eq 'h') ) {
         $vals{$spec->{k}} = { map { $_ => 1 } split(',', ($val || '')) };
      }
      elsif ( $spec->{y} eq 'A' || (defined $val && $spec->{y} eq 'a') ) {
         $vals{$spec->{k}} = [ split(',', ($val || '')) ];
      }
   }

   return %vals;
}

sub error {
   my ( $self, $note ) = @_;
   $self->{__error__} = 1;
   push @{$self->{notes}}, $note;
}

sub prog {
   (my $prog) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
   return $prog || $PROGRAM_NAME;
}

sub prompt {
   my ( $self ) = @_;
   my $prog   = $self->prog;
   my $prompt = $self->{prompt} || '<options>';
   return "Usage: $prog $prompt\n";
}

sub descr {
   my ( $self ) = @_;
   my $prog = $self->prog;
   my $descr  = $prog . ' ' . ($self->{descr} || '')
          . "  For more details, please use the --help option, "
          . "or try 'perldoc $prog' for complete documentation.";
   $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
   $descr =~ s/ +$//mg;
   return $descr;
}

sub usage_or_errors {
   my ( $self, %opts ) = @_;
   if ( $opts{help} ) {
      print $self->usage(%opts);
      exit(0);
   }
   elsif ( $self->{__error__} ) {
      print $self->errors();
      exit(0);
   }
}

sub errors {
   my ( $self ) = @_;
   my $usage = $self->prompt() . "\n";
   if ( (my @notes = @{$self->{notes}}) ) {
      $usage .= join("\n  * ", 'Errors in command-line arguments:', @notes) . "\n";
   }
   return $usage . "\n" . $self->descr();
}

sub usage {
   my ( $self, %vals ) = @_;
   my @specs = @{$self->{specs}};

   my $maxl = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @specs);

   my $maxs = max(0,
      map { length($_->{l}) + ($_->{n} ? 4 : 0)}
      grep { $_->{t} } @specs);

   my $lcol = max($maxl, ($maxs + 3));
   my $rcol = 80 - $lcol - 6;
   my $rpad = ' ' x ( 80 - $rcol );

   $maxs = max($lcol - 3, $maxs);

   my $usage = $self->descr() . "\n" . $self->prompt();
   foreach my $g ( @{$self->{groups}} ) {
      $usage .= "\n$g->{d}:\n";
      foreach my $spec ( sort { $a->{l} cmp $b->{l} } grep { $_->{g} eq $g->{k} } @specs ) {
         my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
         my $short = $spec->{t};
         my $desc  = $spec->{d};
         $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
         $desc =~ s/ +$//mg;
         if ( $short ) {
            $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
         }
         else {
            $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
         }
      }
   }

   if ( (my @instr = @{$self->{instr}}) ) {
      $usage .= join("\n", map { "  $_" } @instr) . "\n";
   }
   if ( $self->{dsn} ) {
      $usage .= "\n" . $self->{dsn}->usage();
   }
   $usage .= "\nOptions and values after processing arguments:\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @specs ) {
      my $val   = $vals{$spec->{k}};
      my $type  = $spec->{y} || '';
      my $bool  = $spec->{s} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
      $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
                : !defined $val             ? '(No value)'
                : $type eq 'd'              ? $self->{dsn}->as_string($val)
                : $type =~ m/H|h/           ? join(',', sort keys %$val)
                : $type =~ m/A|a/           ? join(',', @$val)
                :                             $val;
      $usage .= sprintf("  --%-${lcol}s  %s\n", $spec->{l}, $val);
   }
   return $usage;
}

sub prompt_noecho {
   shift @_ if ref $_[0] eq __PACKAGE__;
   my ( $prompt ) = @_;
   local $OUTPUT_AUTOFLUSH = 1;
   print $prompt;
   my $response;
   eval {
      require Term::ReadKey;
      Term::ReadKey::ReadMode('noecho');
      chomp($response = <STDIN>);
      Term::ReadKey::ReadMode('normal');
      print "\n";
   };
   if ( $EVAL_ERROR ) {
      die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
   }
   return $response;
}

sub groups {
   my ( $self, @groups ) = @_;
   push @{$self->{groups}}, @groups;
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# OptionParser:$line ", @_, "\n";
}

1;

# ###########################################################################
# End OptionParser package
# ###########################################################################

# ###########################################################################
# Quoter package 1339
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package Quoter;

sub new {
   my ( $class ) = @_;
   bless {}, $class;
}

sub quote {
   my ( $self, @vals ) = @_;
   foreach my $val ( @vals ) {
      $val =~ s/`/``/g;
   }
   return join('.', map { '`' . $_ . '`' } @vals);
}

sub quote_val {
   my ( $self, @vals ) = @_;
   return join(', ',
      map {
         if ( defined $_ ) {
            $_ =~ s/'/\\'/g;
            $_ =~ m/\D/ ? "'$_'" : $_;
         }
         else {
            'NULL';
         }
      } @vals
   );
}

1;

# ###########################################################################
# End Quoter package
# ###########################################################################

# ###########################################################################
# DSNParser package 1345
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package DSNParser;

sub new {
   my ( $class, @opts ) = @_;
   my $self = {
      opts => {
         D => {
            desc => 'Database to use',
            dsn  => 'database',
            copy => 1,
         },
         F => {
            desc => 'Only read default options from the given file',
            dsn  => 'mysql_read_default_file',
            copy => 1,
         },
         h => {
            desc => 'Connect to host',
            dsn  => 'host',
            copy => 1,
         },
         p => {
            desc => 'Password to use when connecting',
            dsn  => 'password',
            copy => 1,
         },
         P => {
            desc => 'Port number to use for connection',
            dsn  => 'port',
            copy => 1,
         },
         S => {
            desc => 'Socket file to use for connection',
            dsn  => 'mysql_socket',
            copy => 1,
         },
         u => {
            desc => 'User for login if not current user',
            dsn  => 'user',
            copy => 1,
         },
      },
   };
   foreach my $opt ( @opts ) {
      $ENV{MKDEBUG} && _d('Adding extra property ' . $opt->{key});
      $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
   }
   return bless $self, $class;
}

sub prop {
   my ( $self, $prop, $value ) = @_;
   if ( @_ > 2 ) {
      $ENV{MKDEBUG} && _d("Setting $prop property");
      $self->{$prop} = $value;
   }
   return $self->{$prop};
}

sub parse {
   my ( $self, $dsn, $prev, $defaults ) = @_;
   if ( !$dsn ) {
      $ENV{MKDEBUG} && _d('No DSN to parse');
      return;
   }
   $ENV{MKDEBUG} && _d("Parsing $dsn");
   $prev     ||= {};
   $defaults ||= {};
   my %vals;
   my %opts = %{$self->{opts}};
   if ( $dsn !~ m/=/ && (my $p = $self->prop('autokey')) ) {
      $ENV{MKDEBUG} && _d("Interpreting $dsn as $p=$dsn");
      $dsn = "$p=$dsn";
   }
   my %hash = map { m/^(.)=(.*)$/g } split(/,/, $dsn);
   foreach my $key ( keys %opts ) {
      $ENV{MKDEBUG} && _d("Finding value for $key");
      $vals{$key} = $hash{$key};
      if ( !defined $vals{$key} && defined $prev->{$key} && $opts{$key}->{copy} ) {
         $vals{$key} = $prev->{$key};
         $ENV{MKDEBUG} && _d("Copying value for $key from previous DSN");
      }
      if ( !defined $vals{$key} ) {
         $vals{$key} = $defaults->{$key};
         $ENV{MKDEBUG} && _d("Copying value for $key from defaults");
      }
   }
   foreach my $key ( keys %hash ) {
      die "Unrecognized DSN part '$key' in '$dsn'\n"
         unless exists $opts{$key};
   }
   if ( (my $required = $self->prop('required')) ) {
      foreach my $key ( keys %$required ) {
         die "Missing DSN part '$key' in '$dsn'\n" unless $vals{$key};
      }
   }
   return \%vals;
}

sub as_string {
   my ( $self, $dsn ) = @_;
   return $dsn unless ref $dsn;
   return join(',',
      map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
      grep { defined $dsn->{$_} && $self->{opts}->{$_} }
      sort keys %$dsn );
}

sub usage {
   my ( $self ) = @_;
   my $usage
      = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n"
      . "  KEY  COPY  MEANING\n"
      . "  ===  ====  =============================================\n";
   my %opts = %{$self->{opts}};
   foreach my $key ( sort keys %opts ) {
      $usage .= "  $key    "
             .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
             .  ($opts{$key}->{desc} || '[No description]')
             . "\n";
   }
   if ( (my $key = $self->prop('autokey')) ) {
      $usage .= "  If the DSN is a bareword, the word is treated as the '$key' key.\n";
   }
   return $usage;
}

sub get_cxn_params {
   my ( $self, $info ) = @_;
   my $dsn;
   my %opts = %{$self->{opts}};
   my $driver = $self->prop('dbidriver') || '';
   if ( $driver eq 'Pg' ) {
      $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(h P));
   }
   else {
      $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(F h P S))
         . ';mysql_read_default_group=mysql';
   }
   $ENV{MKDEBUG} && _d($dsn);
   return ($dsn, $info->{u}, $info->{p});
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# DSNParser:$line ", @_, "\n";
}

1;

# ###########################################################################
# End DSNParser package
# ###########################################################################

# ###########################################################################
# VersionParser package 1344
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package VersionParser;

sub new {
   my ( $class ) = @_;
   bless {}, $class;
}

sub parse {
   my ( $self, $str ) = @_;
   my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
   $ENV{MKDEBUG} && _d("$str parses to $result");
   return $result;
}

sub version_ge {
   my ( $self, $dbh, $target ) = @_;
   if ( !$self->{$dbh} ) {
      $self->{$dbh} = $self->parse(
         $dbh->selectrow_array('SELECT VERSION()'));
   }
   my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
   $ENV{MKDEBUG} && _d("$self->{$dbh} ge $target: $result");
   return $result;
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# VersionParser:$line ", @_, "\n";
}

1;

# ###########################################################################
# End VersionParser package
# ###########################################################################

# ###########################################################################
# TableSyncStream package 1344
# ###########################################################################

use strict;
use warnings FATAL => 'all';

package TableSyncStream;

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(handler cols) ) {
      die "I need a $arg argument" unless defined $args{$arg};
   }
   return bless { %args }, $class;
}

sub get_sql {
   my ( $self, %args ) = @_;
   return "SELECT "
      . join(', ', map { $args{quoter}->quote($_) } @{$self->{cols}})
      . ' FROM ' . $args{quoter}->quote(@args{qw(database table)})
      . ' WHERE ' . ( $args{where} || '1=1' );
}

sub same_row {
   my ( $self, $lr, $rr ) = @_;
}

sub not_in_right {
   my ( $self, $lr ) = @_;
   $self->{handler}->change('INSERT', $lr, $self->key_cols());
}

sub not_in_left {
   my ( $self, $rr ) = @_;
   $self->{handler}->change('DELETE', $rr, $self->key_cols());
}

sub done_with_rows {
   my ( $self ) = @_;
   $self->{done} = 1;
}

sub done {
   my ( $self ) = @_;
   return $self->{done};
}

sub key_cols {
   my ( $self ) = @_;
   return $self->{cols};
}

sub prepare {
   my ( $self, $dbh ) = @_;
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# TableSyncStream:$line ", @_, "\n";
}

1;

# ###########################################################################
# End TableSyncStream package
# ###########################################################################

# ###########################################################################
# TableParser package 1348
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package TableParser;

sub new {
   bless {}, shift;
}

sub parse {
   my ( $self, $ddl, $opts ) = @_;

   if ( ref $ddl eq 'ARRAY' ) {
      if ( lc $ddl->[0] eq 'table' ) {
         $ddl = $ddl->[1];
      }
      else {
         return {
            engine => 'VIEW',
         };
      }
   }

   if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
      die "Cannot parse table definition; is ANSI quoting enabled or SQL_QUOTE_SHOW_CREATE disabled?";
   }

   my ( $engine ) = $ddl =~ m/\) (?:ENGINE|TYPE)=(\w+)/;
   $ENV{MKDEBUG} && _d('Storage engine: ', $engine);

   my @defs = $ddl =~ m/^(\s+`.*?),?$/gm;
   my @cols = map { $_ =~ m/`([^`]+)`/g } @defs;
   $ENV{MKDEBUG} && _d('Columns: ' . join(', ', @cols));

   my %def_for;
   @def_for{@cols} = @defs;

   my (@nums, @null);
   my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
   foreach my $col ( @cols ) {
      my $def = $def_for{$col};
      my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
      die "Can't determine column type for $def" unless $type;
      $type_for{$col} = $type;
      if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
         push @nums, $col;
         $is_numeric{$col} = 1;
      }
      if ( $def !~ m/NOT NULL/ ) {
         push @null, $col;
         $is_nullable{$col} = 1;
      }
      $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
   }

   my %keys;
   foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {

      if ( $engine !~ m/MEMORY|HEAP/ ) {
         $key =~ s/USING HASH/USING BTREE/;
      }

      my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
      my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
      $type = $type || $special || 'BTREE';
      if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
         && $engine =~ m/HEAP|MEMORY/i )
      {
         $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
      }

      my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
      my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
      my @cols   = grep { m/[^,]/ } split('`', $cols);
      $name      =~ s/`//g;
      $ENV{MKDEBUG} && _d("Index $name columns: " . join(', ', @cols));

      $keys{$name} = {
         colnames    => $cols,
         cols        => \@cols,
         unique      => $unique,
         is_col      => { map { $_ => 1 } @cols },
         is_nullable => scalar(grep { $is_nullable{$_} } @cols),
         type        => $type,
         name        => $name,
      };
   }

   return {
      cols           => \@cols,
      col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
      is_col         => { map { $_ => 1 } @cols },
      null_cols      => \@null,
      is_nullable    => \%is_nullable,
      is_autoinc     => \%is_autoinc,
      keys           => \%keys,
      defs           => \%def_for,
      numeric_cols   => \@nums,
      is_numeric     => \%is_numeric,
      engine         => $engine,
      type_for       => \%type_for,
   };
}

sub sort_indexes {
   my ( $self, $tbl ) = @_;
   my @indexes
      = sort {
         (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
         || ( !$tbl->{keys}->{$a}->{unique} <=> !$tbl->{keys}->{$b}->{unique} )
         || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
         || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      }
      grep {
         $tbl->{keys}->{$_}->{type} eq 'BTREE'
      }
      sort keys %{$tbl->{keys}};
   $ENV{MKDEBUG} && _d('Indexes sorted best-first: ' . join(', ', @indexes));
   return @indexes;
}

sub find_best_index {
   my ( $self, $tbl, $index ) = @_;
   my $best;
   if ( $index ) {
      ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
   }
   if ( !$best ) {
      if ( $index ) {
         die "Index '$index' does not exist in table";
      }
      else {
         ($best) = $self->sort_indexes($tbl);
      }
   }
   $ENV{MKDEBUG} && _d("Best index found is " . ($index || 'undef'));
   return $best;
}

sub find_possible_keys {
   my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
   return () unless $where;
   my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
      . ' WHERE ' . $where;
   $ENV{MKDEBUG} && _d($sql);
   my $expl = $dbh->selectrow_hashref($sql);
   $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
   if ( $expl->{possible_keys} ) {
      $ENV{MKDEBUG} && _d("possible_keys=$expl->{possible_keys}");
      my @candidates = split(',', $expl->{possible_keys});
      my %possible   = map { $_ => 1 } @candidates;
      if ( $expl->{key} ) {
         $ENV{MKDEBUG} && _d("MySQL chose $expl->{key}");
         unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
         $ENV{MKDEBUG} && _d('Before deduping: ' . join(', ', @candidates));
         my %seen;
         @candidates = grep { !$seen{$_}++ } @candidates;
      }
      $ENV{MKDEBUG} && _d('Final list: ' . join(', ', @candidates));
      return @candidates;
   }
   else {
      $ENV{MKDEBUG} && _d('No keys in possible_keys');
      return ();
   }
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# TableParser:$line ", @_, "\n";
}

1;

# ###########################################################################
# End TableParser package
# ###########################################################################

# ###########################################################################
# RowDiff package 1344
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package RowDiff;

sub new {
   my ( $class, %args ) = @_;
   die "I need a dbh" unless $args{dbh};
   my $self = \%args;
   return bless $self, $class;
}

sub compare_sets {
   my ( $self, %args ) = @_;
   my ( $left, $right, $syncer, $tbl )
      = @args{qw(left right syncer tbl)};

   my ($lr, $rr);       # Current row from the left/right sources.

   do {

      if ( !$lr && $left->{Active} ) {
         $ENV{MKDEBUG} && _d('Fetching row from left');
         $lr = $left->fetchrow_hashref;
      }
      if ( !$rr && $right->{Active} ) {
         $ENV{MKDEBUG} && _d('Fetching row from right');
         $rr = $right->fetchrow_hashref;
      }

      my $cmp;
      if ( $lr && $rr ) {
         $cmp = $self->key_cmp($lr, $rr, $syncer->key_cols(), $tbl);
         $ENV{MKDEBUG} && _d('Key comparison on left and right: '
            . (defined $cmp ? $cmp : 'undef'));
      }
      if ( $lr || $rr ) {
         if ( $lr && $rr && defined $cmp && $cmp == 0 ) {
            $ENV{MKDEBUG} && _d('Left and right have the same key');
            $syncer->same_row($lr, $rr);
            $lr = $rr = undef; # Fetch another row from each side.
         }
         elsif ( !$rr || ( defined $cmp && $cmp < 0 ) ) {
            $ENV{MKDEBUG} && _d('Left is not in right');
            $syncer->not_in_right($lr);
            $lr = undef;
         }
         else {
            $ENV{MKDEBUG} && _d('Right is not in left');
            $syncer->not_in_left($rr);
            $rr = undef;
         }
      }
   } while ( $left->{Active} || $right->{Active} );
   $ENV{MKDEBUG} && _d('No more rows');
   $syncer->done_with_rows();
}

sub key_cmp {
   my ( $self, $lr, $rr, $key_cols, $tbl ) = @_;
   $ENV{MKDEBUG} && _d("Comparing keys using columns " . join(',', @$key_cols));
   foreach my $col ( @$key_cols ) {
      my $l = $lr->{$col};
      my $r = $rr->{$col};
      if ( !defined $l || !defined $r ) {
         $ENV{MKDEBUG} && _d("$col is not defined in both rows");
         return defined $l || -1;
      }
      else {
         if ($tbl->{is_numeric}->{$col} ) {   # Numeric column
            $ENV{MKDEBUG} && _d("$col is numeric");
            my $cmp = $l <=> $r;
            return $cmp unless $cmp == 0;
         }
         elsif ( $l ne $r ) {
            my $cmp;
            my $coll = $tbl->{collation_for}->{$col};
            if ( $coll && ( $coll ne 'latin1_swedish_ci'
                           || $l =~ m/[^\040-\177]/ || $r =~ m/[^\040-\177]/) ) {
               $ENV{MKDEBUG} && _d("Comparing $col via MySQL");
               $cmp = $self->db_cmp($coll, $l, $r);
            }
            else {
               $ENV{MKDEBUG} && _d("Comparing $col in lowercase");
               $cmp = lc $l cmp lc $r;
            }
            return $cmp unless $cmp == 0;
         }
      }
   }
   return 0;
}

sub db_cmp {
   my ( $self, $collation, $l, $r ) = @_;
   if ( !$self->{sth}->{$collation} ) {
      if ( !$self->{charset_for} ) {
         $ENV{MKDEBUG} && _d("Fetching collations from MySQL");
         my @collations = @{$self->{dbh}->selectall_arrayref(
            'SHOW COLLATION', {Slice => { collation => 1, charset => 1 }})};
         foreach my $collation ( @collations ) {
            $self->{charset_for}->{$collation->{collation}}
               = $collation->{charset};
         }
      }
      my $sql = "SELECT STRCMP(_$self->{charset_for}->{$collation}? COLLATE $collation, "
         . "_$self->{charset_for}->{$collation}? COLLATE $collation) AS res";
      $ENV{MKDEBUG} && _d($sql);
      $self->{sth}->{$collation} = $self->{dbh}->prepare($sql);
   }
   my $sth = $self->{sth}->{$collation};
   $sth->execute($l, $r);
   return $sth->fetchall_arrayref()->[0]->[0];
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# RowDiff:$line ", @_, "\n";
}

1;

# ###########################################################################
# End RowDiff package
# ###########################################################################

# ###########################################################################
# MySQLDump package 1238
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package MySQLDump;

use English qw(-no_match_vars);

( our $before = <<'EOF') =~ s/^   //gm;
   /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
   /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
   /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
   /*!40101 SET NAMES utf8 */;
   /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
   /*!40103 SET TIME_ZONE='+00:00' */;
   /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
   /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
   /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
   /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
EOF

( our $after = <<'EOF') =~ s/^   //gm;
   /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
   /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
   /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
   /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
   /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
   /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
   /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
   /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
EOF

sub new {
   my ( $class ) = @_;
   my $self = bless {}, $class;
   return $self;
}

sub dump {
   my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;

   if ( $what eq 'table' ) {
      my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
      if ( $ddl->[0] eq 'table' ) {
         return $before
            . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
            . $ddl->[1] . ";\n";
      }
      else {
         return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
            . '/*!50001 DROP VIEW IF EXISTS '
            . $quoter->quote($tbl) . "*/;\n/*!50001 "
            . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
      }
   }
   elsif ( $what eq 'triggers' ) {
      my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
      if ( $trgs && @$trgs ) {
         my $result = $before . "\nDELIMITER ;;\n";
         foreach my $trg ( @$trgs ) {
            if ( $trg->{sql_mode} ) {
               $result .= "/*!50003 SET SESSION SQL_MODE=\"$trg->{sql_mode}\" */;;\n";
            }
            $result .= "/*!50003 CREATE */ ";
            if ( $trg->{definer} ) {
               my ( $user, $host )
                  = map { s/'/''/g; "'$_'"; }
                    split('@', $trg->{definer}, 2);
               $result .= "/*!50017 DEFINER=$user\@$host */ ";
            }
            $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
               $quoter->quote($trg->{trigger}),
               @{$trg}{qw(timing event)},
               $quoter->quote($trg->{table}),
               $trg->{statement});
         }
         $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
         return $result;
      }
      else {
         return undef;
      }
   }
   elsif ( $what eq 'view' ) {
      my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
      return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
         . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
         . '/*!50001 ' . $ddl->[1] . "*/;\n";
   }
   else {
      die "You didn't say what to dump.";
   }
}

sub get_create_table {
   my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
   if ( !$self->{tables}->{$db}->{$tbl} ) {
      $dbh->do('/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
         . '@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, "ANSI_QUOTES", ""), ",,", ","), '
         . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
         . '@@SQL_QUOTE_SHOW_CREATE := 1 */');
      my $href = $dbh->selectrow_hashref(
         "SHOW CREATE TABLE "
         . $quoter->quote($db)
         . '.'
         . $quoter->quote($tbl)
      );
      $dbh->do('/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
         . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */');
      my ($key) = grep { m/create table/i } keys %$href;
      if ( $key ) {
         $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
      }
      else {
         ($key) = grep { m/create view/i } keys %$href;
         $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
      }
   }
   return $self->{tables}->{$db}->{$tbl};
}

sub get_columns {
   my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
   if ( !$self->{columns}->{$db}->{$tbl} ) {
      my $cols = $dbh->selectall_arrayref(
         "SHOW COLUMNS FROM "
         . $quoter->quote($db)
         . '.'
         . $quoter->quote($tbl),
         { Slice => {} }
      );
      $self->{columns}->{$db}->{$tbl} = [
         map {
            my %row;
            @row{ map { lc $_ } keys %$_ } = values %$_;
            \%row;
         } @$cols
      ];
   }
   return $self->{columns}->{$db}->{$tbl};
}

sub get_tmp_table {
   my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
   my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
   $result .= join(",\n",
      map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
      @{$self->get_columns($dbh, $quoter, $db, $tbl)});
   $result .= "\n)";
}

sub get_triggers {
   my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
   if ( !$self->{triggers}->{$db} ) {
      $self->{triggers}->{$db} = {};
      $dbh->do('/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
         . '@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, "ANSI_QUOTES", ""), ",,", ","), '
         . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
         . '@@SQL_QUOTE_SHOW_CREATE := 1 */');
      my $trgs = $dbh->selectall_arrayref(
         "SHOW TRIGGERS FROM " . $quoter->quote($db),
         { Slice => {} }
      );
      foreach my $trg ( @$trgs ) {
         my %trg;
         @trg{ map { lc $_ } keys %$trg } = values %$trg;
         push @{$self->{triggers}->{$db}->{$trg{table}}}, \%trg;
      }
      $dbh->do('/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
         . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */');
   }
   return $self->{triggers}->{$db}->{$tbl};
}

1;

# ###########################################################################
# End MySQLDump package
# ###########################################################################

# ###########################################################################
# ChangeHandler package 1351
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package ChangeHandler;

use English qw(-no_match_vars);

my $DEFER_PAT = qr/Duplicate entry|Commands out of sync/;
our @ACTIONS  = qw(DELETE INSERT UPDATE);

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(quoter database table sdatabase stable) ) {
      die "I need a $arg argument" unless defined $args{$arg};
   }
   my $self = { %args, map { $_ => [] } @ACTIONS };
   $self->{db_tbl}  = $self->{quoter}->quote(@args{qw(database table)});
   $self->{sdb_tbl} = $self->{quoter}->quote(@args{qw(sdatabase stable)});
   $self->{queue}   = 0; # Do changes immediately if possible.
   $self->{changes} = { map { $_ => 0 } @ACTIONS };
   return bless $self, $class;
}

sub fetch_back {
   my ( $self, $dbh ) = @_;
   $self->{fetch_back} = $dbh;
   $ENV{MKDEBUG} && _d('Will fetch rows from source when updating destination');
}

sub take_action {
   my ( $self, $sql ) = @_;
   $ENV{MKDEBUG} && _d('Calling subroutines on ', $sql);
   foreach my $action ( @{$self->{actions}} ) {
      $action->($sql);
   }
}

sub change {
   my ( $self, $action, $row, $cols ) = @_;
   $ENV{MKDEBUG} && _d("$action where ", $self->make_where_clause($row, $cols));
   $self->{changes}->{$action}++;
   if ( !$self->{queue} ) {
      eval {
         my $func = "make_$action";
         my $sql  = $self->$func($row, $cols);
         $self->take_action($sql);
      };
      if ( $EVAL_ERROR =~ m/$DEFER_PAT/ ) {
         $ENV{MKDEBUG} && _d('The DBH is busy; queueing further changes');
         push @{$self->{$action}}, [ $row, $cols ];
         $self->{queue}++; # Defer further rows
      }
      elsif ( $EVAL_ERROR ) {
         die $EVAL_ERROR;
      }
   }
   else {
      $ENV{MKDEBUG} && _d('Queueing change for later');
      push @{$self->{$action}}, [ $row, $cols ];
   }
}

sub process_rows {
   my ( $self, $queue_level ) = @_;
   if ( $queue_level && $queue_level < $self->{queue} ) {
      $ENV{MKDEBUG} && _d("Not processing now $queue_level<$self->{queue}");
      return;
   }
   my ($row, $cur_act);
   eval {
      foreach my $action ( @ACTIONS ) {
         my $func = "make_$action";
         my $rows = $self->{$action};
         $ENV{MKDEBUG} && _d(scalar(@$rows) . " to $action");
         $cur_act = $action;
         while ( @$rows ) {
            $row = shift @$rows;
            my $sql = $self->$func(@$row);
            $self->take_action($sql);
         }
      }
   };
   if ( $EVAL_ERROR =~ m/$DEFER_PAT/ ) {
      unshift @{$self->{$cur_act}}, $row;
      $ENV{MKDEBUG} && _d('The DBH is still busy; increasing queue level');
      $self->{queue}++; # Defer rows to the very end
   }
   elsif ( $EVAL_ERROR ) {
      die $EVAL_ERROR;
   }
}

sub make_DELETE {
   my ( $self, $row, $cols ) = @_;
   return "DELETE FROM $self->{db_tbl} WHERE "
      . $self->make_where_clause($row, $cols)
      . ' LIMIT 1';
}

sub make_UPDATE {
   my ( $self, $row, $cols ) = @_;
   my %in_where = map { $_ => 1 } @$cols;
   my $where = $self->make_where_clause($row, $cols);
   if ( my $dbh = $self->{fetch_back} ) {
      my $sql = "SELECT * FROM $self->{sdb_tbl} WHERE $where LIMIT 1";
      $ENV{MKDEBUG} && _d("Fetching data for UPDATE: $sql");
      my $res = $dbh->selectrow_hashref($sql);
      @{$row}{keys %$res} = values %$res;
      $cols = [sort keys %$res];
   }
   else {
      $cols = [ sort keys %$row ];
   }
   return "UPDATE $self->{db_tbl} SET "
      . join(', ', map {
            $self->{quoter}->quote($_)
            . '=' .  $self->{quoter}->quote_val($row->{$_})
         } grep { !$in_where{$_} } @$cols)
      . " WHERE $where LIMIT 1";
}

sub make_INSERT {
   my ( $self, $row, $cols ) = @_;
   my @cols = sort keys %$row;
   if ( my $dbh = $self->{fetch_back} ) {
      my $where = $self->make_where_clause($row, $cols);
      my $sql = "SELECT * FROM $self->{sdb_tbl} WHERE $where LIMIT 1";
      $ENV{MKDEBUG} && _d("Fetching data for UPDATE: $sql");
      my $res = $dbh->selectrow_hashref($sql);
      @{$row}{keys %$res} = values %$res;
      @cols = sort keys %$res;
   }
   return "INSERT INTO $self->{db_tbl}("
      . join(', ', map { $self->{quoter}->quote($_) } @cols)
      . ') VALUES ('
      . $self->{quoter}->quote_val( @{$row}{@cols} )
      . ')';
}

sub make_where_clause {
   my ( $self, $row, $cols ) = @_;
   my @clauses = map {
      my $val = $row->{$_};
      my $sep = defined $val ? '=' : ' IS ';
      $self->{quoter}->quote($_) . $sep . $self->{quoter}->quote_val($val);
   } @$cols;
   return join(' AND ', @clauses);
}

sub get_changes {
   my ( $self ) = @_;
   return %{$self->{changes}};
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# ChangeHandler:$line ", @_, "\n";
}

1;

# ###########################################################################
# End ChangeHandler package
# ###########################################################################

# ###########################################################################
# TableChunker package 1350
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package TableChunker;

use POSIX qw(ceil);
use List::Util qw(min max);

sub new {
   my ( $class, %args ) = @_;
   die "I need a quoter" unless $args{quoter};
   bless { %args }, $class;
}

my $EPOCH      = '1970-01-01';
my %int_types  = map { $_ => 1 }
   qw( bigint date datetime int mediumint smallint time timestamp tinyint year );
my %real_types = map { $_ => 1 }
   qw( decimal double float );

sub find_chunk_columns {
   my ( $self, $table, $opts ) = @_;
   $opts ||= {};

   my %prefer;
   if ( $opts->{possible_keys} && @{$opts->{possible_keys}} ) {
      my $i = 1;
      %prefer = map { $_ => $i++ } @{$opts->{possible_keys}};
      $ENV{MKDEBUG} && _d("Preferred indexes for chunking: "
         . join(', ', @{$opts->{possible_keys}}));
   }

   my @candidate_cols;

   my @possible_keys = grep { $_->{type} eq 'BTREE' } values %{$table->{keys}};
   @possible_keys = sort {
      ($prefer{$a->{name}} || 9999) <=> ($prefer{$b->{name}} || 9999)
   } @possible_keys;
   $ENV{MKDEBUG} && _d('Possible keys in order: '
      . join(', ', map { $_->{name} } @possible_keys));

   my $can_chunk_exact = 0;
   if ($opts->{exact}) {
      @candidate_cols =
         grep {
            $int_types{$table->{type_for}->{$_}}
            || $real_types{$table->{type_for}->{$_}}
         }
         map  { $_->{cols}->[0] }
         grep { $_->{unique} && @{$_->{cols}} == 1 }
              @possible_keys;
      if ( @candidate_cols ) {
         $can_chunk_exact = 1;
      }
      $ENV{MKDEBUG} && _d('Exact chunkable: ' . join(', ', @candidate_cols));
   }

   if ( !@candidate_cols ) {
      @candidate_cols =
         grep {
            $int_types{$table->{type_for}->{$_}}
            || $real_types{$table->{type_for}->{$_}}
         }
         map { $_->{cols}->[0] }
         @possible_keys;
      $ENV{MKDEBUG} && _d('Inexact chunkable: ' . join(', ', @candidate_cols));
   }

   my @result;
   if ( !%prefer ) {
      $ENV{MKDEBUG} && _d('Ordering columns by order in tbl, PK first');
      if ( $table->{keys}->{PRIMARY} ) {
         my $pk_first_col = $table->{keys}->{PRIMARY}->{cols}->[0];
         @result = grep { $_ eq $pk_first_col } @candidate_cols;
         @candidate_cols = grep { $_ ne $pk_first_col } @candidate_cols;
      }
      my $i = 0;
      my %col_pos = map { $_ => $i++ } @{$table->{cols}};
      push @result, sort { $col_pos{$a} <=> $col_pos{$b} } @candidate_cols;
   }
   else {
      @result = @candidate_cols;
   }
   $ENV{MKDEBUG} && _d('Chunkable columns: ' . join(', ', @result));
   $ENV{MKDEBUG} && _d("Can chunk exactly: $can_chunk_exact");

   return ($can_chunk_exact, \@result);
}

sub calculate_chunks {
   my ( $self, %args ) = @_;
   foreach my $arg ( qw(table col min max rows_in_range size dbh) ) {
      die "Required argument $arg not given or undefined"
         unless defined $args{$arg};
   }
   $ENV{MKDEBUG} && _d("Arguments: "
      . join(', ',
         map { "$_=" . (defined $args{$_} ? $args{$_} : 'undef') } keys %args));

   my @chunks;
   my ($range_func, $start_point, $end_point);
   my $col_type = $args{table}->{type_for}->{$args{col}};
   $ENV{MKDEBUG} && _d("Chunking on $args{col} ($col_type)");


   if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      $start_point = $args{min};
      $end_point   = $args{max};
      $range_func  = 'range_num';
   }
   elsif ( $col_type eq 'timestamp' ) {
      my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
      $ENV{MKDEBUG} && _d($sql);
      ($start_point, $end_point) = $args{dbh}->selectrow_array($sql);
      $range_func  = 'range_timestamp';
   }
   elsif ( $col_type eq 'date' ) {
      my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
      $ENV{MKDEBUG} && _d($sql);
      ($start_point, $end_point) = $args{dbh}->selectrow_array($sql);
      $range_func  = 'range_date';
   }
   elsif ( $col_type eq 'time' ) {
      my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
      $ENV{MKDEBUG} && _d($sql);
      ($start_point, $end_point) = $args{dbh}->selectrow_array($sql);
      $range_func  = 'range_time';
   }
   elsif ( $col_type eq 'datetime' ) {
      $start_point = $self->timestampdiff($args{dbh}, $args{min});
      $end_point   = $self->timestampdiff($args{dbh}, $args{max});
      $range_func  = 'range_datetime';
   }
   else {
      die "I don't know how to chunk $col_type\n";
   }

   if ( !defined $start_point ) {
      $ENV{MKDEBUG} && _d('Start point is undefined');
      $start_point = 0;
   }
   if ( !defined $end_point || $end_point < $start_point ) {
      $ENV{MKDEBUG} && _d('End point is undefined or before start point');
      $end_point = 0;
   }
   $ENV{MKDEBUG} && _d("Start and end of chunk range: $start_point, $end_point");

   my $interval = $args{size} * ($end_point - $start_point) / $args{rows_in_range};
   if ( $int_types{$col_type} ) {
      $interval = ceil($interval);
   }
   $interval ||= $args{size};
   if ( $args{exact} ) {
      $interval = $args{size};
   }
   $ENV{MKDEBUG} && _d("Chunk interval: $interval units");

   my $col = "`$args{col}`";
   if ( $start_point < $end_point ) {
      my ( $beg, $end );
      my $iter = 0;
      for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
         ( $beg, $end ) = $self->$range_func($args{dbh}, $i, $interval, $end_point);

         if ( $iter++ == 0 ) {
            push @chunks, "$col < " . $self->quote($end);
         }
         else {
            push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
         }
      }

      my $nullable = $args{table}->{is_nullable}->{$args{col}};
      pop @chunks;
      if ( @chunks ) {
         push @chunks, "$col >= " . $self->quote($beg);
      }
      else {
         push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
      }
      if ( $nullable ) {
         push @chunks, "$col IS NULL";
      }

   }
   else {
      push @chunks, '1=1';
   }

   return @chunks;
}

sub get_first_chunkable_column {
   my ( $self, $table, $opts ) = @_;
   my ($exact, $cols) = $self->find_chunk_columns($table, $opts);
   return $cols->[0];
}

sub size_to_rows {
   my ( $self, $dbh, $db, $tbl, $size, $cache ) = @_;
   my $avg_row_length;
   my $status;
   if ( !$cache || !($status = $cache->{$db}->{$tbl}) ) {
      $tbl =~ s/_/\\_/g;
      my $sql = "SHOW TABLE STATUS FROM "
         . $self->{quoter}->quote($db) . " LIKE ?";
      $ENV{MKDEBUG} && _d($sql, ' ', $tbl);
      $status = $dbh->selectrow_hashref($sql, {}, $tbl);
      if ( $cache ) {
         $cache->{$db}->{$tbl} = $status;
      }
   }
   my ($key) = grep { /avg_row_length/i } keys %$status;
   $avg_row_length = $status->{$key};
   return $avg_row_length ? ceil($size / $avg_row_length) : undef;
}

sub get_range_statistics {
   my ( $self, $dbh, $db, $tbl, $col, $where ) = @_;
   my $q = $self->{quoter};
   my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
      . ") FROM " . $q->quote($db, $tbl)
      . ($where ? " WHERE $where" : '');
   $ENV{MKDEBUG} && _d($sql);
   my ( $min, $max ) = $dbh->selectrow_array($sql);
   $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
      . ($where ? " WHERE $where" : '');
   $ENV{MKDEBUG} && _d($sql);
   my $expl = $dbh->selectrow_hashref($sql);
   return (
      min           => $min,
      max           => $max,
      rows_in_range => $expl->{rows},
   );
}

sub quote {
   my ( $self, $val ) = @_;
   return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
}

sub inject_chunks {
   my ( $self, %args ) = @_;
   foreach my $arg ( qw(database table chunks chunk_num query) ) {
      die "$arg is required" unless defined $args{$arg};
   }
   $ENV{MKDEBUG} && _d("Injecting chunk $args{chunk_num}");
   my $comment = sprintf("/*%s.%s:%d/%d*/",
      $args{database}, $args{table},
      $args{chunk_num} + 1, scalar @{$args{chunks}});
   $args{query} =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
   my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
   if ( $args{where} ) {
      $where .= " AND ($args{where})";
   }
   $args{query} =~ s!/\*WHERE\*/! $where!;
   my $db_tbl = $self->{quoter}->quote(@args{qw(database table)});
   $args{query} =~ s!/\*DB_TBL\*/!$db_tbl!;
   $args{query} =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
   return $args{query};
}

sub range_num {
   my ( $self, $dbh, $start, $interval, $max ) = @_;
   my $end = min($max, $start + $interval);
   $start =~ s/\.(\d{5}).*$/.$1/;
   $end   =~ s/\.(\d{5}).*$/.$1/;
   if ( $end > $start ) {
      return ( $start, $end );
   }
   else {
      die "Chunk size is too small: $end !> $start\n";
   }
}

sub range_time {
   my ( $self, $dbh, $start, $interval, $max ) = @_;
   my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
   $ENV{MKDEBUG} && _d($sql);
   return $dbh->selectrow_array($sql);
}

sub range_date {
   my ( $self, $dbh, $start, $interval, $max ) = @_;
   my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
   $ENV{MKDEBUG} && _d($sql);
   return $dbh->selectrow_array($sql);
}

sub range_datetime {
   my ( $self, $dbh, $start, $interval, $max ) = @_;
   my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
       . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
   $ENV{MKDEBUG} && _d($sql);
   return $dbh->selectrow_array($sql);
}

sub range_timestamp {
   my ( $self, $dbh, $start, $interval, $max ) = @_;
   my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
   $ENV{MKDEBUG} && _d($sql);
   return $dbh->selectrow_array($sql);
}

sub timestampdiff {
   my ( $self, $dbh, $time ) = @_;
   my $sql = "SELECT (TO_DAYS('$time') * 86400 + TIME_TO_SEC('$time')) "
      . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
   my ( $diff ) = $dbh->selectrow_array($sql);
   $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
   $ENV{MKDEBUG} && _d($sql);
   my ( $check ) = $dbh->selectrow_array($sql);
   die <<"   EOF"
   Incorrect datetime math: given $time, calculated $diff but checked to $check.
   This is probably because you are using a version of MySQL that overflows on
   large interval values to DATE_ADD().  If not, please report this as a bug.
   EOF
      unless $check eq $time;
   return $diff;
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# TableChunker:$line ", @_, "\n";
}

1;

# ###########################################################################
# End TableChunker package
# ###########################################################################

# ###########################################################################
# TableChecksum package 1356
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package TableChecksum;

use English qw(-no_match_vars);
use POSIX qw(ceil);
use List::Util qw(min max);

our %ALGOS = (
   CHECKSUM => { pref => 0, hash => 0 },
   ACCUM    => { pref => 1, hash => 1 },
   BIT_XOR  => { pref => 2, hash => 1 },
);

sub new {
   bless {}, shift;
}

sub best_algorithm {
   my ( $self, %args ) = @_;
   my ($alg, $vp, $dbh) = @args{ qw(algorithm vp dbh) };
   my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
   die "Invalid checksum algorithm $alg"
      if $alg && !$ALGOS{$alg};

   if (
      $args{where} || $args{chunk}        # CHECKSUM does whole table
      || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
      || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
   {
      $ENV{MKDEBUG} && _d('Cannot use CHECKSUM algorithm');
      @choices = grep { $_ ne 'CHECKSUM' } @choices;
   }

   if ( !$vp->version_ge($dbh, '4.1.1') ) {
      $ENV{MKDEBUG} && _d('Cannot use BIT_XOR algorithm');
      @choices = grep { $_ ne 'BIT_XOR' } @choices;
   }

   if ( $alg && grep { $_ eq $alg } @choices ) {
      $ENV{MKDEBUG} && _d("User requested $alg algorithm");
      return $alg;
   }

   if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      $ENV{MKDEBUG} && _d('Not using CHECKSUM algorithm because COUNT desired');
      @choices = grep { $_ ne 'CHECKSUM' } @choices;
   }

   return $choices[0];
}

sub is_hash_algorithm {
   my ( $self, $algorithm ) = @_;
   return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
}

sub choose_hash_func {
   my ( $self, %args ) = @_;
   my @funcs = qw(SHA1 MD5);
   if ( $args{func} ) {
      unshift @funcs, $args{func};
   }
   my ($result, $error);
   do {
      my $func;
      eval {
         $func = shift(@funcs);
         $args{dbh}->do("SELECT $func('test-string')");
         $result = $func;
      };
      if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
         $error .= qq{$func cannot be used because "$1"\n};
         $ENV{MKDEBUG} && _d("$func cannot be used because $1");
      }
   } while ( @funcs && !$result );

   die $error unless $result;
   return $result;
}

sub optimize_xor {
   my ( $self, %args ) = @_;
   my ( $dbh, $func ) = @args{qw(dbh func)};

   my $opt_slice = 0;
   my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
   my $sliced    = '';
   my $start     = 1;
   my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);

   do { # Try different positions till sliced result equals non-sliced.
      $ENV{MKDEBUG} && _d("Trying slice $opt_slice");
      $dbh->do('SET @crc := "", @cnt := 0');
      my $slices = $self->make_xor_slices(
         query     => "\@crc := $func('a')",
         crc_wid   => $crc_wid,
         opt_slice => $opt_slice,
      );

      my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
      $sliced = ($dbh->selectrow_array($sql))[0];
      if ( $sliced ne $unsliced ) {
         $ENV{MKDEBUG} && _d("Slice $opt_slice does not work");
         $start += 16;
         ++$opt_slice;
      }
   } while ( $start < $crc_wid && $sliced ne $unsliced );

   if ( $sliced eq $unsliced ) {
      $ENV{MKDEBUG} && _d("Slice $opt_slice works");
      return $opt_slice;
   }
   else {
      $ENV{MKDEBUG} && _d("No slice works");
      return undef;
   }
}

sub make_xor_slices {
   my ( $self, %args ) = @_;
   my ( $query, $crc_wid, $opt_slice )
      = @args{qw(query crc_wid opt_slice)};

   my @slices;
   for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
      my $len = $crc_wid - $start + 1;
      if ( $len > 16 ) {
         $len = 16;
      }
      push @slices,
         "LPAD(CONV(BIT_XOR("
         . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
         . ", 10, 16), $len, '0')";
   }

   if ( defined $opt_slice && $opt_slice < @slices ) {
      $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
   }
   else {
      map { s/\@crc/$query/ } @slices;
   }

   return join(', ', @slices);
}

sub make_row_checksum {
   my ( $self, %args ) = @_;
   my ( $table, $quoter, $func )
      = @args{ qw(table quoter func) };

   my $sep = $args{sep} || '#';
   $sep =~ s/'//g;
   $sep ||= '#';

   my %cols = map { $_ => 1 } ($args{cols} ? @{$args{cols}} : @{$table->{cols}});
   my @cols =
      map {
         my $type = $table->{type_for}->{$_};
         my $result = $quoter->quote($_);
         if ( $type eq 'timestamp' ) {
            $result .= ' + 0';
         }
         elsif ( $type =~ m/float|double/ && $args{precision} ) {
            $result = "ROUND($result, $args{precision})";
         }
         $result;
      }
      grep {
         $cols{$_}
      }
      @{$table->{cols}};

   my @nulls = grep { $cols{$_} } @{$table->{null_cols}};
   if ( @nulls ) {
      my $bitmap = "CONCAT("
         . join(', ', map { 'ISNULL(' . $quoter->quote($_) . ')' } @nulls)
         . ")";
      push @cols, $bitmap;
   }

   my $query = @cols > 1
             ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
             : "$func($cols[0])";

   return $query;
}

sub make_checksum_query {
   my ( $self, %args ) = @_;
   my ( $dbname, $tblname, $table, $quoter, $algorithm,
        $func, $crc_wid, $opt_slice )
      = @args{ qw(dbname tblname table quoter algorithm
        func crc_wid opt_slice) };
   die "Invalid or missing checksum algorithm"
      unless $algorithm && $ALGOS{$algorithm};

   my $result;

   if ( $algorithm eq 'CHECKSUM' ) {
      return "CHECKSUM TABLE " . $quoter->quote($dbname, $tblname);
   }

   my $expr = $self->make_row_checksum(%args);

   if ( $algorithm eq 'BIT_XOR' ) {
      my $slices = $self->make_xor_slices( query => $expr, %args );
      $result = "LOWER(CONCAT($slices)) AS crc ";
   }
   else {
      $result = "RIGHT(MAX("
         . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
         . "$func(CONCAT(\@crc, $expr)))"
         . "), $crc_wid) AS crc ";
   }
   if ( $args{replicate} ) {
      $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
         . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
         . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
   }
   else {
      $result = "SELECT /*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
   }
   return $result . "FROM /*DB_TBL*//*WHERE*/";
}

sub check_server {
   my ( $self, $args, $level ) = @_;
   $level ||= 0;

   my $dbh;
   eval {
      $dbh = $args->{dbh} || DBI->connect(
         $args->{dsn_parser}->get_cxn_params($args->{dsn},
            { RaiseError => 1, PrintError => 0, AutoCommit => 1 }));
      $ENV{MKDEBUG} && _d('Connected to '
         . $args->{dsn_parser}->as_string($args->{dsn}));
   };
   if ( $EVAL_ERROR ) {
      print "Cannot connect to "
         . $args->{dsn_parser}->as_string($args->{dsn}), "\n";
      return;
   }

   my ($id) = $dbh->selectrow_array('SELECT @@SERVER_ID');
   $ENV{MKDEBUG} && _d('Working on server ID ' . $id);
   my $master_thinks_i_am = $args->{dsn}->{server_id};
   if ( !defined $id
       || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
       || $args->{server_ids_seen}->{$id}++
   ) {
      $ENV{MKDEBUG} && _d('Server ID seen, or not what master said');
      print "Skipping "
         . $args->{dsn_parser}->as_string($args->{dsn}), "\n";
      return;
   }

   (my $sql = <<"   EOF") =~ s/\s+/ /gm;
      SELECT db, tbl, chunk, boundaries,
         COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
         COALESCE(
            this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
            0
         ) AS crc_diff
      FROM $args->{table}
      WHERE master_cnt <> this_cnt OR master_crc <> this_crc
      OR ISNULL(master_crc) <> ISNULL(this_crc)
   EOF

   $ENV{MKDEBUG} && _d($sql);
   my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
   if ( @$diffs ) {
      $args->{callback}->($args->{dsn}, $dbh, $level, @$diffs);
   }

   if ( !defined $args->{recurse} || $level < $args->{recurse} ) {

      my @slaves =
         grep { $_->{master_id} == $id } # Only my own slaves.
         map  {                          # Convert each to all-lowercase keys.
            my %hash;
            @hash{ map { lc $_ } keys %$_ } = values %$_;
            \%hash;
         }
         @{$dbh->selectall_arrayref("SHOW SLAVE HOSTS", { Slice => {} })};

      foreach my $slave ( @slaves ) {
         my $dsn = $args->{dsn_parser}->parse(
             "h=$slave->{host},P=$slave->{port}", $args->{dsn});
         $dsn->{server_id} = $slave->{server_id};
         $ENV{MKDEBUG} && _d('Recursing from '
            . $args->{dsn_parser}->as_string($args->{dsn})
            . ' to '
            . $args->{dsn_parser}->as_string($dsn));
         $self->check_server( { %$args, dsn => $dsn, dbh => undef }, $level + 1 );
      }
   }

}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# TableChecksum:$line ", @_, "\n";
}

1;

# ###########################################################################
# End TableChecksum package
# ###########################################################################

# ###########################################################################
# TableSyncChunk package 1355
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package TableSyncChunk;

use List::Util qw(max);

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(dbh database table handler chunker quoter struct
                        checksum cols vp chunksize where possible_keys) ) {
      die "I need a $arg argument" unless defined $args{$arg};
   }

   $args{crc_col} = '__crc';
   while ( $args{struct}->{is_col}->{$args{crc_col}} ) {
      $args{crc_col} = "_$args{crc_col}"; # Prepend more _ until not a column.
   }
   $ENV{MKDEBUG} && _d('CRC column will be named ' . $args{crc_col});

   my @chunks;
   my $col = $args{chunker}->get_first_chunkable_column(
      $args{struct}, { possible_keys => $args{possible_keys} });
   if ( $col ) {
      my %params = $args{chunker}->get_range_statistics(
         $args{dbh}, $args{database}, $args{table}, $col,
         $args{where});
      if ( !grep { !defined $params{$_} }
            qw(min max rows_in_range) )
      {
         @chunks = $args{chunker}->calculate_chunks(
            dbh      => $args{dbh},
            table    => $args{struct},
            col      => $col,
            size     => $args{chunksize},
            %params,
         );
      }
      $args{chunk_col} = $col;
   }
   die "Cannot chunk $args{database}.$args{table}; cannot find a column."
      unless @chunks;
   $args{chunks}     = \@chunks;
   $args{chunk_num}  = 0;

   $args{algorithm} = $args{checksum}->best_algorithm(
      algorithm   => 'BIT_XOR',
      vp          => $args{vp},
      dbh         => $args{dbh},
      where       => 1,
      chunk       => 1,
      count       => 1,
   );
   $args{func} = $args{checksum}->choose_hash_func(
      func => 'SHA1',
      dbh  => $args{dbh},
   );
   $args{crc_wid} = max(16, length(
      $args{dbh}->selectall_arrayref("SELECT $args{func}('a')")->[0]->[0]));
   if ( $args{algorithm} eq 'BIT_XOR' ) {
      $args{opt_slice}
         = $args{checksum}->optimize_xor(dbh => $args{dbh}, func => 'SHA1');
   }
   $args{chunk_sql} ||= $args{checksum}->make_checksum_query(
      dbname    => $args{database},
      tblname   => $args{table},
      table     => $args{struct},
      quoter    => $args{quoter},
      algorithm => $args{algorithm},
      func      => $args{func},
      crc_wid   => $args{crc_wid},
      opt_slice => $args{opt_slice},
      cols      => $args{cols},
   );
   $args{row_sql} ||= $args{checksum}->make_row_checksum(
      table     => $args{struct},
      quoter    => $args{quoter},
      func      => $args{func},
      cols      => $args{cols},
   );

   $args{state} = 0;
   $args{handler}->fetch_back($args{dbh});
   return bless { %args }, $class;
}

sub get_sql {
   my ( $self, %args ) = @_;
   if ( $self->{state} ) {
      return 'SELECT '
         . join(', ', map { $self->{quoter}->quote($_) } @{$self->key_cols()})
         . ', ' . $self->{row_sql} . " AS $self->{crc_col}"
         . ' FROM ' . $self->{quoter}->quote(@args{qw(database table)})
         . ' WHERE (' . $self->{chunks}->[$self->{chunk_num}] . ')'
         . ($args{where} ? " AND ($args{where})" : '');
   }
   else {
      return $self->{chunker}->inject_chunks(
         database  => $args{database},
         table     => $args{table},
         chunks    => $self->{chunks},
         chunk_num => $self->{chunk_num},
         query     => $self->{chunk_sql},
         where     => $args{where},
         quoter    => $self->{quoter},
      );
   }
}

sub prepare {
   my ( $self, $dbh ) = @_;
   $dbh->do(q{SET @crc := ''});
}

sub same_row {
   my ( $self, $lr, $rr ) = @_;
   if ( $self->{state} ) {
      if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
         $self->{handler}->change('UPDATE', $lr, $self->key_cols());
      }
   }
   elsif ( $lr->{cnt} != $rr->{cnt} || $lr->{crc} ne $rr->{crc} ) {
      $ENV{MKDEBUG} && _d('Will examine this chunk before moving to next');
      $self->{state} = 1; # Must examine this chunk row-by-row
   }
}

sub not_in_right {
   my ( $self, $lr ) = @_;
   die "Called not_in_right in state 0" unless $self->{state};
   $self->{handler}->change('INSERT', $lr, $self->key_cols());
}

sub not_in_left {
   my ( $self, $rr ) = @_;
   die "Called not_in_left in state 0" unless $self->{state};
   $self->{handler}->change('DELETE', $rr, $self->key_cols());
}

sub done_with_rows {
   my ( $self ) = @_;
   if ( $self->{state} == 1 ) {
      $self->{state} = 2;
      $ENV{MKDEBUG} && _d("Setting state=$self->{state}");
   }
   else {
      $self->{state} = 0;
      $self->{chunk_num}++;
      $ENV{MKDEBUG}
         && _d("Setting state=$self->{state}, chunk_num=$self->{chunk_num}");
   }
}

sub done {
   my ( $self ) = @_;
   $ENV{MKDEBUG}
      && _d("Done with $self->{chunk_num} of "
       . scalar(@{$self->{chunks}}) . ' chunks');
   $ENV{MKDEBUG} && $self->{state} && _d('Chunk differs; must examine rows');
   return $self->{state} == 0
      && $self->{chunk_num} >= scalar(@{$self->{chunks}})
}

sub key_cols {
   my ( $self ) = @_;
   my @cols;
   if ( $self->{state} == 0 ) {
      @cols = qw(chunk_num);
   }
   else {
      @cols = $self->{chunk_col};
   }
   $ENV{MKDEBUG} && _d("State $self->{state}, key cols " . join(', ', @cols));
   return \@cols;
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# TableSyncChunk:$line ", @_, "\n";
}

1;

# ###########################################################################
# End TableSyncChunk package
# ###########################################################################

# ###########################################################################
# TableSyncer package 1355
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package TableSyncer;

use English qw(-no_match_vars);

our %ALGOS = map { $_ => 1 } qw(Stream Chunk);

sub new {
   bless {}, shift;
}

sub best_algorithm {
   my ( $self, %args ) = @_;
   foreach my $arg ( qw(struct parser nibbler chunker) ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my $struct = $args{struct};
   my $result;

   my $best_key = $args{parser}->find_best_index($struct);
   if ( $best_key eq 'PRIMARY'
      || ( $struct->{keys}->{$best_key}->{unique}
         && !$struct->{keys}->{$best_key}->{is_nullable} )) {
      $result = 'Chunk';
   }
   else {
      $ENV{MKDEBUG} && _d("No primary or unique non-null key in table");
      $result = 'Stream';
   }
   $ENV{MKDEBUG} && _d("Algorithm: $result");
   return $result;
}

sub sync_table {
   my ( $self, %args ) = @_;
   foreach my $arg ( qw(
      buffer checksum chunker chunksize dst_db dst_dbh dst_tbl execute lock
      misc_dbh quoter replicate src_db src_dbh src_tbl tbl_struct timeoutok
      versionparser wait where possible_keys cols) )
   {
      die "I need a $arg argument" unless defined $args{$arg};
   }
   $ENV{MKDEBUG} && _d("Syncing table with args "
      . join(', ',
         map { "$_=" . (defined $args{$_} ? $args{$_} : 'undef') }
         sort keys %args));

   my $update_func;
   if ( $args{execute} ) {
      my $change_dbh;
      if ( $args{replicate} ) {
         $change_dbh = $args{src_dbh};
         $self->check_permissions(@args{qw(src_dbh src_db src_tbl quoter)});
      }
      else {
         $change_dbh = $args{dst_dbh};
         $self->check_permissions(@args{qw(dst_dbh dst_db dst_tbl quoter)});
      }
      $ENV{MKDEBUG} && _d('Will make changes via ' . $change_dbh);
      $update_func = sub {  map { $change_dbh->do($_) } @_ };
   }

   my $ch = new ChangeHandler(
      quoter    => $args{quoter},
      database  => $args{dst_db},
      table     => $args{dst_tbl},
      sdatabase => $args{src_db},
      stable    => $args{src_tbl},
      actions   => [
         ( $args{print} ? sub { print @_, ";\n" } : () ),
         ( $update_func ? $update_func            : () ),
      ],
   );
   my $rd = new RowDiff( dbh => $args{misc_dbh} );

   my $class  = "TableSync$args{algorithm}";
   my $plugin = $class->new(
      handler   => $ch,
      cols      => $args{cols},
      dbh       => $args{src_dbh},
      database  => $args{src_db},
      table     => $args{src_tbl},
      chunker   => $args{chunker},
      struct    => $args{tbl_struct},
      checksum  => $args{checksum},
      vp        => $args{versionparser},
      quoter    => $args{quoter},
      chunksize => $args{chunksize},
      where     => $args{where},
      possible_keys => [],
   );

   my $cycle = 0;
   while ( !$plugin->done ) {

      $self->lock_and_wait(%args, lock_level => $cycle ? 1 : 2);

      $ENV{MKDEBUG} && _d("Beginning sync cycle $cycle");
      my $src_sql = $plugin->get_sql(
         quoter   => $args{quoter},
         database => $args{src_db},
         table    => $args{src_tbl},
         where    => $args{where},
      );
      my $dst_sql = $plugin->get_sql(
         quoter   => $args{quoter},
         database => $args{dst_db},
         table    => $args{dst_tbl},
         where    => $args{where},
      );
      $plugin->prepare($args{src_dbh});
      $plugin->prepare($args{dst_dbh});
      $ENV{MKDEBUG} && _d("src: " . $src_sql);
      $ENV{MKDEBUG} && _d("dst: " . $dst_sql);
      my $src_sth = $args{src_dbh}
         ->prepare( $src_sql, { mysql_use_result => !$args{buffer} } );
      $src_sth->execute();
      my $dst_sth = $args{dst_dbh}
         ->prepare( $dst_sql, { mysql_use_result => !$args{buffer} } );
      $dst_sth->execute();
      $rd->compare_sets(
         left   => $src_sth,
         right  => $dst_sth,
         syncer => $plugin,
         tbl    => $args{tbl_struct},
      );
      $ENV{MKDEBUG} && _d("Finished sync cycle $cycle");
      $ch->process_rows(1);

      $cycle++;
   }

   $ch->process_rows();

   if ( $args{lock} && $args{lock} < 3 ) {
      $ENV{MKDEBUG} && _d('Unlocking and committing');
      foreach my $dbh ( @args{qw(src_dbh dst_dbh)} ) {
         $dbh->do('UNLOCK TABLES');
         $dbh->commit unless $dbh->{AutoCommit};
      }
   }

   return $ch->get_changes();
}

sub check_permissions {
   my ( $self, $dbh, $db, $tbl, $quoter ) = @_;
   my $db_tbl = $quoter->quote($db, $tbl);
   my $sql = "REPLACE INTO $db_tbl SELECT * FROM $db_tbl LIMIT 0";
   $ENV{MKDEBUG} && _d('Permissions check: ', $sql);
   $dbh->do($sql);
}

sub lock_table {
   my ( $self, $dbh, $where, $db_tbl, $mode ) = @_;
   my $query = "LOCK TABLES $db_tbl $mode";
   $ENV{MKDEBUG} && _d($query);
   $dbh->do($query);
   $ENV{MKDEBUG} && _d("Acquired table lock on $where in $mode mode");
}

sub wait_for_master {
   my ( $self, $src_dbh, $dst_dbh, $time, $timeoutok ) = @_;
   my $query = 'SHOW MASTER STATUS';
   $ENV{MKDEBUG} && _d($query);
   my $ms = $src_dbh->selectrow_hashref($query);
   $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
   $ENV{MKDEBUG} && _d("Waiting $time sec for $ms->{file}, $ms->{position}");
   $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
   $ENV{MKDEBUG} && _d($query);
   my $stat = $dst_dbh->selectall_arrayref($query)->[0]->[0];
   $stat = 'NULL' unless defined $stat;
   if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      die "MASTER_POS_WAIT failed: $stat";
   }
   $ENV{MKDEBUG} && _d("Result of waiting: $stat");
}

sub lock_and_wait {
   my ( $self, %args ) = @_;

   foreach my $arg ( qw(
      dst_db dst_dbh dst_tbl lock quoter replicate src_db src_dbh src_tbl
      timeoutok wait lock_level) )
   {
      die "I need a $arg argument" unless defined $args{$arg};
   }

   return unless $args{lock} && $args{lock} >= $args{lock_level};

   my $sql = 'UNLOCK TABLES';
   $ENV{MKDEBUG} && _d($sql);
   foreach my $dbh( @args{qw(src_dbh dst_dbh)} ) {
      $dbh->do($sql);
   }

   if ( $args{lock} == 3 ) {
      my $sql = 'FLUSH TABLES WITH READ LOCK';
      $ENV{MKDEBUG} && _d("$args{src_dbh}, $sql");
      $args{src_dbh}->do($sql);
   }
   else {
      $self->lock_table($args{src_dbh}, 'source',
         $args{quoter}->quote($args{src_db}, $args{src_tbl}),
         $args{replicate} ? 'WRITE' : 'READ');
   }

   if ( $args{wait} ) {
      $self->wait_for_master(
         $args{src_dbh}, $args{dst_dbh}, $args{wait}, $args{timeoutok});
   }

   if ( $args{replicate} ) {
      $ENV{MKDEBUG}
         && _d('Not locking destination because syncing via replication');
   }
   else {
      if ( $args{lock} == 3 ) {
         my $sql = 'FLUSH TABLES WITH READ LOCK';
         $ENV{MKDEBUG} && _d("$args{dst_dbh}, $sql");
         $args{dst_dbh}->do($sql);
      }
      else {
         $self->lock_table($args{dst_dbh}, 'dest',
            $args{quoter}->quote($args{dst_db}, $args{dst_tbl}),
            $args{execute} ? 'WRITE' : 'READ');
      }
   }
}

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# TableSyncer:$line ", @_, "\n";
}

1;

# ###########################################################################
# End TableSyncer package
# ###########################################################################

package main;

use DBI;
use English qw(-no_match_vars);
use List::Util qw(sum max min);
use POSIX qw(ceil);

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", q$Revision$ =~ m/(\d+)/g || 0);

$OUTPUT_AUTOFLUSH = 1;

# TODO: algorithms: nibble, chunk, stream, drilldown, temp-table, group-by (sja)

# ############################################################################
# Get configuration information.
# ############################################################################

my @opt_spec = (
   { s => 'algorithm|a=s',
     d => 'Algorithm to use (default Chunk)'},
   { s => 'askpass',
     d => 'Prompt for password for connections' },
   { s => 'bufferresults',
     d => 'Fetch all rows from MySQL before comparing' },
   { s => 'chunksize=i',
     d => 'Number of rows to sync at a time for Chunk algorithm (default 1000)'},
   { s => 'columns|c=a',
     d => 'Compare this comma-separated list of columns' },
   { s => 'databases|d=h',
     d => 'Do only this comma-separated list of databases' },
   { s => 'engine|e=h',
     d => 'Do only this comma-separated list of storage engines' },
   { s => 'execute|x',
     d => 'Execute queries to sync tables' },
   #TODO { s => 'forupdate|F',
   #       d => 'Use SELECT FOR UPDATE or LOCK IN SHARE MODE for checksums' },
   { s => 'ignoredb|g=H',
     d => 'Ignore this comma-separated list of databases' },
   { s => 'ignoreengine|E=H',
     d => 'Ignore this comma-separated list of storage engines '
        . '(default FEDERATED,MRG_MyISAM)' },
   { s => 'ignoretbl|n=H',
     d => 'Ignore this comma-separated list of tables' },
   { s => 'lock|k=i',
     d => 'Lock tables: 0=none, 1=per sync cycle, 2=per table, '
        . 'or 3=globally (default 0)' },
   { s => 'print|p',
     d => 'Print queries that will resolve differences' },
   { s => 'replicate|R=s',
     d => 'Sync tables listed as different in this table' },
   { s => 'skipbinlog',
     d => 'Do not log to the binary log' },
   { s => 'skipforeignkey|K',
     d => 'Turn off foreign key checks' },
   { s => 'skipuniquekey',
     d => 'Turn off UNIQUE key checks' },
   { s => 'synctomaster|s',
     d => 'Sync a slave to its master. Implies --wait 60'},
   { s => 'tables|t=h',
     d => 'Do only this comma-separated list of tables' },
   { s => 'timeoutok',
     d => 'Keep going if --wait fails' },
   { s => 'verbose|v',
     d => 'Print results of sync operations' },
   { s => 'wait|w=i',
     d => 'Make slave wait for master pos (implies --lock)' },
   { s => 'where|W=s',
     d => 'WHERE clause to restrict syncing to part of the table' },
);

my $du         = new MySQLDump();
my $tp         = new TableParser();
my $q          = new Quoter();
my $vp         = new VersionParser();
my $chunker    = new TableChunker( quoter => $q );
my $checksum   = new TableChecksum();
my $syncer     = new TableSyncer();
my $dsn_parser = new DSNParser(
   {
      key  => 'D',
      desc => 'Database containing the table to be synced',
      dsn  => 'database',
      copy => 1,
   },
   {
      key  => 't',
      desc => 'Table to be synced',
      dsn  => undef,
      copy => 1,
   },
);
my $opt_parser = new OptionParser(@opt_spec);
$opt_parser->{dsn}    = $dsn_parser;
$opt_parser->{strict} = 0;
$opt_parser->{prompt} = '[OPTION].. [SOURCE] DEST';
$opt_parser->{descr}
   = 'finds and resolves data differences between two MySQL tables.  SOURCE '
   . 'and DEST are DSNs.  Values for DEST default to the values for SOURCE.';
my %opts = $opt_parser->parse();

$opts{w}    = 60 if ($opts{R} || $opts{s} ) && !defined $opts{w};
$opts{k}    = 1  if $opts{w}                && !defined $opts{k};

# TODO: when --columns is specified, and --synctomaster is given, you end up
# with REPLACE INTO (partial columns) which will destroy data.  Yet maybe we
# don't want to update the whole row, just columns we know to be bad (the DBA
# knows this externally to mk-table-sync).  This should turn into INSERT
# and UPDATE.  Or REPLACE should be disallowed when not all columns are
# included.

my @dsns;
while ( my $arg = shift(@ARGV) ) {
   my $dsn = $dsn_parser->parse($arg, $dsns[0]);
   die "You specified a t part, but not a D part in $arg"
      if ($dsn->{t} && !$dsn->{D});
   push @dsns, $dsn;
}

if ( !@dsns || (@dsns ==1 && !$opts{R} && !$opts{s}) ) {
   $opt_parser->error('SOURCE is required, and at least one DEST is '
      . 'required unless --synctomaster or --replicate is specified');
}

$opt_parser->usage_or_errors(%opts);

# ############################################################################
# Do the work.
# ############################################################################
my $exit_status = 0;

if ( $opts{v} ) {
   printf("# %6s %6s %6s %s.%s\n",
      @ChangeHandler::ACTIONS, qw(DATABASE TABLE));
}

if ( $dsns[0]->{t} ) {
   $ENV{MKDEBUG} && _d('DSN has t part; syncing ONE TABLE between servers');
   if ( @dsns == 1 ) {
      die "You specified one DSN with a t part, but not --synctomaster.\n"
         unless $opts{s};
      $dsns[0]->{dbh} = get_dbh($dsns[0]);
      unshift @dsns, get_master_dsn($dsns[0]);
   }

   if ( $dsns[0]->{t} ne $dsns[1]->{t}
         && -t STDIN && -t STDOUT
         && (  (($dsns[0]->{h} || '') ne ($dsns[1]->{h} || ''))
            || (($dsns[0]->{P} || '') ne ($dsns[1]->{P} || '')) ))
   {
      print "Continue syncing tables with different names?  y/n: ";
      my $answer = <STDIN>;
      if ( $answer !~ m/y/i ) {
         exit(1);
      }
   }

   foreach my $dsn ( @dsns[1 .. $#dsns] ) {
      sync_a_table(
         src     => $dsns[0],
         src_db  => $dsns[0]->{D},
         src_tbl => $dsns[0]->{t},
         dst     => $dsn,
         dst_db  => $dsn->{D},
         dst_tbl => $dsn->{t},
         where   => $opts{W},
      );
   }
}
elsif ( $opts{R} ) {

   # Connect to the master and treat it as the source, then find differences on
   # the slave and sync them.
   if ( $opts{s} ) {
      $dsns[0]->{dbh} = get_dbh($dsns[0]);
      unshift @dsns, get_master_dsn($dsns[0]);
      $dsns[0]->{dbh} = get_dbh($dsns[0]);

      # First, check that the master (source) has no discrepancies itself, and
      # ignore tables that do.
      my %skip_table;
      $checksum->check_server(
         {  dbh        => $dsns[0]->{dbh},
            dsn        => $dsns[0],
            dsn_parser => $dsn_parser,
            recurse    => 0,
            table      => $opts{R},
            callback   => sub {
               my ( $dsn, $dbh, $level, @diffs ) = @_;
               foreach my $diff ( @diffs ) {
                  $skip_table{$diff->{db}}->{$diff->{tbl}}++;
               }
            },
         }
      );

      $checksum->check_server(
         {  dbh        => $dsns[1]->{dbh},
            dsn        => $dsns[1],
            dsn_parser => $dsn_parser,
            recurse    => 0,
            table      => $opts{R},
            callback   => sub {
               my ( $dsn, $dbh, $level, @diffs ) = @_;
               foreach my $diff ( @diffs ) {
                  next if $skip_table{$diff->{db}}->{$diff->{tbl}};
                  sync_a_table(
                     src     => $dsns[0],
                     src_db  => $diff->{db},
                     src_tbl => $diff->{tbl},
                     dst     => $dsns[1],
                     dst_db  => $diff->{db},
                     dst_tbl => $diff->{tbl},
                     where   => $diff->{boundaries},
                  );
               }
            },
         }
      );

   }

   # The DSN is the master.  Connect to each slave and find differences, then
   # sync them.
   else {
      my %skip_table;
      $dsns[0]->{dbh} = get_dbh($dsns[0]);
      $checksum->check_server(
         {  dbh        => $dsns[0]->{dbh},
            dsn        => $dsns[0],
            dsn_parser => $dsn_parser,
            recurse    => 1,
            table      => $opts{R},
            callback   => sub {
               my ( $dsn, $dbh, $level, @diffs ) = @_;
               if ( $level ) {
                  # Must save a reference to the DBH to close gracefully later
                  $dsn->{dbh} ||= $dbh;
                  push @dsns, $dsn;
               }
               foreach my $diff ( @diffs ) {
                  if ( !$level ) {
                     $skip_table{$diff->{db}}->{$diff->{tbl}}++;
                  }
                  else {
                     next if $skip_table{$diff->{db}}->{$diff->{tbl}};
                     sync_a_table(
                        src     => $dsns[0],
                        src_db  => $diff->{db},
                        src_tbl => $diff->{table},
                        dst     => $dsns[1],
                        dst_db  => $diff->{db},
                        dst_tbl => $diff->{table},
                        where   => $diff->{boundaries},
                     );
                  }
               }
            },
         }
      );
   }

}
else {
   $dsns[0]->{dbh} = get_dbh($dsns[0]);
   my $finder = new MySQLFind(
      dbh       => $dsns[0]->{dbh},
      quoter    => $q,
      useddl    => 1,
      parser    => $tp,
      dumper    => $du,
      databases => {
         permit => $opts{d},
         reject => $opts{g},
      },
      tables => {
         permit => $opts{t},
         reject => $opts{n},
      },
      engines => {
         views  => 0,
         permit => $opts{e},
         reject => $opts{E},
      },
   );

   DATABASE:
   foreach my $database ( $finder->find_databases() ) {
      foreach my $table ( $finder->find_tables(database => $database) ) {
         foreach my $dsn ( @dsns[ 1 .. $#dsns ] ) {
            eval {
               sync_a_table(
                  src     => $dsns[0],
                  src_db  => $database,
                  src_tbl => $table,
                  dst     => $dsn,
                  dst_db  => $database,
                  dst_tbl => $table,
                  where   => $opts{W},
               );
            };
            if ( $EVAL_ERROR ) {
               print_err($EVAL_ERROR, $database, $table, $dsn->{h} );
               $exit_status = 1;
            }
         }
      }
   }
}

sub sync_a_table {
   my (%args) = @_;

   # Open connections as needed.
   $args{src}->{dbh}      ||= get_dbh($args{src});
   $args{dst}->{dbh}      ||= get_dbh($args{dst});
   $args{src}->{misc_dbh} ||= get_dbh($args{src});

   my $tbl_struct = $tp->parse(
      $du->get_create_table($args{src}->{dbh}, $q, @args{qw(src_db src_tbl)}));
   my @possible_keys = $tp->find_possible_keys(
      $args{src}->{dbh}, @args{qw(src_db src_tbl)}, $q, $opts{W});

   my %status = $syncer->sync_table(
      algorithm     => $opts{a},
      buffer        => $opts{bufferresults} ? 1 : 0,
      checksum      => $checksum,
      chunker       => $chunker,
      chunksize     => $opts{chunksize},
      cols          => $opts{c} || $tbl_struct->{cols},
      dst_db        => $args{dst_db},
      dst_dbh       => $args{dst}->{dbh},
      dst_tbl       => $args{dst_tbl},
      execute       => $opts{x} ? 1 : 0,
      lock          => $opts{k} ? 1 : 0,
      misc_dbh      => $args{src}->{misc_dbh},
      possible_keys => \@possible_keys,
      print         => $opts{p} ? 1 : 0,
      quoter        => $q,
      replicate     => ($opts{R} || $opts{s}) ? 1 : 0,
      src_db        => $args{src_db},
      src_dbh       => $args{src}->{dbh},
      src_tbl       => $args{src_tbl},
      tbl_struct    => $tbl_struct,
      timeoutok     => $opts{timeoutok} ? 1 : 0,
      versionparser => $vp,
      wait          => $opts{w} ? 1 : 0,
      where         => $args{where} || '',
   );

   if ( $opts{v} ) {
      printf("# %6d %6d %6d %s.%s\n",
         @status{@ChangeHandler::ACTIONS}, @args{qw(src_db src_tbl)});
   }
}

foreach my $dsn (@dsns) {
   foreach my $thing ( qw(dbh misc_dbh) ) {
      my $dbh = $dsn->{$thing};
      next unless $dbh;
      $dbh->commit unless $dbh->{AutoCommit};
      $dbh->disconnect;
   }
}

exit $exit_status;

# ############################################################################
# Subroutines
# ############################################################################

sub _d {
   my ( $line ) = (caller(0))[2];
   print "# main:$line ", @_, "\n";
}

# Tries to extract the MySQL error message and print it
sub print_err {
   my ( $msg, $database, $table, $host ) = @_;
   return if !defined $msg;
   $msg =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
   $msg =~ s/\s+/ /g;
   if ( $database && $table ) {
      $msg .= " while doing $database.$table";
   }
   if ( $host ) {
      $msg .= " on $host";
   }
   print STDERR $msg, "\n";
}

sub get_master_dsn {
   my ( $dsn ) = @_;
   $ENV{MKDEBUG} && _d("Connecting to master via SHOW SLAVE STATUS");
   my $query  = 'SHOW SLAVE STATUS';
   $ENV{MKDEBUG} && _d($query);
   my $status = $dsn->{dbh}->selectrow_hashref($query);
   $status    = { map { lc($_) => $status->{$_} } keys %$status };
   my $spec   = "h=$status->{master_host},P=$status->{master_port}";
   return       $dsn_parser->parse($spec, $dsn);
}

sub get_dbh {
   my ( $info ) = @_;
   my $db_options = {
      AutoCommit => !$opts{k} && !$opts{F} && !$opts{1},
      RaiseError => 1,
      PrintError => 0,
      # TODO: enable support for this on old versions of DBD::mysql?
      # http://www.perlmonks.org/?node_id=620803
      mysql_enable_utf8 => 1,
   };

   if ( !$info->{p} && $opts{askpass} ) {
      $info->{p}
         = OptionParser::prompt_noecho("Enter password for $info->{h}: ");
   }
   my $dbh = DBI->connect($dsn_parser->get_cxn_params($info), $db_options);
   my $sql;
   if ( $opts{skipbinlog} ) {
      $sql = "/*!32316 SET SQL_LOG_BIN=0 */";
      $ENV{MKDEBUG} && _d("$dbh: $sql");
      $dbh->do($sql);
   }
   if ( $opts{skipuniquekey} ) {
      $sql = "/*!40014 SET UNIQUE_CHECKS=0 */";
      $ENV{MKDEBUG} && _d("$dbh: $sql");
      $dbh->do($sql);
   }
   if ( $opts{K} ) {
      $sql = "/*!40014 SET FOREIGN_KEY_CHECKS=0 */";
      $ENV{MKDEBUG} && _d("$dbh: $sql");
      $dbh->do($sql);
   }
   return $dbh;
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mk-table-sync - Efficiently synchronize data between two MySQL tables.

=head1 SYNOPSIS

To compare two tables, try one of these:

 mk-table-sync -d col1,col2 u=user,p=pass,h=host1,D=db,t=tbl host2
 mk-table-sync -a bottomup -B 128 u=user,p=pass,h=host1,D=db,t=tbl host2

To sync the destination to the source, try

 mk-table-sync -x -d col1,col2 u=user,p=pass,h=host1,D=db,t=tbl host2

To show the differences between the tables, use the L<"--verbose"> option.
Issue this option multiple times for more detail.  To see queries that will
make the second table the same as the first, use the L<"--print"> option.  To
see the queries issued while searching for differences, use the L<"--debug">
option.

There is a special syntax for connecting to MySQL servers.  Each server name
on the command line can be either just a hostname, or a key=value,key=value
string.  Keys are a single letter:

   KEY MEANING
   === =======
   h   Connect to host
   P   Port number to use for connection
   S   Socket file to use for connection
   u   User for login if not current user
   p   Password to use when connecting
   F   Only read default options from the given file
   D   Database containing the table to be synced
   t   Table to be synced
   i   Index to drill into when syncing

=head1 OPTIONS

Many options are enabled by default and can be disabled by prefixing with --no.

=over

=item --algorithm

The algorithm to use when comparing the tables.  Top-down drills into the tables
with GROUP BY queries.  Bottom-up builds levels of summary tables with
logarithmically fewer rows at each successive level, and then navigates the
tables in reverse to find differences.  Top-down is explained in L<"FINDING
DIFFERENCES TOP-DOWN"> and bottom-up in L<"FINDING DIFFERENCES BOTTOM-UP">.

=item --analyze

Only applies to bottom-up search.  Specifies that mk-table-sync should examine the
summary tables and find table differences, and if desired, issue queries to
resolve them.  This is the default behavior, but you can disable it if you just
want to build the summary tables.

=item --askpass

Prompts the user for a password when connecting to MySQL.

=item --branchfactor

Branch factor for bottom-up algorithm.  Each successive summary table will group
this many rows together in the next summary table.  This means each summary
table will be approximately this fraction of the size of the previous table.  If
you don't specify an exact power of two, mk-table-sync will round it to the
nearest power of two.  The default is 128.

=item --bufferresults

Fetch all rows from MySQL before comparing.  This is disabled by default.  If
enabled, all rows will be fetched into memory for comparing.  This may result in
the results "cursor" being held open for a shorter time on the server, but if
the tables are large, it could take a long time anyway, and eat all your memory.
For most non-trivial data sizes, you want to leave this disabled.

=item --build

Build summary tables for bottom-up algorithm.  Enabled by default.  You can
disable to use existing summary tables.

=item --cleanup

Clean up scratch tables for bottom-up algorithm.  Enabled by default.  You can
disable this to leave the scratch (summary) tables for later analysis or
troubleshooting.

=item --collate

Use MySQL to compare strings if necessary.  Enabled by default.  Perl cannot
reliably compare character strings the same way MySQL does, so if it's unsure
how two strings should be sorted, mk-table-sync will send them to MySQL and
ask its opinion.  You should leave this enabled.

=item --columns

Comma-separated list of columns to compare and synchronize.  If you specify this
list, mk-table-sync will completely ignore any other columns.  Specifying
a column that doesn't exist is not an error.

=item --debug

Print debugging output to STDOUT.  This is mostly the queries used to compare
data.  It is not complete at the moment.

=item --deleteinsert

Convert all UPDATES to DELETE and INSERT.  This can help prevent conflicts due
to unique indexes on columns other than the primary key.  This option will
become obsolete when I make mk-table-sync auto-detect this situation and handle it
itself.

=item --drilldown

Drilldown groupings for the top-down algorithm.  This governs how the
comparison algorithm searches for differences.  If you specify col2,col3 it will
group rows by col2, find groups that differ, search within them grouped by col3,
and then search within these rows on primary key.  The behavior of this option
is likely to change in the future.

=item --engine

Storage engine to use for the bottom-up summary tables.  If you don't specify,
it is controlled by the server's default storage engine.

=item --execute

After finding differences, execute the queries required to sync the tables.

=item --forupdate

Use SELECT FOR UPDATE or LOCK IN SHARE MODE for checksums.  This only applies to
the top-down algorithm.  It can help prevent the tables being changed while
you're examining them.  mk-table-sync automatically decides which type of
locks to acquire, based on other command-line options.  This doesn't do anything
on some storage engines, such as MyISAM.

=item --help

Show a brief help message.

=item --lock

Lock tables when beginning work.  This uses table-level LOCK TABLES.  This can
help prevent tables being changed while you're examining them.

=item --maxcost

Maximum rowcount before aborting.  In either algorithm, if you specify this
option mk-table-sync will abort if it discovers more than this many rows need
to be changed to sync the tables.  There may be more rows to change than can be
definitely discovered up front, but this might be a good way to stop before
doing too much work.

=item --onlydo

Only do INSERT, UPDATE, or DELETE queries while syncing tables.  The default is
to do all three, but if you want to, you can specify any combination of actions.
For example, if you want to do a two-way sync of rows that have been added to
either table, one way to do it is specify 'L<"--onlydo"> iu' and then run
mk-table-sync again the "other direction" with the same iu argument.  That
will avoid deleting extra rows from the destination table, which the second
invocation will then copy back to the source table.

=item --prefix

Tablename prefix for bottom-up algorithm.  In case the default prefix clashes
with existing tables for some reason, or in case you want to use work tables
that were built previously.  The default is a pseudo-random value that is
constant within a given day.  If you run mk-table-sync again the next day, it
will choose a different prefix.

=item --print

Print all sync queries to STDOUT.  If you don't trust mk-table-sync, or just
want to see what it will do, this is a good way.  These queries are valid SQL
and you can run them yourself if you want to sync the tables manually.

=item --queries

Output the L<"--debug"> debugging output as SQL that can be executed.  By
default it's commented out with SQL comments, so it won't interfere with the
output of L<"--print">.  This option removes the comments.

=item --separator

Separator for CONCAT_WS, which is used to concatenate all columns in each row
for checksumming.  The default is '#', but you might want to change it if
you're suspicious about this for any reason (possible collisions, for example).

=item --singletxn

Do all work in a single transaction.  This has no effect unless you're syncing
tables that use a transactional storage engine.

=item --size

Table size in bottom-up algorithm.  Size estimates used to build the summary
tables may be off.  If this happens, mk-table-sync will die and tell you what
value to use for this parameter.  Most of the time the size estimates should be
accurate enough (they just have to be within some logarithmic order of
magnitude), so estimating size up front is a good optimization.  It prevents
COUNT() queries that aren't needed.

=item --synctomaster

Change the table on the master/source server, and let replication propagate the
changes to the destination table.  If you're syncing a master and slave, this is
almost certainly the option you should use.  Implies L<"--strategy">=r.

=item --temp

Use temporary tables in bottom-up algorithm.  The default is to use real tables.

=item --timeoutok

Keep going if L<"--wait"> fails.  If you specify L<"--wait"> and the slave doesn't catch
up to the master's position before the wait times out, the default behavior is
to abort.  This option makes mk-table-sync keep going anyway.  Warning: if
you are trying to get a consistent comparision between the two servers, you
probably don't want to keep going after a timeout.

=item --verbose

Explain the differences found while comparing the tables.  Specify up to three
times for more verbosity.  See L<"OUTPUT"> for more details about the output.

=item --verify

Verify checksum compatibility across servers.  Some older versions of MySQL
won't concatenate columns the same, so checksums might differ.
mk-table-checksum checks for this and aborts if the servers have different
behavior.  If you know your columns will never contain the empty string, you can
safely disable this check.

=item --version

Output version information and exit.

=item --wait

Make the slave wait to catch up to the master before comparing the tables.  The
value is the number of seconds to wait before timing out (see also L<"--timeoutok">).
mk-table-sync issues LOCK TABLES on the master, then finds the master's
binlog position and waits for the slave to catch up to that position before
comparing tables.  This is useful for guaranteeing a consistent comparision
between the servers.

=item --where

Use this option to limit the portion of the table being synchronized.  The
value will be added to queries in the WHERE clause .  Do not include the
keyword WHERE in the option; that will be added automatically.  Be sure to
quote and escape as required by your shell.  For example:

  mk-table-sync [OPTIONS...] --where "id between 5 and 10"

=back

=head1 DESCRIPTION

I wrote this tool to help me resync slaves that "drift" from their masters,
which can happen for any number of reasons.  I wanted a solution that would work
well for MySQL replication, so I didn't have to re-initialize the slaves, which
can be prohibitively expensive -- if there's enough data, even stopping and
restarting the slave is costly, as it takes a while to "warm up" the server.
Add to that the overhead of copying huge amounts of data over the network, and
the time involved, and a way to resync the slaves "live" is very attractive
indeed.  There are also many constraints introduced by replication, which I
wanted to either avoid or use to my advantage.

I know not everyone has exactly these needs, so I made mk-table-sync much more
generic than I'd need to patch a table that's out of sync on a slave.

The DBA must choose the algorithm and parameters to use when reconciling
differences between the tables.  See below for help making this decision.
Different algorithms have more or less network traffic, impact on the servers,
or work better in certain circumstances.  The tool supports a variety of
algorithms so you can resolve the differences as efficiently as possible within
whatever parameters matter to you.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

You need MySQL version 4.1.1 or greater; earlier versions lack the BIT_XOR()
function required to take a groupwise checksum.

=head1 OVERVIEW

This tool implements two algorithms to find differences between two MySQL
tables, which need not be on the same server.  One is "bottom-up" and builds
summary tables from each table, then traverses them to find rows and chunks of
rows that differ.  The other is "top-down" and builds no summary tables, but
repeatedly queries the target table.  Each algorithm has strengths and
limitations, and is suitable for different situations.

Once you've identified the differences, you can also choose from several methods
of resolving them.  One method is to do inserts, updates and deletes to the
destination table.  The other assumes the destination table is on a replication
slave and makes the changes on the source (master) server, counting on
replication to propagate the changes.  Again it's up to a smart DBA to decide
which method is best.

There are also variations on all the techniques, in support of locking,
master/slave consistency, partial-row updates, and so forth.

=head1 FINDING DIFFERENCES BOTTOM-UP

The bottom-up method of finding differences begins by checksumming every row in
the source and destination target tables.  The result of the checksum is stored
in a scratch table on the server.

This scratch table is what I call the "level 0" table.  It contains the target
table's primary key columns and a checksum of all the columns, concatenated.
This checksum is easy to compare and makes it possible to see whether the rows
differ.  Level 0 contains one row per row in the target table.

Table "level 1" is derived from level 0 by grouping a number of rows together
and checksumming the group.  How many rows are grouped together is up to the
user, but it must be a power of two.  128 is a suggestion I've seen.  I refer to
this number as the "branch factor" because the summary tables conceptually build
a tree.

The grouping works by dividing the checksum of each row in level 0 by some power
of the branch factor and taking the remainder.  A checksum is a number, though
it is usually written as a string of hex digits, such as
acbd18db4cc2f85cedef654fccc4a4d8, so you can divide and take the remainder
(modulus) easily.  (This tool actually uses some bitwise arithmetic to optimize
this, but I won't go into it here).  The power of the branch factor decreases as
the levels are built, so the remainders get smaller and smaller, grouping the
rows into fewer and fewer summary rows.

Level 1's primary key is not the target table's primary key.  It is the modulus
of the group from which the row was derived.  For example, if a number of rows
in level 0 have a modulus of 11, they will be grouped together into a single row
in level 1, with the primary key value of 11.

Assuming a branch factor of 128, level 1 has 1/128th as many rows as level 0,
give or take.  Level 2 is built from level 1, and has 1/128th as many rows in it
again, and so on until level N, which has just a single row.

After building scratch tables 0 through N, mk-table-sync begins at level N and works
backwards.  At level N, there is just a single row.  If the checksum in this row
matches on source and destination, the tables must be identical, and there is no
more work to do.  If they differ though, some rows in level N-1 must differ, and
mk-table-sync examines the "parent" rows in level N-1.  It continues to do this until
it travels all the way back "up the tree" to level 0 and identifies exactly
which rows in the target tables are different.  It uses breadth-first search.

I've glossed over many subtleties.  For example, as the summary tables are
built, not only their checksums but the remainders are computed on the fly; the
remainders are stored in the summary tables and are indexed for efficient lookup
as the algorithm traverses back up the tree seeking differences.  A running
count is also stored so at any given point you know how many rows in the target
table got rolled into the one row you're examining, no matter what level you're
at in the tree.  Some optimizations can be used to short-circuit the process
when entire chunks of rows are missing from one of the tables, and so on.  But
these optimizations and subtleties are just efficiencies, and are not necessary
for correctness.

Here are some details about the table structures: The __crc column contains the
checksum of the row from which it was derived.  The __cnt column contains the
running count of rows from which it was derived, except in the case of level 0
where each row is derived from one row.  The __rem column contains the checksum
modulus the power of the branching factor.  The __par column in level N is a
"pointer" to the __rem column in level N-1.

=head1 FINDING DIFFERENCES TOP-DOWN

The top-down algorithm is nearly the reverse of the bottom-up algorithm.
Instead of building summary tables bottom-up from many rows and ending with one
row, then searching top-down back through the summaries, it does an n-ary search
on clusters of the tables, which I refer to as "groupings."  The search begins
with grouped data and ends with single rows, instead of beginning with single
rows and working towards summaries.  There are no summary tables.

The basic idea is to choose an appropriate grouping strategy which will allow
MySQL to use indexes to drill down through regions of the table, grouping each
region together at first and comparing whole chunks of data between the source
and destination.  Suppose the tables contain day-level data for many client
accounts; clients can have many accounts.  Day, client, account and whatever the
primary key is, are all indexed.  The drill-down strategy might first group the
table by day and see which days differ between the tables, then within the days
that differ group by client, then account, and finally descend to the individual
row level, using the primary key.

This approach is also a breadth-first search as I've implemented it.  At each
level in the drill-down, mk-table-sync knows a set of truths, such as the value of
certain columns in the rows, the number of rows that might be bad, and so on.
In this respect it is fairly similar to the bottom-up approach.

=head1 PROS AND CONS OF THE TWO SEARCH METHODS

Each method for finding the rows that differ has its own strengths and
weaknesses, and is suited for different scenarios.

The bottom-up approach has these advantages:

=over

=item *

The checksum and modulo arithmetic ensure a uniform hierarchy of rows in the
"tree" of N-level summary tables.  Taking the modulo of a checksum is
essentially a random number, which will distribute rows approximately evenly in
each successive summary.

=item *

The algorithm makes no assumptions about keys or data types, and will work on
any table with a primary key or a user-specified index.  All you need is a way
to identify a row, in the final analysis.

=item *

The technique works the same on every table structure; there's no need to think
about the "best" way to do it for a specific table.

=item *

The summary tables can be kept and re-used for successive analyses, or to
restart an analysis that fails for some reason (for example, you specified a
maximum cost before halting, and it was exceeded but you've changed your mind;
no need to rebuild the summaries, you can just restart).

=item *

If you assume there are occasional "bad" rows scattered through the table, the
entire tree of summary tables will need to be examined to find them.
Pre-calculating this is an up-front penalty that pays off in efficiency once you
try to find the bad rows.

=item *

This algorithm's best and worst cases, in terms of pre-computing the summary
tables, are identical.  Given that you know the table size, you know how
expensive it will be.

=item *

Parts of the algorithm can be parallelized readily, though I have not yet done
so, as I want to make sure the implementation is correct first (I plan to do
this soon).

=item *

This algorithm is network-efficient, as the potentially large rows in the target
tables (suppose each row has very large BLOBS in it) are not sent across the
network.  Only the checksums are sent across the network, until the bad rows
themselves are identified.

=back

The algorithm has its shortcomings too, though:

=over

=item *

It is necessary to do some possibly significant work up front to design the
summary tables properly.  For example, you need to know the maximum possible
number of rows to be examined.  I have tried to optimize this process as much as
possible by examining index statistics and making estimates.  This is fairly
cheap, and should work in nearly every case, but it makes the coding much more
complex, just to avoid things like a COUNT(*) query, which is notoriously slow
on InnoDB.

=item *

All the summary tables may add up to a LOT of data on very large tables.  If the
target table is narrow, the summary tables may be even larger than the target
tables, though there will never be more rows in level 0 than the target table
has.

=item *

It's hard to make this approach play nicely with replication.  If you build
temporary tables in memory, you're playing havoc with statement-based
replication should the slave crash.  Even if you build them on disk, which is
durable and restartable, the summary tables built on the master will replicate
to the slave.  The slave server will be doing double work with the master's
queries running on it.  Either way, building summary tables on the server is
anathema to replication.

=item *

It's hard to lock the table for consistency, should you wish to.  You can't
design the summary tables until you start querying the target tables, yet you
can't write to the summary tables while only holding a lock on the target table,
which would require releasing and re-acquiring the lock on the target -- race
conditions abound.  I do have a workaround to this problem in mind, but have not
implemented it yet (and it would not solve the problem in cases where the
destination table is being written to).

=item *

The original algorithm, as designed by Coelho, didn't use any indexes or
pre-computed and cached remainders and counts on the summary tables.  This is
extremely inefficient on large tables, causing repeated table scans.  While I
have modified the algorithm to avoid this, it comes at the cost of larger table
and index size on the server.

=item *

The checksum/modulo approach destroys locality of reference in the target
tables.  Suppose the rows that differ between the source and destination tables
are concentrated in a small region of the table; the checksum/modulo math will
randomly scatter these neighbors throughout the summary tables.  This precludes
some types of optimizations.  This is very important on extremely large tables,
as it causes lots of random I/O during the search phase.  It's also a realistic
scenario for large tables, which may tend to be append-only logs or similar
(credit card transactions, for example).

=item *

The reverse of something I mentioned earlier as a benefit becomes a drawback
when only a small part of the table is bad.  Building the entire summary table
tree for just one bad row is wasteful.  Most of the tree will compare equal, but
there's no chance for early optimizations by pruning those branches; they've
already been built by the time the search notices they aren't needed.

=item *

All the INSERT .. SELECT statements necessary to build the summary tables will
acquire shared row locks on InnoDB tables.  This overhead adds up.

=back

The top-down approach is quite different, both in behavior and implementation
details.  Here are some of its strengths:

=over

=item *

This approach is network-efficient.  Large rows are not sent across the network,
just as with the bottom-up approach.  However, it is also memory and space
efficient on the servers, as there are no summary tables to build.

=item *

This approach does allow for early optimizations such as tree-pruning in the
search.

=item *

The target table's natural groupings, created by its indexes, can (and should)
be exploited.

=item *

The queries are not replicated because they don't affect any data.  The queries
on the master will not cause extra work on the slave.

=item *

It's easy to lock the tables with one of several strategies, including
intentionally locking InnoDB tables with SELECT FOR UPDATE or SELECT LOCK ON
SHARE MODE, and MySQL's own table locks.

=item *

There is no need in this algorithm to compute branching factors and numbers of
summary levels needed according the the size of the target tables.  There's no
up-front analysis to do.  You don't need to pre-compute anything before
searching for differences.

=item *

Spatial locality can be exploited.  Adjacent "bad" rows stay adjacent during the
search.  This can help avoid random I/O during the search.

=item *

There are more opportunities for bulk operations, such as noticing a large chunk
of the table can be inserted or deleted en masse.  While there are some in the
bottom-up approach, there are not as many, and they're harder to optimize.

=item *

The best case for this algorithm is not the same cost as the worst case.  This
can be good or bad, depending on the scenario.

=item *

The grouping strategy determines the "branch factor" of the search tree, and it
can vary from level to level in the search, depending on the data and the
strategy chosen.  This can be a good thing in the hands of a smart DBA, or a bad
thing in a novice's hands.

=item *

As the search descends through the tree of groupings, it needs to examine fewer
and fewer columns in the target tables.

=back

The top-down approach is not without its weaknesses:

=over

=item *

The search strategy can be simpler or more complex.  It's up to the DBA.  There
are certainly more possibilities, and choosing a good top-down strategy might be
hard.

=item *

If there's no locality to exploit, the top-down approach might not be able to
prune the search tree, and it might end up doing more work than the bottom-up.

=item *

The drill-down must repeatedly checksum the entire row (except the columns it
holds as constants in each level of the search).  If the rows are very large,
for example if there are large text columns, this might be a lot of work for the
server to do over and over.

=back

=head1 RESOLVING DIFFERENCES

Once mk-table-sync has found the differences, you probably want to resolve them.
There are two major ways I know to do this, and several variations.

The most obvious way is to simply issue INSERT, UPDATE, and DELETE statements
against the destination server.

A more subtle approach is to take advantage of replication and issue the
statements on the master, letting replication propagate them to the slave.  In
this case a slightly different approach is needed.  If a row is missing on the
slave, you can't just INSERT it on the master, or you'll presumably get a
duplicate key error.  You could do INSERT IGNORE or REPLACE instead.

The tool uses REPLACE by default when you're using replication.  To tell it to
use INSERT and UPDATE instead, use the L<"--strategy">=s option.  You can use
L<"--strategy">=s to use REPLACE even when you're not using replication to fix the
destination table.

You can also use the L<"--onlydo"> option to only issue some kinds of statements --
for example, suppose you want to run the INSERT and UPDATE statements but not
the DELETE.

=head1 SPECIAL CASES

There are cases where no combination of UPDATE statements can resolve
differences without violating some unique key.  For example, suppose there's a
primary key on column a and a unique key on column b.  Then there is no way to
sync these two tables with straightforward UPDATE statements:

 +---+---+  +---+---+
 | a | b |  | a | b |
 +---+---+  +---+---+
 | 1 | 2 |  | 1 | 1 |
 | 2 | 1 |  | 2 | 2 |
 +---+---+  +---+---+

If you run into this, you can use the L<"--deleteinsert"> option to convert all
UPDATE statements into DELETE followed by INSERT.  The tool orders statements
such that this will succeed.

If necessary, you can use the L<"--singletxn"> option to make sure sychronizing
either succeeds or rolls back entirely.  Of course this will have no effect on
non-transactional tables such as MyISAM.  Running the entire sync in a single
transaction causes extra overhead.

Another special case is comparing strings between servers.  If your primary key
or drilldown columns are character data, mk-table-sync will potentially issue queries
to the source server when it doesn't think it can reliably compare two strings
exactly the same way MySQL does.  The collation used is the column's collation
on the source server, so if the character set or collation differ between the
tables being synced, it's hard to say what the results will be.  This feature
will cause more network traffic between the servers as it compares the tables.
This is a feature I don't have fully baked yet.  You can disable it with the
L<"--nocollate"> option.

=head1 GUARANTEEING CONSISTENCY

I wrote this tool to synchronize tables live, without stopping the servers
they're on.  This requires some kind of locking to guarantee a consistent write
after reading.  This tool supports several methods.

The first is simple table locks.  If you specify the L<"--lock"> option, it will lock
the table for reading or writing, depending on how you want to update.  If you
want to update on a master and let replication propagate the changes, it locks
for write on the master and read on the slave; if you want to make changes on
the slave, it locks for read on the master and doesn't lock on the slave, to
avoid blocking the replication thread on the slave.

If you are using InnoDB tables, you can get consistency without locking the
whole table.  This is especially useful if you're only trying to synchronize
part of the table that you know to be bad.  Use the L<"--forupdate"> option to make
the SELECT statements acquire locks.  As above, it gets either shared (LOCK IN
SHARE MODE) or exclusive (FOR UPDATE) locks, depending on how you are syncing.
This only applies to the top-down algorithm.  The bottom-up algorithm creates
tables, which implicitly commits and releases locks unless you use temporary
tables (the L<"--temp"> option).  If you're using temporary tables with the bottom-up
algorithm, there are implicit shared locks on the target tables if they're
InnoDB.

Finally, if you're working on a master and slave server, you should probably
specify the L<"--wait"> option in conjunction with one of the above. This locks on
the master, finds the master's position, and then waits for the slave to catch
up to that position.  The argument to the option is the number of seconds the
slave should wait before timing out.  By default L<"--wait"> implies L<"--lock">, but you
can specify L<"--nolock"> if you want to override this and use InnoDB's row-level
locks.  Also by default, if the wait timeout is exceeded or another
MASTER_POS_WAIT error occurs, the program will exit with an error, but you can
use the L<"--timeoutok"> option to control this.

You can use the L<"--singletxn"> option to make the entire sync run in one
transaction.

=head1 OUTPUT

Output varies greatly depending on the command-line options you specify.
There are several different kinds of output: debugging, status, and query.  I
have tried to ensure it will always be valid SQL, though much of it will be
commented out.

If you specify the L<"--print"> option, the queries needed to sync the destination
table with the source table will be printed to STDOUT.

If you specify the L<"--debug"> option, the queries needed to discover the
differences between source and destination will be printed to STDOUT, commented
out.  You can use this to see how many queries are executed for a given
strategy, or whatever other debugging you want.  If you remove the comment
characters with the L<"--queries"> option, you can also replay the process of finding
the differences.

If you specify the L<"--verbose"> option, you'll see information about the process of
discovering the differences between the tables.  The output is quite different
for top-down and bottom-up algorithms.  Specify this option multiple times to
increase the amount of information you see.  This output is complex enough
that I'll need to explain it separately.

=head2 TOP-DOWN OUTPUT

At its most verbose, the top-down output may resemble this:

   -- Level 2: CHECK  group of    81 rows WHERE `col2` = '20'
   -- Level 2: INSERT group of    18 rows WHERE `col2` = '42'
   --          Level 2 total:     18 bad rows        81 to inspect
   --          Level 2 summary:    1 bad groups in    3 src groups    2 dst groups
   --          Level 2 changes:    0 updates         18 inserts       0 deletes
   -- Level 1: CHECK  group of     6 rows WHERE `col3` = '737696900' AND `col2` = '20'
   -- Level 1: CHECK  group of     1 rows WHERE `col3` = '737953400' AND `col2` = '20'
   -- Level 1: CHECK  group of     1 rows WHERE `col3` = '737955900' AND `col2` = '20'
   --          Level 1 total:     18 bad rows         8 to inspect
   --          Level 1 summary:    3 bad groups in   32 src groups   32 dst groups
   --          Level 1 changes:    0 updates         18 inserts       0 deletes
   --          Level 0 total:     18 bad rows         2 to inspect
   --          Level 0 summary:    2 bad groups in    6 src groups    6 dst groups
   --          Level 0 changes:    0 updates         18 inserts       0 deletes
   -- Level 0: UPDATE             1 row  WHERE `col3` = '737953400' AND `col1` = '87551' AND `col2` = '20'
   --          Level 0 total:     19 bad rows         1 to inspect
   --          Level 0 summary:    1 bad groups in    1 src groups    1 dst groups
   --          Level 0 changes:    1 updates         18 inserts       0 deletes
   --          Level 0 total:     19 bad rows         0 to inspect
   --          Level 0 summary:    0 bad groups in    1 src groups    1 dst groups
   --          Level 0 changes:    1 updates         18 inserts       0 deletes

Outdented lines are actions that must be taken later, indented lines are
play-by-play status as differences between the tables are found.  There will be
one group of indented lines for each group of rows drilled into and found to
have differences.

The first two lines are details of level 2.  At level 2, col2 is held as a
constant.  There is one group of 81 rows where col2 = 20, which does not match
from source to destination.  It needs further checking and is marked as CHECK.
The next level will drill down into this group.  Also at level 2, there is one
group of 18 rows that needs to be inserted to sync the destination table.  This
does not need to be drilled into on the next level.

The next three lines summarize the findings at level 2, and the work that
remains to be done.  Line 1 shows level 2 found a total of 18 rows known to
differ between the source and destination, and there are 81 more to inspect
further.  Line 2 shows level 2 found 1 entire group of rows known to be bad
(the group that must be inserted) after inspecting 3 groups from the source
table and 2 from the destination table.  The difference, 3-2, is the one group
that must be inserted.  Line 3 shows 18 rows have been queued for insertion
en masse.

The next six lines are what happens in the one group at level 1.  At level 1,
the group of rows where col2 = 20 is drilled into, grouped on col3.  The first
three lines of output show the algorithm finds three groups of rows that don't
match.  The next three show the total bad-row count still at 18, so no new bad
rows have been found, but the number of rows that must be drilled into is much
smaller now -- only 8 rows.  Level 1 found 3 bad groups by checking 32 groups
from each table, and queued no new rows into the known-bad list.

The level 0 output shows these 3 groups being examined a row at a time, with no
more drilldown possible.  And you can see the one bad row being found.
Eventually the last line of output shows 18 rows must be inserted (no change
from before) and 1 row must be updated to sync the destination table.

It might help to see what happens with only one level of verbosity, this time on
a 50,000 row table with 5 rows missing from the destination:

   --          Level 2 total:       0 bad rows       6385 to inspect
   --          Level 1 total:       0 bad rows       5142 to inspect
   --          Level 1 total:       1 bad rows       4235 to inspect
   --          Level 1 total:       1 bad rows       2919 to inspect
   --          Level 1 total:       1 bad rows       2560 to inspect
   --          Level 1 total:       1 bad rows        325 to inspect
   --          Level 0 total:       2 bad rows        142 to inspect
   --          Level 0 total:       2 bad rows        141 to inspect
   --          Level 0 total:       3 bad rows         61 to inspect
   --          Level 0 total:       4 bad rows         37 to inspect
   --          Level 0 total:       5 bad rows          0 to inspect

Now you can see it progressing from 0 known bad rows, with 6385 to do, all the
way to 5 known bad rows and 0 left to do.

=head2 BOTTOM-UP OUTPUT

At maximum verbosity, the output from the bottom-up algorithm may look like this
(this output is from the same 100-row tables as above).

   -- Level 2 UPDATE parent:      0
   --         Level 2 total:    100 rows
   --         Level 2 summary:    1 parents  100 src rows   82 dst rows
   --         Level 2 changes:    0 updates    0 inserts     0 deletes    0 total
   --         Level 2 bulk-op:    0 inserts    0 ins-rows    0 deletes    0 del-rows
   -- Level 1 UPDATE parent:      0
   -- Level 1 BULKIN parent:      1
   -- Level 1 UPDATE parent:      2
   -- Level 1 UPDATE parent:      3
   -- Level 1 UPDATE parent:      4
   -- Level 1 UPDATE parent:      5
   -- Level 1 UPDATE parent:      8
   -- Level 1 UPDATE parent:      9
   -- Level 1 UPDATE parent:     10
   -- Level 1 UPDATE parent:     11
   -- Level 1 UPDATE parent:     14
   -- Level 1 UPDATE parent:     15
   --         Level 1 total:     84 rows
   --         Level 1 summary:   11 parents  100 src rows   82 dst rows
   --         Level 1 changes:    0 updates    1 inserts     0 deletes    1 total
   --         Level 1 bulk-op:    1 inserts    1 ins-rows    0 deletes    0 del-rows
   --         Level 0 total:     19 rows
   --         Level 0 summary:    0 parents   83 src rows   66 dst rows
   --         Level 0 changes:    1 updates   18 inserts     0 deletes   19 total
   --         Level 0 bulk-op:    1 inserts    1 ins-rows    0 deletes    0 del-rows

The first level, level 2, says the parent row whose remainder is 0 (this will
always be the case at the first level in bottom-up) differs.  At this point it
looks like the parent must be updated to reconcile source and destination
tables, but it's not yet known which individual rows must be changed.  The level
2 summary says there are 100 rows grouped together from parent rows, that is 1
parent value with 100 rows in the source and 82 in the destination (the
difference is the 18 rows that must be inserted, but that is not yet known).
The next two lines of output show what work is queued to do -- row-level
updates, inserts and deletes, and bulk inserts and deletes.  Each bulk insert or
delete knows how many rows it will affect.

The next set of output, for level 1, shows that this level of the tree has 11
rows that don't match between source and destination.  These are again marked as
UPDATE because they differ, but it's still not known why.  One row doesn't exist
in the destination and is marked as BULKIN, for "bulk insert."  This level of
drill-down was able to narrow the part of the table possibly bad from 100 to 84
rows.

At level 0, this narrows down to just 19 rows.  Most of these are inserted
singly, and there is one update.

Again, here is what happens with just one level of verbosity on the same
50,000-row tables as above:

   --         Level 2 total:   50000 rows
   --         Level 1 total:    1945 rows
   --         Level 0 total:       5 rows

At the beginning, all 50,000 rows look bad, but as it navigates the tree, it
narrows it down to just the 5 missing rows.

=head1 COMPATIBILITY

My goal is a superb solution for MySQL.  However, I think you can probably
make some minor changes and use this tool on other platforms.

=head1 HISTORY AND ACKNOWLEDGEMENTS

My work is based in part on Giuseppe Maxia's work on distributed databases,
L<http://www.sysadminmag.com/articles/2004/0408/> and code derived from that
article.  There is more explanation, and a link to the code, at
L<http://www.perlmonks.org/?node_id=381053>.

Another programmer extended Maxia's work even further.  Fabien Coelho changed
and generalized Maxia's technique, introducing symmetry and avoiding some
problems that might have caused too-frequent checksum collisions.  This work
grew into pg_comparator, L<http://www.coelho.net/pg_comparator/>.  Coelho also
explained the technique further in a paper titled "Remote Comparison of Database
Tables" (L<http://cri.ensmp.fr/classement/doc/A-375.pdf>).

This existing literature mostly addressed how to find the differences between
the tables, not how to resolve them once found.  I needed a tool that would not
only find them efficiently, but would then resolve them.  I first began thinking
about how to improve the technique further with my article
L<http://www.xaprb.com/blog/2007/03/05/an-algorithm-to-find-and-resolve-data-differences-between-mysql-tables/>,
where I discussed a number of problems with the Maxia/Coelho "bottom-up"
algorithm.  After writing that article, I began to write this tool.  I wanted to
actually implement their algorithm with some improvements so I was sure I
understood it completely.  I discovered it is not what I thought it was, and is
considerably more complex than it appeared to me at first.  Fabien Coelho was
kind enough to address some questions over email.

The improvements to the bottom-up algorithm are my original work, as is the
top-down algorithm.  The techniques to actually resolve the differences are also
my own work.

Another tool that can synchronize tables is the SQLyog Job Agent from webyog.
Thanks to Rohit Nadhani, SJA's author, for the conversations about the general
techniques.  There is a comparison of mk-table-sync and SJA at
L<http://www.xaprb.com/blog/2007/04/05/mysql-table-sync-vs-sqlyog-job-agent/>

Thanks to the following people and organizations for helping in many ways:

Alan Rimm-Kaufman and John Miller (The Rimm-Kaufman Group),
Dane Miller,
Fabien Coelho,
Giuseppe Maxia and others at MySQL AB,
Kristian Koehntopp (MySQL AB),
Rohit Nadhani (WebYog),
The helpful monks at Perlmonks,
Travis Rodak,

=head1 BUGS

Please use the Sourceforge bug tracker, forums, and mailing lists to request
support or report bugs: L<http://sourceforge.net/projects/maatkit/>.

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz.

=head1 VERSION

This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision$.

=cut
