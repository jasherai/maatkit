#!/usr/bin/perl

use strict;
use warnings FATAL => 'all';

# http://dev.mysql.com/doc/refman/5.0/en/explain.html
# http://dev.mysql.com/doc/sakila/en/sakila.html
# http://dev.mysql.com/doc/refman/5.0/en/in-subquery-optimization.html

# explain select film_id from sakila.film where exists(select * from
# sakila.film_actor where sakila.film.film_id = sakila.film_actor.film_id);
# explain select film_id, (select count(*) from sakila.film) as foo from
# sakila.film;
# explain select film_id from sakila.film where exists(select * from
# sakila.film_actor where sakila.film.film_id = sakila.film_actor.film_id and
# @foo is null);
# explain select film_id, (select @foo:=count(*) from sakila.film) as foo from
# sakila.film;

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# ###########################################################################

# ###########################################################################
# Converts text (e.g. saved output) to a "recordset" -- an array of hashrefs
# -- just like EXPLAIN does for selectall_arrayref({}).
# ###########################################################################
package ExplainParser;

sub new {
   bless {}, shift;
}

sub parse {
   my ($self, $text) = @_;
   my $started = 0;
   my $lines   = 0;
   my @cols    = ();
   my @result  = ();

   # Detect which kind of input it is
   my ( $start_re, $line_re, $vals_re, $has_hdr, $is_horiz );
   if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      $start_re = qr/^\+[+-]+$/m;
      $line_re  = qr/^(\| .*)[\r\n]+/m;
      $vals_re  = qr/\| +(.*?)(?= +\|)/ms;
      $has_hdr  = 1;
   }
   elsif ( $text =~ m/\*\*\* 1. row/ ) { # "vertical" output
      $start_re = qr/\*\*\* 1. row/m;
      $line_re  = qr/^( *.*?^ *Extra:[^\n]*$)/ms;
      $vals_re  = qr/^ *(\w+): ([^\n]*) *$/ms;
      $is_horiz = 1;
   }

   if ( $start_re ) {
      # Pull it apart into lines and parse them.
      LINE:
      foreach my $line ( $text =~ m/$line_re/g ) {
         my @vals = $line =~ m/$vals_re/g;
         if ( !$has_hdr || $lines++ ) {
            my %row;
            if ( $has_hdr ) {
               @row{@cols} = @vals;
            }
            elsif ( $is_horiz ) {
               %row = @vals;
            }
            foreach my $key ( keys %row ) {
               $row{$key} = undef if $row{$key} eq 'NULL';
            }
            push @result, \%row;
         }
         else { # header row
            @cols = @vals
         }
      }
   }

   return \@result;
}

# ###########################################################################
# Converts output of EXPLAIN into a human-readable tree.
# ###########################################################################
package ExplainTree;

sub new {
   bless {}, shift;
}

sub parse {
   my ( $self, $text ) = @_;
   return $self->process(ExplainParser->new->parse($text));
}

# The main method that turns a result set into a tree.
sub process {
   my ( $self, $rows ) = @_;
   my $tree;
   foreach my $row ( @$rows ) {
      my $sub = $row->{type};

      my $node = $self->$sub($row);

      if ( $row->{Extra} =~ m/Using where/ ) {
         $node = {
            type  => 'Filter with WHERE',
            children => [$node],
         };
      }

      if ( $tree ) {
         $tree = {
            type     => 'JOIN',
            children => [ $tree, $node ],
         };
      }
      else {
         $tree = $node;
      }

   }
   return $tree;
}

#############################################################################
# Each method in this section corresponds to a value you will find in the 'type'
# column in EXPLAIN.
#############################################################################

sub ALL {
   my ( $self, $row ) = @_;
   return {
      type  => 'Table scan',
      rows  => $row->{rows},
      children => [$self->table($row)],
   };
}

sub range {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index range scan');
}

sub index {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index scan');
}

sub eq_ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Unique index lookup');
}

sub ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup');
}

sub ref_or_null {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup with extra null lookup');
}

sub const {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Constant index lookup');
}

# From the manual: "The Index Merge method is used to retrieve rows with several
# range scans and to merge their results into one."  Therefore each index access
# should be shown as an index range scan.
sub index_merge {
   my ( $self, $row ) = @_;
   my ( $merge_type, $merge_stuff )
      = $row->{Extra} =~ m/Using (intersect|union|sort_union)\((.*?)\)(?=;|$)/;
   my @indexes = split(/,/, $merge_stuff);
   my @lens = $row->{key_len} =~ m/(\d+)/g;
   my @nodes = map {
      my $node = $self->index_access($row, 'Index range scan', $indexes[$_]);
      $node->{key_len} = $lens[$_];
      $node;
   } ( 0 .. $#indexes );
   return {
      type     => 'Index merge',
      method   => $merge_type,
      rows     => $row->{rows},
      children => \@nodes,
   };
}

# ###########################################################################
# Here are helper subroutines for the ones that correspond to values in the
# 'type' column.
# ###########################################################################
sub table {
   my ( $self, $row ) = @_;
   return {
      type          => 'Table',
      table         => $row->{table},
      possible_keys => $row->{possible_keys},
   };
}

sub index_access {
   my ( $self, $row, $type, $key ) = @_;
   my $node = {
      type    => $type,
      key     => $row->{table} . '->' . ($key || $row->{key}),
      key_len => $row->{key_len},
      'ref'   => $row->{ref},
      rows    => $row->{rows},
   };
   if ( $row->{Extra} !~ m/Using index/ ) {
      $node->{children} = [$self->table($row)];
   }
   return $node;
}

# ###########################################################################
# And now for the "program".
# ###########################################################################
package main;

if ( !caller ) {
   print "hi there\n";
}

1; # Because this is a module as well as a script.
