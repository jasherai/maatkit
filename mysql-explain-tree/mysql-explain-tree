#!/usr/bin/perl

use strict;
use warnings FATAL => 'all';

# http://dev.mysql.com/doc/refman/5.0/en/explain.html
# http://dev.mysql.com/doc/sakila/en/sakila.html
# http://dev.mysql.com/doc/refman/5.0/en/in-subquery-optimization.html

# explain select film_id from sakila.film where exists(select * from
# sakila.film_actor where sakila.film.film_id = sakila.film_actor.film_id);
# explain select film_id, (select count(*) from sakila.film) as foo from
# sakila.film;
# explain select film_id from sakila.film where exists(select * from
# sakila.film_actor where sakila.film.film_id = sakila.film_actor.film_id and
# @foo is null);
# explain select film_id, (select @foo:=count(*) from sakila.film) as foo from
# sakila.film;

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# ###########################################################################

# ###########################################################################
# Converts text (e.g. saved output) to a "recordset" -- an array of hashrefs
# -- just like EXPLAIN does for selectall_arrayref({}).
# ###########################################################################
package ExplainParser;

sub new {
   bless {}, shift;
}

sub parse_tabular {
   my ( $text, @cols ) = @_;
   my %row;
   my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
   return (undef, \@vals) unless @cols;
   @row{@cols} = @vals;
   return (\%row, undef);
}

sub parse_tab_sep {
   my ( $text, @cols ) = @_;
   my %row;
   my @vals = split(/\t/, $text);
   return (undef, \@vals) unless @cols;
   @row{@cols} = @vals;
   return (\%row, undef);
}

sub parse_vertical {
   my ( $text, @cols ) = @_;
   my %row = $text =~ m/^ *(\w+): ([^\n]*) *$/msg;
   return (\%row, undef);
}

sub parse {
   my ($self, $text) = @_;
   my $started = 0;
   my $lines   = 0;
   my @cols    = ();
   my @result  = ();

   # Detect which kind of input it is
   my ( $line_re, $vals_sub );
   if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      $line_re  = qr/^(\| .*)[\r\n]+/m;
      $vals_sub = \&parse_tabular;
   }
   elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
      $line_re  = qr/^(.*?\t.*)[\r\n]+/m;
      $vals_sub = \&parse_tab_sep;
   }
   elsif ( $text =~ m/\*\*\* 1. row/ ) { # "vertical" output
      $line_re  = qr/^( *.*?^ *Extra:[^\n]*$)/ms;
      $vals_sub = \&parse_vertical;
   }

   if ( $line_re ) {
      # Pull it apart into lines and parse them.
      LINE:
      foreach my $line ( $text =~ m/$line_re/g ) {
         my ($row, $cols) = $vals_sub->($line, @cols);
         if ( $row ) {
            foreach my $key ( keys %$row ) {
               $row->{$key} = undef if $row->{$key} eq 'NULL';
            }
            push @result, $row;
         }
         else {
            @cols = @$cols;
         }
      }
   }

   return \@result;
}

# ###########################################################################
# Converts output of EXPLAIN into a human-readable tree.
# ###########################################################################
package ExplainTree;

use Regexp::Common;
use Data::Dumper;

sub new {
   bless {}, shift;
}

sub parse {
   my ( $self, $text ) = @_;
   return $self->process(ExplainParser->new->parse($text));
}

# The main method that turns a result set into a tree.
sub process {
   my ( $self, $rows ) = @_;
   my @nodes;
   my %node_for;

   # ##################################################################
   # EXPLAIN output has forward references, so this requires two passes,
   # one to generate subtrees from each row and one to resolve the refs.
   # ##################################################################

   my $rowid = 0;

   foreach my $row ( @$rows ) {
      my $sub = $row->{type};

      # ##################################################################
      # Dispatch to a class method to generate the tree.
      # ##################################################################
      my $node
         = $sub                          ? $self->$sub($row)
         : $row->{Extra} =~ m/No tables/ ? { type => 'DUAL' }
         :                                 die "Can't handle " . Dumper($row);

      # ##################################################################
      # Apply other tree transformations.
      # ##################################################################
      if ( $row->{Extra} =~ m/Using where/ ) {
         $node = {
            type  => 'Filter with WHERE',
            children => [$node],
         };
      }

      # Add some data that will help me keep track of nodes as I manipulate
      # them later
      $node->{id}    = $row->{id};
      $node->{rowid} = $rowid;
      $node->{row}   = $row;

      $node_for{$rowid} = $node;
      push @nodes, $node;

      $rowid++;
   }

   # Find nodes whose table references need to be resolved.  Remove the
   # referenced nodes from the flat list and make them children.
   foreach my $node (
      grep { $_->{row}->{table} && $_->{row}->{table} =~ m/^<.*>$/ } @nodes
   ) {
      my @ids = $node->{row}->{table} =~ m/(\d+)/g;
      my @kids;
      foreach my $id ( @ids ) {
         push @kids, grep { $_->{id} && $_->{id} == $id } @nodes;
      }
      $node->{children} = [@kids];

      # Now remove the children from the main list.
      my %child_row_ids = map { $_->{rowid} => 1 } @kids;
      @nodes = grep { !$child_row_ids{$_->{rowid}} } @nodes;
   }

   # Resolve joins in the main node list.
   my $tree = $self->build_join_tree(@nodes);

   # Massage some kinds of nodes.
   foreach my $node ( values %node_for ) {
      if ( $node->{row}->{table} && $node->{row}->{table} =~ m/^<derived(\d+,?)+>$/ ) {
         $node->{type} = 'DERIVED';
         $node->{table} = $node->{row}->{table};
         $node->{children} = [ $self->build_join_tree(@{$node->{children}}) ];
      }
      elsif ( $node->{row}->{select_type} eq 'UNION RESULT' ) {
         $node->{type} = 'UNION';
         $node->{table} = $node->{row}->{table};
      }
   }

   # Get rid of temp variables.
   foreach my $node ( values %node_for ) {
      delete @{$node}{qw(row)};
   }

   return $tree;
}

#############################################################################
# Each method in this section corresponds to a value you will find in the 'type'
# column in EXPLAIN.
#############################################################################

sub ALL {
   my ( $self, $row ) = @_;
   return {
      type     => 'Table scan',
      rows     => $row->{rows},
      children => [$self->table($row)],
   };
}

sub range {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index range scan');
}

sub index {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index scan');
}

sub eq_ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Unique index lookup');
}

sub ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup');
}

sub ref_or_null {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup with extra null lookup');
}

sub const {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Constant index lookup');
}

# From the manual: "The Index Merge method is used to retrieve rows with
# several range scans and to merge their results into one."  Therefore each
# index access should be shown as an index range scan.  The unions and
# intersections can be recursive, as in
# union(intersect(key1,key2),intersect(key3,key4))
sub index_merge {
   my ( $self, $row ) = @_;
   my ( $merge_spec )
      = $row->{Extra} =~ m/Using ((?:intersect|union|sort_union)\(.*?\))(?=;|$)/;
   my ($merge, $num) = $self->recurse_index_merge($row, $merge_spec, 0);

   # index_merge_bookmark_lookup note:
   # From the manual, "If the used indexes don't cover all columns used in the
   # query, full rows are retrieved only when the range conditions for all
   # used keys are satisfied."  So a bookmark lookup shouldn't be shown for
   # all indexes; it should be shown from the merge results.
   if ( $row->{Extra} !~ m/Using index/ ) {
      return {
         type     => 'Bookmark lookup',
         rows     => $row->{rows},
         children => [
            $merge,
            $self->table($row),
         ],
      };
   }

   return $merge;
}

# ###########################################################################
# Here are helper subroutines for the ones that correspond to values in the
# 'type' column.
# ###########################################################################

sub build_join_tree {
   my ( $self, @nodes ) = @_;
   my $tree;
   foreach my $node ( @nodes ) {
      if ( !$tree ) {
         $tree = $node;
      }
      else {
         $tree = {
            type     => 'JOIN',
            children => [ $tree, $node ],
         };
      }
   }
   return $tree;
}

# TODO: get rid of Regexp::Common dependency with a re like this:
# my $bal;
# $bal = qr /[(]
# [^()]*
# (?:(??{ $bal }) [^()]* )*
# [)]/x;
# see http://www.perlmonks.org/?node_id=308039
# $num is the number of nodes to the left of this node in a depth-first
# traversal.  It lets me figure out which value goes in key_len.
sub recurse_index_merge {
   my ( $self, $row, $spec, $num ) = @_;
   my ($type, $args) = $spec =~ m/(intersect|union|sort_union)\((.*)\)$/;

   my @children;

   # Extract a thing, followed by balanced parentheses.
   my $bal = qr/(\w+$RE{balanced}{-parens=>'()'})/;
   foreach my $child ( $args =~ m/$bal/g ) {
      my ( $subtree, $num ) = $self->recurse_index_merge($row, $child, $num);
      push @children, $subtree;
   }

   if ( !@children ) { # Recursion base case; $args is an index list
      foreach my $idx ( split(/,/, $args) ) {
         my $index_scan = $self->index_access($row, 'Index range scan', $idx);
         $index_scan->{key_len} = ($row->{key_len} =~ m/(\d+)/g)[$num++];
         push @children, $index_scan;
      }
   }

   return (
      {
         type     => 'Index merge',
         method   => $type,
         rows     => $row->{rows},
         children => \@children,
      },
      $num
   );

}

sub table {
   my ( $self, $row ) = @_;
   return {
      type          => 'Table',
      table         => $row->{table},
      possible_keys => $row->{possible_keys},
   };
}

sub index_access {
   my ( $self, $row, $type, $key ) = @_;
   my $node = {
      type    => $type,
      key     => $row->{table} . '->' . ($key || $row->{key}),
      key_len => $row->{key_len},
      'ref'   => $row->{ref},
      rows    => $row->{rows},
   };
   # See index_merge_bookmark_lookup note above.
   if ( $row->{Extra} !~ m/Using index/ && $row->{type} ne 'index_merge' ) {
      $node->{children} = [$self->table($row)];
   }
   return $node;
}

# ###########################################################################
# And now for the "program".
# ###########################################################################
package main;

if ( !caller ) {
   print "hi there\n";
}

1; # Because this is a module as well as a script.
