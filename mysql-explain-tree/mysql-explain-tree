#!/usr/bin/perl

use strict;
use warnings FATAL => 'all';

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# Or, look it up in the Camel book (TODO).
# ###########################################################################

# ###########################################################################
# Converts text (e.g. saved output) to a "recordset" -- an array of hashrefs
# -- just like EXPLAIN does for selectall_arrayref({}).
# ###########################################################################
package ExplainParser;

sub new {
   bless {}, shift;
}

sub parse_tabular {
   my ( $text, @cols ) = @_;
   my %row;
   my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
   return (undef, \@vals) unless @cols;
   @row{@cols} = @vals;
   return (\%row, undef);
}

sub parse_tab_sep {
   my ( $text, @cols ) = @_;
   my %row;
   my @vals = split(/\t/, $text);
   return (undef, \@vals) unless @cols;
   @row{@cols} = @vals;
   return (\%row, undef);
}

sub parse_vertical {
   my ( $text, @cols ) = @_;
   my %row = $text =~ m/^ *(\w+): ([^\n]*) *$/msg;
   return (\%row, undef);
}

sub parse {
   my ($self, $text) = @_;
   my $started = 0;
   my $lines   = 0;
   my @cols    = ();
   my @result  = ();

   # Detect which kind of input it is
   my ( $line_re, $vals_sub );
   if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      $line_re  = qr/^(\| .*)[\r\n]+/m;
      $vals_sub = \&parse_tabular;
   }
   elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
      $line_re  = qr/^(.*?\t.*)[\r\n]+/m;
      $vals_sub = \&parse_tab_sep;
   }
   elsif ( $text =~ m/\*\*\* 1. row/ ) { # "vertical" output
      $line_re  = qr/^( *.*?^ *Extra:[^\n]*$)/ms;
      $vals_sub = \&parse_vertical;
   }

   if ( $line_re ) {
      # Pull it apart into lines and parse them.
      LINE:
      foreach my $line ( $text =~ m/$line_re/g ) {
         my ($row, $cols) = $vals_sub->($line, @cols);
         if ( $row ) {
            foreach my $key ( keys %$row ) {
               $row->{$key} = undef if $row->{$key} eq 'NULL';
            }
            push @result, $row;
         }
         else {
            @cols = @$cols;
         }
      }
   }

   return \@result;
}

# ###########################################################################
# Converts output of EXPLAIN into a human-readable tree.
# ###########################################################################
package ExplainTree;

use List::Util qw(max);
use Regexp::Common;
use Data::Dumper;

sub new {
   bless {}, shift;
}

sub parse {
   my ( $self, $text ) = @_;
   return $self->process(ExplainParser->new->parse($text));
}

# The main method that turns a result set into a tree.
sub process {
   my ( $self, $rows ) = @_;
   return unless ref $rows eq 'ARRAY' && @$rows;
   my @nodes;

   # ##################################################################
   # EXPLAIN output has forward references, so this requires two passes,
   # one to generate subtrees from each row and one to resolve the refs.
   # ##################################################################

   my $rowid = 0;

   foreach my $row ( @$rows ) {
      my $sub = $row->{type};

      # ##################################################################
      # Dispatch to a class method to generate the tree.
      # ##################################################################
      my $node
         = $sub                                 ? $self->$sub($row)
         : $row->{Extra} =~ m/No tables/        ? { type => 'DUAL' }
         : $row->{Extra} =~ m/Impossible WHERE/ ? { type => 'IMPOSSIBLE' }
         : $row->{Extra} =~ m/optimized away/   ? { type => 'CONSTANT' }
         :                                      die "Can't handle " . Dumper($row);

      # ##################################################################
      # Apply other tree transformations.
      # ##################################################################
      if ( $row->{Extra} =~ m/Using where/ ) {
         $node = {
            type     => 'Filter with WHERE',
            children => [$node],
         };
      }
      if ( $row->{Extra} =~ m/Using temporary/ ) {
         $node = {
            type     => 'Table scan',
            rows     => undef,
            children => [
               {  type          => 'TEMPORARY',
                  table         => "temporary($row->{table})",
                  possible_keys => undef,
                  children      => [$node],
               }
            ],
         };
      }
      if ( $row->{Extra} =~ m/Distinct|Not exists/ ) {
         $node = {
            type     => 'Distinct/Not-Exists',
            children => [$node],
         };
      }
      if ( $row->{Extra} =~ m/Using filesort/ ) {
         $node = {
            type     => 'Filesort',
            children => [$node],
         };
      }

      # Add some data that will help me keep track of nodes as I manipulate
      # them later
      $node->{id}    = $row->{id};
      $node->{rowid} = $rowid;
      $node->{row}   = $row;

      push @nodes, $node;

      $rowid++;
   }

   # Build a tree from the node list by fixing nodes whose table references need
   # to be resolved.  Remove the referenced nodes from the flat list and make
   # them children of their parents ("push them down").  Because of the way
   # unions and derived tables can be nested (study the EXPLAIN of a union of
   # derived tables of unions), this process has to alternate between unions and
   # derived tables, resolving union results first, and resolving things that
   # don't refer to unresolved things first.
   #
   # Therefore, when a union is resolved I "pull up" information from its child
   # nodes: its id and select_type come from its first child, and its table
   # becomes the concatenation of its child tables.  This convoluted process is
   # necessary because there are both forward and backward references.
   #
   # Strict alternation between union and derived is necessary because a) there
   # is no such thing as a union of unions and b) I can't try to resolve derived
   # tables twice in a row without resolving potential unions within them.

   my $op        = 'UNION';
   my $i         = 0;
   my $this_time = 0;
   my $last_time = 1; # Don't quit if first run doesn't do anything
   while ( $i < @nodes ) {
      my $result = $self->resolve_dependencies(\@nodes, $nodes[$i], $nodes[$i], $op);
      $this_time ||= $result;
      $i = max(0, $i - $result + 1); # May redo nodes, but won't skip any.
      if ( $i >= @nodes ) {
         if ( $this_time || $last_time ) {
            $op = $op eq 'UNION' ? 'DERIVED' : 'UNION';
            $i  = 0;
         }
         $last_time = $this_time;
         $this_time = 0;
      }
   }

   # Resolve joins in the main node list.
   my $tree = $self->build_join_tree(@nodes);

   # Recurse the tree again for more tree transformations.
   my @stack = $tree;
   while ( @stack ) {
      my $node = shift @stack;

      if ( $node->{children} ) {
         unshift @stack, @{$node->{children}};
      }

      if ( $node->{type} eq 'DERIVED' ) {
         $node->{children} = [ $self->build_join_tree(@{$node->{children}}) ];
      }
      
      # Get rid of temp variables.
      delete $node->{row};
   }

   return $tree;
}

sub as_string {
   my ( $self, $node, $prefix ) = @_;
   $prefix ||= '';
   my $branch = $prefix ? substr($prefix, 0, length($prefix) -3) . '+- ' : '';
   my $output = $branch . $node->{type} . "\n";

   my @kids;
   if ( $node->{children} ) {
      @kids   = reverse @{$node->{children}};
   }
   my $suffix = (@kids > 1) ? '|  ' : '   ';

   foreach my $thing ( qw(table possible_keys key method key_len ref rows warning) ) {
      if ( defined $node->{$thing} ) {
         $output .= $prefix . sprintf('%-14s %s', $thing, $node->{$thing}) . "\n";
      }
   }

   my $last_child = pop @kids;
   foreach my $child ( @kids ) {
      $output .= $self->as_string($child, $prefix . $suffix);
   }
   if ( $last_child ) {
      $output .= $self->as_string($last_child, $prefix . '   ');
   }
   return $output;
}

#############################################################################
# Each method in this section corresponds to a value you will find in the 'type'
# column in EXPLAIN.
#############################################################################

sub ALL {
   my ( $self, $row ) = @_;
   return {
      type     => 'Table scan',
      rows     => $row->{rows},
      children => [$self->table($row)],
   };
}

sub range {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index range scan');
}

sub index {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index scan');
}

sub eq_ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Unique index lookup');
}

sub ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup');
}

sub ref_or_null {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup with extra null lookup');
}

sub const {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Constant index lookup');
}

sub system {
   my ( $self, $row ) = @_;
   return {
      type => 'Constant table access',
      rows     => $row->{rows},
      children => [$self->table($row)],
   };
}

sub unique_subquery {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Unique subquery');
}

sub index_subquery {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index subquery');
}

# From the manual: "The Index Merge method is used to retrieve rows with
# several range scans and to merge their results into one."  Therefore each
# index access should be shown as an index range scan.  The unions and
# intersections can be recursive, as in
# union(intersect(key1,key2),intersect(key3,key4))
sub index_merge {
   my ( $self, $row ) = @_;
   my ( $merge_spec )
      = $row->{Extra} =~ m/Using ((?:intersect|union|sort_union)\(.*?\))(?=;|$)/;
   my ($merge, $num) = $self->recurse_index_merge($row, $merge_spec, 0);

   # index_merge_bookmark_lookup note:
   # From the manual, "If the used indexes don't cover all columns used in the
   # query, full rows are retrieved only when the range conditions for all
   # used keys are satisfied."  So a bookmark lookup shouldn't be shown for
   # all indexes; it should be shown from the merge results.
   if ( $row->{Extra} !~ m/Using index/ ) {
      return {
         type     => 'Bookmark lookup',
         rows     => $row->{rows},
         children => [
            $merge,
            $self->table($row),
         ],
      };
   }

   return $merge;
}

# ###########################################################################
# Helper subroutines.
# ###########################################################################

sub has_unresolved_dependencies {
   my ( $self, $node ) = @_;
   if ( $node->{table} && $node->{table} =~ m/^<(?:union|derived)(?:\d+,?)+>$/ ) {
      return 1;
   }
   if ( $node->{children} ) {
      foreach my $child ( @{$node->{children}} ) {
         if ( $self->has_unresolved_dependencies($child) ) {
            return 1;
         }
      }
   }
}

# Takes all nodes, a top-level node, a node, and a kind (union/derived), and
# returns the number of rows it moved.  Does not resolve dependencies if it
# would change something that has dependencies in turn.

sub resolve_dependencies {
   my ( $self, $nodes, $tl, $node, $kind ) = @_;
   my $changes = 0;
   if ( $node->{type} eq $kind && !$node->{children}
         && $self->has_unresolved_dependencies($node) )
   {
      my @ids = $node->{table} =~ m/(\d+)/g;
      my @kids;
      foreach my $id ( @ids ) {
         push @kids, grep { $_->{id} && $_->{id} == $id } @$nodes;
      }

      # Check that kids don't contain any references themselves.
      if ( !grep { $self->has_unresolved_dependencies($_) } @kids ) {

         # "Push down" children.
         $node->{children} = [@kids];
         my %child_row_ids = map { $_->{rowid} => 1 } @kids;
         my $before = scalar @$nodes;
         @$nodes = grep { !$child_row_ids{$_->{rowid}} } @$nodes;

         # "Pull up" information from the children.
         if ( $kind eq 'UNION' ) {
            # UNION RESULT rows don't have a value for the 'id' column, so derived
            # tables over the union won't be able to find their children unless
            # I pull this info up.  They also need a select_type for the
            # build_join_tree() method.
            $tl->{id}          = $kids[0]->{row}->{id};
            $tl->{row}->{select_type} = $kids[0]->{row}->{select_type};
         }
         $node->{table}
            = lc($kind) . '(' . join(',', map { $_->{row}->{table} } @kids) . ')';
         $tl->{row}->{table} = $node->{table};
         return $before - scalar @$nodes;
      }

   }

   if ( $node->{children} ) {
      foreach my $child ( @{$node->{children}} ) {
         $changes += $self->resolve_dependencies($nodes, $tl, $child, $kind);
      }
   }

   return $changes;
}

# The rules seem to be that all rows with the same 'id' value are JOINED.  After
# that, adjacent rows are 'join'ed with some other kind of join, like a
# subquery.
sub build_join_tree {
   my ( $self, @nodes ) = @_;

   # Grab the first row for each 'id' value.
   my %seen;
   my @top_level = grep { !$seen{$_->{id}}++ } @nodes;

   # Build a tree for each 'id' value.
   my @subtrees;
   foreach my $id ( map { $_->{id} } @top_level ) {
      my ($tree, @sub_nodes) = grep { $_->{id} eq $id } @nodes;
      foreach my $node ( @sub_nodes ) {
         $tree = {
            type     => 'JOIN',
            children => [ $tree, $node ],
         };
      }
      push @subtrees, $tree;
   }

   # Now join the list of subtrees together with the specified join type.
   my $tree = shift @subtrees;
   shift @top_level;
   foreach my $i ( 0 .. $#subtrees ) {
      $tree = {
         type     => $top_level[$i]->{row}->{select_type},
         children => [ $tree, $subtrees[$i] ],
      };
   }

   return $tree;
}

# TODO: get rid of Regexp::Common dependency with a re like this:
# my $bal;
# $bal = qr /[(]
# [^()]*
# (?:(??{ $bal }) [^()]* )*
# [)]/x;
# see http://www.perlmonks.org/?node_id=308039
# $num is the number of nodes to the left of this node in a depth-first
# traversal.  It lets me figure out which value goes in key_len.
sub recurse_index_merge {
   my ( $self, $row, $spec, $num ) = @_;
   my ($type, $args) = $spec =~ m/(intersect|union|sort_union)\((.*)\)$/;

   my @children;

   # Extract a thing, followed by balanced parentheses.
   my $bal = qr/(\w+$RE{balanced}{-parens=>'()'})/;
   foreach my $child ( $args =~ m/$bal/g ) {
      my ( $subtree, $num ) = $self->recurse_index_merge($row, $child, $num);
      push @children, $subtree;
   }

   if ( !@children ) { # Recursion base case; $args is an index list
      foreach my $idx ( split(/,/, $args) ) {
         my $index_scan = $self->index_access($row, 'Index range scan', $idx);
         $index_scan->{key_len} = ($row->{key_len} =~ m/(\d+)/g)[$num++];
         push @children, $index_scan;
      }
   }

   return (
      {
         type     => 'Index merge',
         method   => $type,
         rows     => $row->{rows},
         children => \@children,
      },
      $num
   );

}

sub table {
   my ( $self, $row ) = @_;
   my $node = {
      type          => ($row->{table} && $row->{table} =~ m/^<(derived|union)/)
                       ? uc $1
                       : 'Table',
      table         => $row->{table},
      possible_keys => $row->{possible_keys},
   };
   if ( $row->{Extra} =~ m/(Range checked [^)]*\))/ ) {
      $node->{warning} = $1;
   }
   return $node;
}

sub index_access {
   my ( $self, $row, $type, $key ) = @_;
   my $node = {
      type    => $type,
      key     => $row->{table} . '->' . ($key || $row->{key}),
      key_len => $row->{key_len},
      'ref'   => $row->{ref},
      rows    => $row->{rows},
   };
   # See index_merge_bookmark_lookup note above.
   if ( $row->{Extra} !~ m/Using index/ && $row->{type} ne 'index_merge' ) {
      $node->{children} = [$self->table($row)];
   }
   if ( $row->{Extra} =~ m/Full scan on NULL key/ ) {
      $node->{warning} = 'Full scan on NULL key';
   }
   if ( $row->{Extra} =~ m/Using index for group-by/ ) {
      $node->{type} = 'Loose index scan';
   }
   return $node;
}

# ###########################################################################
# And now for the "program".
# ###########################################################################
package main;

use English qw(-no_match_vars);
use Data::Dumper;

if ( !caller ) {
   # Magically read STDIN or files in @ARGV
   my $text = do { local $INPUT_RECORD_SEPARATOR = undef; <>; };
   my $e    = ExplainTree->new();
   print $e->as_string($e->parse($text));
}

1; # Because this is a module as well as a script.
