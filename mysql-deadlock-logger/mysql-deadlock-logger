#!/usr/bin/perl

# This is mysql-deadlock-logger, a program that extracts and saves a summary of
# the last deadlock recorded in MySQL.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use Socket qw(inet_aton);

our $VERSION = '@VERSION@';

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my %opt_spec = (
   l => { s => 'help',         d => 'Show this help message' },
   s => { s => 'source|s=s',   d => 'Server to check for deadlock' },
   d => { s => 'dest|d=s',     d => 'Server in which to store info' },
   p => { s => 'print|p',      d => 'Print to STDOUT' },
   c => { s => 'collapse|c=i', d => 'Collapse whitespace in queries' },
   n => { s => 'numip|n',      d => 'Express IP addresses as integers' },
   C => { s => 'columns|C=s',  d => 'Comma-separated columns in the output' },
   t => { s => 'tab|t',        d => 'Output tab-separated' },
);

# Define the order cmdline opts will appear in help output.  Add any extra ones
# defined above.  If it's not in this list, it's not an option to this
# program.  Note that 'h' is host and 'l' is help.
my @opt_keys = qw( l s d p c n C t );

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   l => '',
   s => '',
   d => '',
   p => 0,
   c => undef,
   n => 0,
   C => '',
   t => 0,
);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => \$opts{$_} }  @opt_keys );

# Process options...
$opts{c} = $opts{p} unless defined $opts{c};
$opts{C} = $opts{C} ? { map { $_ => 1 } $opts{C} =~ m/(\w+)/g } : 0;

# ############################################################################
# Try to use the user's .my.cnf file.
# ############################################################################
my $my_cnf = {
   host => 'localhost',
   user => getlogin() || getpwuid($UID),
   port => 3306,
};
eval {
   my $homedir = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '';
   my $filename = "$homedir/.my.cnf";
   if ( -f $filename ) {
      open my $conf_file, "<", "$homedir/.my.cnf" or die $OS_ERROR;
      while ( my $line = <$conf_file> ) {
         chomp $line;
         $line =~ s/(^\s*)|(\s*#.*$)//g;
         next unless $line;
         my ( $key, $val ) = split( /\s*=\s*/, $line );
         next unless defined $val;
         if ( $key eq 'host' )     { $my_cnf->{host} = $val; }
         if ( $key eq 'user' )     { $my_cnf->{user} = $val; }
         if ( $key =~ m/^pass/ )   { $my_cnf->{pass} = $val; }
         if ( $key eq 'database' ) { $my_cnf->{database} = $val; }
         if ( $key eq 'port' )     { $my_cnf->{port} = $val; }
      }
      close $conf_file;
   }
};

# ############################################################################
# Parse arguments saying where to connect.  If the script doesn't have
# everything it needs, show help text.
# ############################################################################
# Parses a DSN in login:pass@host:port/database.table format
sub parse_dsn {
   my ($dsn, $prev, $defs) = @_;
   $dsn  ||= '';
   $prev ||= {};
   $defs ||= {};

   my ( $user, $pass, $host, $port, $database, $table ) = $dsn =~ m{
      (?:
         (.*?)       # Username
         (?::(.*))?  # Optional password
      @)?            # User-pass is optional
      (?:
         (.*?)       # Hostname
         (?::(.*))?  # Optional port
      /)?            # Host-port is optional
      (?:
         (.*?)       # Database
      \.)?           # Database is optional
      (.*)?          # Table is optional
      }x;

   return {
      user     => coalesce( $user,     $prev->{user},     $defs->{user} ),
      pass     => coalesce( $pass,     $prev->{pass},     $defs->{pass} ),
      host     => coalesce( $host,     $prev->{host},     $defs->{host} ),
      port     => coalesce( $port,     $prev->{port},     $defs->{port} ),
      database => coalesce( $database, $prev->{database}, $defs->{database} ),
      table    => coalesce( $table,    $prev->{table} ),
   };
}

sub coalesce {
   my $i = 0;
   while ( $i < @_ && !defined $_[$i] ) {
      $i++;
   }
   return $_[$i];
}

my $source = parse_dsn($opts{s}, {},      $my_cnf);
my $dest   = parse_dsn($opts{d}, $source, $my_cnf);

if ( $opts{l} || !$source ) {
   print "Usage: $PROGRAM_NAME <options>\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^=]*))?/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME extracts and saves information about the
most recent deadlock in a MySQL server.  The --source and --dest arguments
take the form
   user:pass\@host:port/database.table.
All parts are optional, and default to values in your .my.cnf file.  Missing
values to --dest are filled in from --source.

For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Configuration info.
# ############################################################################

# Some common patterns and variables
my $MAX_ULONG = 4294967296;                   # 2^32
my $d         = qr/(\d+)/;                    # Digit
my $t         = qr/(\d+ \d+)/;                # Transaction ID
my $i         = qr/((?:\d{1,3}\.){3}\d+)/;    # IP address
my $n         = qr/([^`\s]+)/;                # MySQL object name
my $w         = qr/(\w+)/;                    # Words
my $s         = qr/(\d{6} .\d:\d\d:\d\d)/;    # InnoDB timestamp

# A thread's proc_info can be at least 98 different things I've found in the
# source.  Fortunately, most of them begin with a gerunded verb.  These are
# the ones that don't.
my %is_proc_info = (
   'After create'                 => 1,
   'Execution of init_command'    => 1,
   'FULLTEXT initialization'      => 1,
   'Reopen tables'                => 1,
   'Repair done'                  => 1,
   'Repair with keycache'         => 1,
   'System lock'                  => 1,
   'Table lock'                   => 1,
   'Thread initialized'           => 1,
   'User lock'                    => 1,
   'copy to tmp table'            => 1,
   'discard_or_import_tablespace' => 1,
   'end'                          => 1,
   'got handler lock'             => 1,
   'got old table'                => 1,
   'init'                         => 1,
   'key cache'                    => 1,
   'locks'                        => 1,
   'malloc'                       => 1,
   'query end'                    => 1,
   'rename result table'          => 1,
   'rename'                       => 1,
   'setup'                        => 1,
   'statistics'                   => 1,
   'status'                       => 1,
   'table cache'                  => 1,
   'update'                       => 1,
);

# ############################################################################
# Start working.
# ############################################################################

# Connect to the database
my $dbh = DBI->connect(
   "DBI:mysql:" . join(";",
      map  { "$_=$source->{$_}" }
      grep { defined $source->{$_} } qw(database host port)),
   $source->{user}, $source->{pass}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $!");

my $text = $dbh->selectrow_hashref("SHOW INNODB STATUS")->{Status};

# Pull out the deadlock section
my $dl_text;
my @matches = $text =~ m#\n(---+)\n([A-Z /]+)\n\1\n(.*?)(?=\n(---+)\n[A-Z /]+\n\4\n|$)#gs;
while ( my ( $start, $name, $text, $end ) = splice(@matches, 0, 4) ) {
   next unless $name eq 'LATEST DETECTED DEADLOCK';
   $dl_text = $text;
}

exit(0) unless $dl_text;

my @sections = $dl_text =~ m/^\*{3} (.*)\n(?s:(.*?))(?=^\*)/gm;

# Loop through each section.  There are no assumptions about how many
# there are, who holds and wants what locks, and who gets rolled back.
my %txns;
while ( my ($header, $body) = splice(@sections, 0, 2) ) {
   my ( $txn_id, $what ) = $header =~ m/^\($d\) (.*):$/m;
   next unless $txn_id;
   $txns{$txn_id} ||= { id => $txn_id };
   my $hash = $txns{$txn_id};

   if ( $what eq 'TRANSACTION' ) {
      @{$hash}{qw(txn_time)} = $body =~ m/ACTIVE $d sec/;

      # Parsing the line that begins 'MySQL thread id' is complicated.  The only
      # thing always in the line is the thread and query id.  See function
      # innobase_mysql_print_thd in InnoDB source file sql/ha_innodb.cc.
      my ( $thread_line ) = $body =~ m/^(MySQL thread id .*)$/m;
      my ( $mysql_thread_id, $query_id, $hostname, $ip, $user, $query_status );

      if ( $thread_line ) {
         # These parts can always be gotten.
         ( $mysql_thread_id, $query_id ) = $thread_line =~ m/^MySQL thread id $d, query id $d/m;

         # If it's a master/slave thread, "Has (read|sent) all" may be the thread's
         # proc_info.  In these cases, there won't be any host/ip/user info
         ( $query_status ) = $thread_line =~ m/(Has (?:read|sent) all .*$)/m;
         if ( defined($query_status) ) {
            $user = 'system user';
         }

         # It may be the case that the query id is the last thing in the line.
         elsif ( $thread_line =~ m/query id \d+ / ) {
            # The IP address is the only non-word thing left, so it's the most
            # useful marker for where I have to start guessing.
            ( $hostname, $ip ) = $thread_line =~ m/query id \d+(?: ([A-Za-z]\S+))? $i/m;
            if ( defined $ip ) {
               ( $user, $query_status ) = $thread_line =~ m/$ip $w(?: (.*))?$/;
            }
            else { # OK, there wasn't an IP address.
               # There might not be ANYTHING except the query status.
               ( $query_status ) = $thread_line =~ m/query id \d+ (.*)$/;
               if ( $query_status !~ m/^\w+ing/ && !exists($is_proc_info{$query_status}) ) {
                  # The remaining tokens are, in order: hostname, user, query_status.
                  # It's basically impossible to know which is which.
                  ( $hostname, $user, $query_status ) = $thread_line
                     =~ m/query id \d+(?: ([A-Za-z]\S+))?(?: $w(?: (.*))?)?$/m;
               }
               else {
                  $user = 'system user';
               }
            }
         }
      }

      my ( $query_text ) = $body =~ m/\nMySQL thread id .*\n((?s).*)/;
      $query_text =~ s/\s+$//;
      $query_text =~ s/\s+/ /g if $opts{c};

      @{$hash}{qw(thread hostname ip user query)}
         = ($mysql_thread_id, $hostname, $ip, $user, $query_text);
      foreach my $key ( keys %$hash ) {
         if ( !defined $hash->{$key} ) {
            $hash->{$key} = '';
         }
      }

   }
   else {
      # Prefer information about locks waited for over held.
      if ( $what eq 'WAITING FOR THIS LOCK TO BE GRANTED' || !$hash->{lock_type} ) {
         @{$hash}{ qw(lock_type idx db tbl txn_id lock_mode) }
            = $body
            =~ m{^(RECORD|TABLE) LOCKS? (?:space id \d+ page no \d+ n bits \d+ index `?$n`? of )?table `$n/$n` trx id $t lock.mode (\S+)}m;
         my ( $high, $low ) = $hash->{txn_id} =~ m/^(\d+) (\d+)$/;
         $hash->{txn_id} = $high ? ( $low + $high * $MAX_ULONG ) : $low;
      }
   }
}

my ( $ts ) = $dl_text =~ m/^$s$/m;
my ( $year, $mon, $day, $hour, $min, $sec ) = $ts =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)$/;
$ts = sprintf('%02d-%02d-%02dT%02d:%02d:%02d', $year + 2000, $mon, $day, $hour, $min, $sec);

my ( $victim ) = $dl_text =~ m/^\*\*\* WE ROLL BACK TRANSACTION \((\d+)\)$/m;
foreach my $txn ( values %txns ) {
   $txn->{victim} = $txn->{id} == $victim ? 1 : 0;
   $txn->{ts}     = $ts;
   $txn->{server} = $source->{host};
   $txn->{ip}     = inet_aton($txn->{ip}) if $opts{n};
}

my @cols = qw( server ts thread txn_id txn_time user hostname ip db tbl idx lock_type lock_mode victim query );
if ( $opts{C} ) {
   @cols = grep { $opts{C}->{$_} } @cols;
}

if ( $dest && $dest->{table} ) {
   my $db_tbl = 
      join('.',
      map  {  $dbh->quote_identifier($_) }
      grep { $_ }
      ( $dest->{database}, $dest->{table} ));
   my $dbh2 = DBI->connect(
      "DBI:mysql:" . join(";",
         map  { "$_=$dest->{$_}" }
         grep { defined $dest->{$_} } qw(database host port)),
      $dest->{user}, $dest->{pass}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
      or die("Can't connect to DB: $!");
   my $cols  = join(',', map { $dbh->quote_identifier($_) } @cols);
   my $parms = join(',', map { '?' } @cols);
   my $query = $dbh2->prepare("INSERT IGNORE INTO $db_tbl($cols) VALUES($parms)");
   foreach my $txn ( sort { $a->{thread} <=> $b->{thread} } values %txns ) {
      $query->execute(@{$txn}{@cols});
   }
}

if ( $opts{p} ) {
   my $sep = $opts{t} ? "\t" : ' ';
   print join($sep, @cols), "\n";
   foreach my $txn ( sort { $a->{thread} <=> $b->{thread} } values %txns ) {
      # If $opts{c} is on, it's already been taken care of, but if it's unset,
      # by default strip whitespace.
      if ( !defined $opts{c} ) {
         $txn->{query} =~ s/\s+/ /g;
      }
      print join($sep, map { $txn->{$_} } @cols), "\n";
   }
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-deadlock-logger - Extract and log MySQL deadlock information.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

=head1 OVERVIEW

This program extracts deadlock data from a MySQL server (currently only InnoDB
deadlock information is available).  You can print it to standard output or save
it in a database table.

You specify a server to connect to with a URL-like argument to the --source
option.  This argument takes the form user:pass@host:port/database.table.  All
parts are optional, and in fact the table doesn't matter anyway.  If possible,
values from your .my.cnf file will fill in missing bits, so you might be able to
omit the whole argument.

If you want to store the information into a MySQL database table, specify it
with the --dest argument, which takes the same form as --source.  Missing bits
in --dest are filled in with values from --source, so you can omit even more
parts, but you must specify a table.  You should probably create a table before
you try to store anything in it ;-)  This works for me, though you may need
something different if you decide you don't want all the columns of ouput:

 CREATE TABLE `deadlocks` (
   `server` char(20) NOT NULL,
   `ts` datetime NOT NULL,
   `thread` int unsigned NOT NULL,
   `txn_id` bigint unsigned NOT NULL,
   `txn_time` smallint unsigned NOT NULL,
   `user` char(16) NOT NULL,
   `hostname` char(20) NOT NULL,
   `ip` char(15) NOT NULL, -- alternatively, `ip` int unsigned NOT NULL
   `db` char(64) NOT NULL,
   `tbl` char(64) NOT NULL,
   `idx` char(64) NOT NULL,
   `lock_type` char(16) NOT NULL,
   `lock_mode` char(1) NOT NULL,
   `victim` tinyint unsigned NOT NULL,
   `query` text NOT NULL,
   PRIMARY KEY  (`server`,`ts`,`thread`)
 ) ENGINE=InnoDB

=head1 OUTPUT

If you print to standard output, query text whitespace is collapsed by default
so there is one line per query that deadlocked.  You can disable this with
--collapse=0.  When saving the query to a database table, whitespace is not
collapsed by default.  If you omit the --collapse argument altogether, the
script will probably do what you want in all cases.

Sometimes not all information (for example, username or IP address) is included
in the deadlock information.

You can choose which columns are ouput with the --columns argument.  The default
columns are as follows:

=over

=item server

The (source) server on which the deadlock occurred.  This might be useful if
you're tracking deadlocks on many servers.

=item ts

The date and time of the last detected deadlock.

=item thread

The MySQL thread number, which is the same as the connection ID in SHOW FULL
PROCESSLIST.

=item txn_id

The InnoDB transaction ID, which InnoDB expresses as two unsigned integers.  I
have multiplied them out to be one number.

=item txn_time

How long the transaction was active when the deadlock happened.

=item user

The connection's database username.

=item hostname

The connection's host.

=item ip

The connection's IP address.  If you give the --numip argument, this is
converted to an unsigned integer.

=item db

The database in which the deadlock occurred.

=item tbl

The table on which the deadlock occurred.

=item idx

The index on which the deadlock occurred.

=item lock_type

The lock type the transaction held on the lock that caused the deadlock.

=item lock_mode

The lock mode of the lock that caused the deadlock.

=item victim

Whether the transaction was selected as the deadlock victim and rolled back.

=item query

The query that caused the deadlock.

=back

=head1 BUGS

There must be bugs.  InnoDB's status information is a beast to parse.  I ripped
off some of the parsing code for innotop, but there still might be some things
wrong.  Please tell me when you find them.

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
