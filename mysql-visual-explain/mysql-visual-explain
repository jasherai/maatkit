#!/usr/bin/perl

# This is mysql-visual-explain, a program to transform MySQL's EXPLAIN output
# into a query execution plan formatted as a tree.
#
# This program is copyright (c) 2007 Baron Schwartz.  Feedback and
# improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
# ###########################################################################

# ###########################################################################
# Converts text (e.g. saved output) to a "recordset" -- an array of hashrefs
# -- just like EXPLAIN does for selectall_arrayref({}).
# ###########################################################################
package ExplainParser;

sub new {
   bless {}, shift;
}

sub parse_tabular {
   my ( $text, @cols ) = @_;
   my %row;
   my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
   return (undef, \@vals) unless @cols;
   @row{@cols} = @vals;
   return (\%row, undef);
}

sub parse_tab_sep {
   my ( $text, @cols ) = @_;
   my %row;
   my @vals = split(/\t/, $text);
   return (undef, \@vals) unless @cols;
   @row{@cols} = @vals;
   return (\%row, undef);
}

sub parse_vertical {
   my ( $text, @cols ) = @_;
   my %row = $text =~ m/^ *(\w+): ([^\n]*) *$/msg;
   return (\%row, undef);
}

sub parse {
   my ($self, $text) = @_;
   my $started = 0;
   my $lines   = 0;
   my @cols    = ();
   my @result  = ();

   # Detect which kind of input it is
   my ( $line_re, $vals_sub );
   if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      $line_re  = qr/^(\| .*)[\r\n]+/m;
      $vals_sub = \&parse_tabular;
   }
   elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
      $line_re  = qr/^(.*?\t.*)[\r\n]+/m;
      $vals_sub = \&parse_tab_sep;
   }
   elsif ( $text =~ m/\*\*\* 1. row/ ) { # "vertical" output
      $line_re  = qr/^( *.*?^ *Extra:[^\n]*$)/ms;
      $vals_sub = \&parse_vertical;
   }

   if ( $line_re ) {
      # Pull it apart into lines and parse them.
      LINE:
      foreach my $line ( $text =~ m/$line_re/g ) {
         my ($row, $cols) = $vals_sub->($line, @cols);
         if ( $row ) {
            foreach my $key ( keys %$row ) {
               if ( !$row->{$key} || $row->{$key} eq 'NULL' ) {
                  $row->{$key} = undef;
               }
            }
            push @result, $row;
         }
         else {
            @cols = @$cols;
         }
      }
   }

   return \@result;
}

# ###########################################################################
# Converts output of EXPLAIN into a human-readable tree.
# ###########################################################################
package ExplainTree;

use List::Util qw(max);
use Data::Dumper;

sub new {
   my ( $class, $options ) = @_;
   my $self = bless {}, $class;
   $self->load_options($options);
   return $self;
}

sub load_options {
   my ( $self, $options ) = @_;
   if ( $options && ref $options eq 'HASH' ) {
      @{$self}{keys %$options} = values %$options;
   }
   else {
      delete @{$self}{keys %$self};
   }
}

sub parse {
   my ( $self, $text, $options ) = @_;
   return $self->process(ExplainParser->new->parse($text), $options);
}

# The main method that turns a result set into a tree.
sub process {
   my ( $self, $rows, $options ) = @_;
   $self->load_options($options);
   return unless ref $rows eq 'ARRAY' && @$rows;
   my @nodes;

   # ##################################################################
   # EXPLAIN output has forward references, so this requires two passes,
   # one to generate subtrees from each row and one to resolve the refs.
   # ##################################################################

   my $rowid = 0;

   foreach my $row ( @$rows ) {
      $row->{Extra} ||= '';
      my $sub = $row->{type};

      # ##################################################################
      # Dispatch to a class method to generate the tree.
      # ##################################################################
      my $node
         = $sub                                 ? $self->$sub($row)
         : $row->{Extra} =~ m/No tables/        ? { type => 'DUAL' }
         : $row->{Extra} =~ m/Impossible WHERE/ ? { type => 'IMPOSSIBLE' }
         : $row->{Extra} =~ m/optimized away/   ? { type => 'CONSTANT' }
         :                                      die "Can't handle " . Dumper($row);

      # ##################################################################
      # Apply other tree transformations.
      # ##################################################################
      if ( $row->{Extra} =~ m/Using where/ ) {
         $node = {
            type     => 'Filter with WHERE',
            children => [$node],
         };
      }
      if ( $row->{Extra} =~ m/Using temporary/ ) {
         $node = {
            type     => 'Table scan',
            rows     => undef,
            children => [
               {  type          => 'TEMPORARY',
                  table         => "temporary($row->{table})",
                  possible_keys => undef,
                  partitions    => undef,
                  children      => [$node],
               }
            ],
         };
      }
      if ( $row->{Extra} =~ m/Distinct|Not exists/ ) {
         $node = {
            type     => 'Distinct/Not-Exists',
            children => [$node],
         };
      }
      if ( $row->{Extra} =~ m/Using filesort/ ) {
         $node = {
            type     => 'Filesort',
            children => [$node],
         };
      }
      if ( $row->{Extra} =~ m/Using join buffer/ ) {
         $node = {
            type     => 'Join buffer',
            children => [$node],
         };
      }

      # Add some data that will help me keep track of nodes as I manipulate
      # them later
      $node->{id}    = $row->{id};
      $node->{rowid} = $rowid;
      $node->{row}   = $row;

      push @nodes, $node;

      $rowid++;
   }

   # Build a tree from the node list by fixing nodes whose table references need
   # to be resolved.  Remove the referenced nodes from the flat list and make
   # them children of their parents ("push them down").  Because of the way
   # unions and derived tables can be nested (study the EXPLAIN of a union of
   # derived tables of unions), this process has to alternate between unions and
   # derived tables, resolving union results first, and resolving things that
   # don't refer to unresolved things first.
   #
   # Therefore, when a union is resolved I "pull up" information from its child
   # nodes: its id and select_type come from its first child, and its table
   # becomes the concatenation of its child tables.  This convoluted process is
   # necessary because there are both forward and backward references.
   #
   # Strict alternation between union and derived is necessary because a) there
   # is no such thing as a union of unions and b) I can't try to resolve derived
   # tables twice in a row without resolving potential unions within them.

   my $op        = 'UNION';
   my $i         = 0;
   my $this_time = 0;
   my $last_time = 1; # Don't quit if first run doesn't do anything
   while ( $i < @nodes ) {
      my $result = $self->resolve_dependencies(\@nodes, $nodes[$i], $nodes[$i], $op);
      $this_time ||= $result;
      $i = max(0, $i - $result + 1); # May redo nodes, but won't skip any.
      if ( $i >= @nodes ) {
         if ( $this_time || $last_time ) {
            $op = $op eq 'UNION' ? 'DERIVED' : 'UNION';
            $i  = 0;
         }
         $last_time = $this_time;
         $this_time = 0;
      }
   }

   # Resolve joins in the main node list.
   my $tree = $self->build_join_tree(@nodes);

   # Recurse the tree again for more tree transformations.
   my @stack = $tree;
   while ( @stack ) {
      my $node = shift @stack;

      if ( $node->{children} ) {
         unshift @stack, @{$node->{children}};
      }

      if ( $node->{type} eq 'DERIVED' ) {
         $node->{children} = [ $self->build_join_tree(@{$node->{children}}) ];
      }

      # Get rid of temp variables.
      delete $node->{row};
   }

   return $tree;
}

sub pretty_print {
   my ( $self, $node, $prefix ) = @_;
   $prefix ||= '';
   my $branch = $prefix ? substr($prefix, 0, length($prefix) -3) . '+- ' : '';
   my $output = $branch . $node->{type} . "\n";

   my @kids;
   if ( $node->{children} ) {
      @kids   = reverse @{$node->{children}};
   }
   my $suffix = (@kids > 1) ? '|  ' : '   ';

   foreach my $thing ( qw(table key partitions possible_keys method key_len ref rows warning) ) {
      if ( defined $node->{$thing} ) {
         $output .= $prefix . sprintf('%-14s %s', $thing, $node->{$thing}) . "\n";
      }
   }

   my $last_child = pop @kids;
   foreach my $child ( @kids ) {
      $output .= $self->pretty_print($child, $prefix . $suffix);
   }
   if ( $last_child ) {
      $output .= $self->pretty_print($last_child, $prefix . '   ');
   }
   return $output;
}

#############################################################################
# Each method in this section corresponds to a value you will find in the 'type'
# column in EXPLAIN.
#############################################################################

sub ALL {
   my ( $self, $row ) = @_;
   return {
      type     => 'Table scan',
      rows     => $row->{rows},
      children => [$self->table($row)],
   };
}

sub range {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index range scan');
}

sub index {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index scan');
}

sub eq_ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Unique index lookup');
}

sub ref {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup');
}

sub ref_or_null {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index lookup with extra null lookup');
}

sub const {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Constant index lookup');
}

sub system {
   my ( $self, $row ) = @_;
   return {
      type => 'Constant table access',
      rows     => $row->{rows},
      children => [$self->table($row)],
   };
}

sub unique_subquery {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Unique subquery');
}

sub index_subquery {
   my ( $self, $row ) = @_;
   return $self->index_access($row, 'Index subquery');
}

# From the manual: "The Index Merge method is used to retrieve rows with
# several range scans and to merge their results into one."  Therefore each
# index access should be shown as an index range scan.  The unions and
# intersections can be recursive, as in
# union(intersect(key1,key2),intersect(key3,key4))
sub index_merge {
   my ( $self, $row ) = @_;
   my ( $merge_spec )
      = $row->{Extra} =~ m/Using ((?:intersect|union|sort_union)\(.*?\))(?=;|$)/;
   my ($merge, $num) = $self->recurse_index_merge($row, $merge_spec, 0);

   # index_merge_bookmark_lookup note:
   # From the manual, "If the used indexes don't cover all columns used in the
   # query, full rows are retrieved only when the range conditions for all
   # used keys are satisfied."  So a bookmark lookup shouldn't be shown for
   # all indexes; it should be shown from the merge results.
   return $self->bookmark_lookup($merge, $row);
}

# ###########################################################################
# Helper subroutines.
# ###########################################################################

sub has_unresolved_dependencies {
   my ( $self, $node ) = @_;
   if ( $node->{table} && $node->{table} =~ m/^<(?:union|derived)(?:\d+,?)+>$/ ) {
      return 1;
   }
   if ( $node->{children} ) {
      foreach my $child ( @{$node->{children}} ) {
         if ( $self->has_unresolved_dependencies($child) ) {
            return 1;
         }
      }
   }
}

# Takes all nodes, a top-level node, a node, and a kind (union/derived), and
# returns the number of rows it moved.  Does not resolve dependencies if it
# would change something that has dependencies in turn.

sub resolve_dependencies {
   my ( $self, $nodes, $tl, $node, $kind ) = @_;
   my $changes = 0;
   if ( $node->{type} eq $kind && !$node->{children}
         && $self->has_unresolved_dependencies($node) )
   {
      my @ids = $node->{table} =~ m/(\d+)/g;
      my @kids;
      foreach my $id ( @ids ) {
         push @kids, grep { $_->{id} && $_->{id} == $id } @$nodes;
      }

      # Check that kids don't contain any references themselves.
      if ( !grep { $self->has_unresolved_dependencies($_) } @kids ) {

         # "Push down" children.
         $node->{children} = [@kids];
         my %child_row_ids = map { $_->{rowid} => 1 } @kids;
         my $before = scalar @$nodes;
         @$nodes = grep { !$child_row_ids{$_->{rowid}} } @$nodes;

         # "Pull up" information from the children.
         if ( $kind eq 'UNION' ) {
            # UNION RESULT rows don't have a value for the 'id' column, so derived
            # tables over the union won't be able to find their children unless
            # I pull this info up.  They also need a select_type for the
            # build_join_tree() method.
            $tl->{id}          = $kids[0]->{row}->{id};
            $tl->{row}->{select_type} = $kids[0]->{row}->{select_type};
         }
         $node->{table}
            = lc($kind) . '(' . join(',', map { $_->{row}->{table} } @kids) . ')';
         $tl->{row}->{table} = $node->{table};
         return $before - scalar @$nodes;
      }

   }

   if ( $node->{children} ) {
      foreach my $child ( @{$node->{children}} ) {
         $changes += $self->resolve_dependencies($nodes, $tl, $child, $kind);
      }
   }

   return $changes;
}

# The rules seem to be that all rows with the same 'id' value are JOINED.  After
# that, adjacent rows are 'join'ed with some other kind of join, like a
# subquery.
sub build_join_tree {
   my ( $self, @nodes ) = @_;

   # Grab the first row for each 'id' value.
   my %seen;
   my @top_level = grep { !$seen{$_->{id}}++ } @nodes;

   # Build a tree for each 'id' value.
   my @subtrees;
   foreach my $id ( map { $_->{id} } @top_level ) {
      my ($tree, @sub_nodes) = grep { $_->{id} eq $id } @nodes;
      foreach my $node ( @sub_nodes ) {
         $tree = {
            type     => 'JOIN',
            children => [ $tree, $node ],
         };
      }
      push @subtrees, $tree;
   }

   # Now join the list of subtrees together with the specified join type.
   my $tree = shift @subtrees;
   shift @top_level;
   foreach my $i ( 0 .. $#subtrees ) {
      $tree = {
         type     => $top_level[$i]->{row}->{select_type},
         children => [ $tree, $subtrees[$i] ],
      };
   }

   return $tree;
}

# $num is the number of nodes to the left of this node in a depth-first
# traversal.  It lets me figure out which value goes in key_len.
sub recurse_index_merge {
   my ( $self, $row, $spec, $num ) = @_;
   my ($type, $args) = $spec =~ m/(intersect|union|sort_union)\((.*)\)$/;

   my @children;

   # See 'man perlre' and search for 'matches a parenthesized group'.
   my $bal;
   $bal = qr/
      \(
      (?:
         (?> [^()]+ )    # Non-parens without backtracking
         |
         (??{ $bal })     # Group with matching parens
      )*
      \)
   /x;

   # Extract a thing, followed by balanced parentheses.
   foreach my $child ( $args =~ m/(\w+$bal)/g ) {
      my ( $subtree, $num ) = $self->recurse_index_merge($row, $child, $num);
      push @children, $subtree;
   }

   if ( !@children ) { # Recursion base case; $args is an index list
      foreach my $idx ( split(/,/, $args) ) {
         my $index_scan = $self->index_access($row, 'Index range scan', $idx);
         $index_scan->{key_len} = ($row->{key_len} =~ m/(\d+)/g)[$num++];
         push @children, $index_scan;
      }
   }

   return (
      {
         type     => 'Index merge',
         method   => $type,
         rows     => $row->{rows},
         children => \@children,
      },
      $num
   );

}

sub table {
   my ( $self, $row ) = @_;
   my $node = {
      type          => ($row->{table} && $row->{table} =~ m/^<(derived|union)/)
                       ? uc $1
                       : 'Table',
      table         => $row->{table},
      possible_keys => $row->{possible_keys},
      partitions    => $row->{partitions},
   };
   if ( $row->{Extra} =~ m/(Range checked [^)]*\))/ ) {
      $node->{warning} = $1;
   }
   return $node;
}

sub bookmark_lookup {
   my ( $self, $node, $row ) = @_;
   if ( $row->{Extra} =~ m/Using index/
         || ( $self->{clustered} && $row->{key} && $row->{key} eq 'PRIMARY' ))
   {
      return $node;
   }
   return {
      type     => 'Bookmark lookup',
      children => [ $node, $self->table($row) ],
   };
}

sub index_access {
   my ( $self, $row, $type, $key ) = @_;
   my $node = {
      type          => $type,
      key           => $row->{table} . '->' . ( $key || $row->{key} ),
      possible_keys => $row->{possible_keys},
      partitions    => $row->{partitions},
      key_len       => $row->{key_len},
      'ref'         => $row->{ref},
      rows          => $row->{rows},
   };
   if ( $row->{Extra} =~ m/Full scan on NULL key/ ) {
      $node->{warning} = 'Full scan on NULL key';
   }
   if ( $row->{Extra} =~ m/Using index for group-by/ ) {
      $node->{type} = 'Loose index scan';
   }
   # See index_merge_bookmark_lookup note above.
   if ( $row->{type} ne 'index_merge' ) {
      $node = $self->bookmark_lookup($node, $row);
   }
   return $node;
}

# ###########################################################################
# And now for the "program".
# ###########################################################################
package main;

use DBI;
use English qw(-no_match_vars);
use List::Util qw(max);
use Getopt::Long;

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", q$Revision$ =~ m/(\d+)/g);

if ( !caller ) {

   # ############################################################################
   # Get configuration information.
   # ############################################################################

   # Define cmdline args.
   my @opt_spec = (
      { s => 'clusterpk|C',       d => 'Assume clustered PK, as for InnoDB' },
      { s => 'connect|c',         d => 'Connect and EXPLAIN the input, then transform' },
      { s => 'database|D=s',      d => 'Database to use' },
      { s => 'defaults-file|F=s', d => 'Only read default options from the given file' },
      { s => 'help',              d => 'Show this help message' },
      { s => 'host|h=s',          d => 'Connect to host' },
      { s => 'password|p=s',      d => 'Password to use when connecting' },
      { s => 'port|P=i',          d => 'Port number to use for connection' },
      { s => 'socket|S=s',        d => 'Socket file to use for connection' },
      { s => 'user|u=s',          d => 'User for login if not current user' },
      { s => 'version',           d => 'Output version information and exit' },
   );

   # This is the container for the command-line options' values to be stored in
   # after processing.  Initial values are defaults.
   my %opts = (
   );

   # Post-process...
   my %opt_seen;
   foreach my $spec ( @opt_spec ) {
      my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
      $spec->{k} = $short || $long;
      $spec->{l} = $long;
      $spec->{t} = $short;
      $spec->{n} = $spec->{s} =~ m/!/;
      $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
      die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
   }

   Getopt::Long::Configure('no_ignore_case', 'bundling');
   GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

   if ( $opts{version} ) {
      print "mysql-visual-explain  Ver $VERSION Distrib $DISTRIB Changeset $SVN_REV\n";
      exit(0);
   }

   if ( $opts{help} ) {
      print "Usage: mysql-visual-explain <options> [FILE]...\n\n";
      my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
      foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
         my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
         my $short = $spec->{t} ? "-$spec->{t}" : '';
         printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
      }
      (my $usage = <<"      USAGE") =~ s/^      //mg;

      mysql-visual-explain transforms EXPLAIN output into a tree representation
      of the query plan.  If FILE is given, input is read from the file(s).
      With no FILE, or when FILE is -, read standard input.  For more details,
      please read the documentation:

         perldoc mysql-visual-explain

      USAGE
      print $usage;
      exit(0);
   }

   # ############################################################################
   # Do the main work.
   # ############################################################################
   # Magically read STDIN or files in @ARGV
   my $text = do { local $INPUT_RECORD_SEPARATOR = undef; <>; };
   my $rows;

   if ( $opts{c} ) { # Connect to the database
      my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');

      my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
         . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(F h P S))
         . ';mysql_read_default_group=mysql';
      my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
         or die("Can't connect to DB: $OS_ERROR");
      $text =~ s{^.*?select}{EXPLAIN /*!50115 PARTITIONS*/ SELECT}is;
      $rows = $dbh->selectall_arrayref($text, { Slice => {} } );
      $dbh->disconnect;
   }
   else {
      $rows = ExplainParser->new->parse($text);
   }

   my $et   = ExplainTree->new();
   my $tree = $et->process($rows, { clustered => $opts{C} });
   if ( $tree ) {
      print $et->pretty_print($tree);
   }
}

1; # Because this is a module as well as a script.

# ############################################################################
# Documentation.
# ############################################################################

=pod

=head1 NAME

mysql-visual-explain - Format EXPLAIN output as a tree.

=head1 SYNOPSIS

 mysql-visual-explain <file_containing_explain_output>
 mysql-visual-explain -c <file_containing_query>
 mysql -e "explain select * from mysql.user" | mysql-visual-explain

=head1 DESCRIPTION

MySQL Visual Explain reverse-engineers MySQL's EXPLAIN output into a query
execution plan, which it then formats as a left-deep tree -- the same way the
plan is represented inside MySQL.  It is possible to do this by hand, or to read
EXPLAIN's output directly, but it requires patience and expertise.  Many people
find a tree representation more understandable.

You can pipe input into MySQL Visual Explain or specify a filename at the
command line, including the magical '-' filename, which will read from standard
input.  It can do two things with the input: parse it for something that looks
like EXPLAIN output, or connect to a MySQL instance and run EXPLAIN on the
input.

When parsing its input, MySQL Visual Explain understands three formats: tabular
like that shown in the mysql command-line client, vertical like that created by
using the \G line terminator in the mysql command-line client, and tab
separated.  It ignores any lines it doesn't know how to parse.

When executing the input, MySQL Visual Explain replaces everything in the input
up to the first SELECT keyword with 'EXPLAIN SELECT,' and then executes the
result.  You must specify L<"--connect"> to execute the input as a query.

Either way, it builds a tree from the result set and prints it to standard
output.  For the following query,

 select * from sakila.film_actor join sakila.film using(film_id);

MySQL Visual Explain generates this query plan:

 JOIN
 +- Bookmark lookup
 |  +- Table
 |  |  table          film_actor
 |  |  possible_keys  idx_fk_film_id
 |  +- Index lookup
 |     key            film_actor->idx_fk_film_id
 |     possible_keys  idx_fk_film_id
 |     key_len        2
 |     ref            sakila.film.film_id
 |     rows           2
 +- Table scan
    rows           952
    +- Table
       table          film
       possible_keys  PRIMARY

The query plan is left-deep, depth-first search, and the tree's root is the
output node -- the last step in the execution plan.  In other words, read it
like this:

=over

=item 1

Table scan the 'film' table, which accesses an estimated 952 rows.

=item 2

For each row, find matching rows by doing an index lookup into the
film_actor->idx_fk_film_id index with the value from sakila.film.film_id, then a
bookmark lookup into the film_actor table.

=back

For more information on how to read EXPLAIN output, please see
L<http://dev.mysql.com/doc/en/explain.html>, and this talk titled "Query
Optimizer Internals and What's New in the MySQL 5.2 Optimizer," from Timour
Katchaounov, one of the MySQL developers:
L<http://conferences.oreillynet.com/presentations/mysql07/katchaounov_timour.pdf>.

=head1 OPTIONS

=over

=item --clusterpk

Assume that PRIMARY KEY index accesses don't need to do a bookmark lookup to
retrieve rows.  This is the case for InnoDB.

=item --connect

Treat input as a query, and obtain EXPLAIN output by connecting to a MySQL
instance and running EXPLAIN on the query.  When this option is given, MySQL
Visual Explain uses the other connection-specific options such as L<"--user"> to
connect to the MySQL instance.  If you have a .my.cnf file, it will read it, so
you may not need to specify any connection-specific options.

=item --database

Connect to this database.

=item --defaults-file

If you specify this option, only this file is read for MySQL default options;
otherwise all the default files will be read.

=item --help

Displays a help message.

=item --host

MySQL host to connect to.

=item --password

The password to use when connecting.

=item --port

The port number to use for the connection.

=item --socket

The socket file to use for the connection.

=item --user

MySQL user account to use for the connection.

=item --version

Output version information and exit.

=back

=head1 MODULES

This program is actually a runnable module, not just an ordinary Perl script.
In fact, there are two modules embedded in it.  This makes unit testing easy,
but it also makes it easy for you to use the parsing and tree-building
functionality if you want.

The ExplainParser package accepts a string and parses whatever it thinks looks
like EXPLAIN output from it.  The synopsis is as follows:

 require "mysql-visual-explain";
 my $p    = ExplainParser->new();
 my $rows = $p->parse("some text");
 # $rows is an arrayref of hashrefs.

The ExplainTree package accepts a set of rows and turns it into a tree.  For
convenience, you can also have it delegate to ExplainParser and parse text for
you.  Here's the synopsis:

 require "mysql-visual-explain";
 my $e      = ExplainTree->new();
 my $tree   = $e->parse("some text", \%options);
 my $output = $e->pretty_print($tree);
 print $tree;

=head1 SEE ALSO

See also L<mysql-query-profiler>.

=head1 BUGS

Please use the Sourceforge bug tracker, forums, and mailing lists to request
support or report bugs: L<http://sourceforge.net/projects/mysqltoolkit/>.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

=head1 AUTHOR

Baron "Xaprb" Schwartz.

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 VERSION

This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision$.

=cut
