#!/usr/bin/perl

# This is mysql-table-maintainer, a program to run table maintenance
# statements against MySQL tables.
# 
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# TODO: restrict to certain engine?

my @opt_spec = (
   { s => 'analyze|a',        d => 'Run ANALYZE TABLE' },
   { s => 'check|c',          d => 'Run CHECK TABLE' },
   { s => 'databases|d=s',    d => 'Only do this comma-separated list of databases' },
   { s => 'debug|b',          d => 'Print SQL statements executed' },
   { s => 'help',             d => 'Show this help message' },
   { s => 'host|h=s',         d => 'Connect to host' },
   { s => 'ignoredb|g=s',     d => 'Ignore this comma-separated list of databases' },
   { s => 'ignoretbl|n=s',    d => 'Ignore this comma-separated list of tables' },
   { s => 'writetobinlog|w!', d => 'Write the statement to the binlog (default)' },
   { s => 'optimize|o',       d => 'Run OPTIMIZE TABLE' },
   { s => 'password|p=s',     d => 'Password to use when connecting' },
   { s => 'port|P=i',         d => 'Port number to use for connection' },
   { s => 'repair|r',         d => 'Run REPAIR TABLE' },
   { s => 'socket|S=s',       d => 'Socket file to use for connection' },
   { s => 'tables|t=s',       d => 'Only do this comma-separated list of tables' },
   { s => 'user|u=s',         d => 'User for login if not current user' },
   { s => 'views|v!',         d => 'Do views also (default)' }, # TODO
);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   d => '',
   g => '',
   t => '',
   n => '',
   w => 1,
);
# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g}) };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n}) };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}

if ( $opts{help} ) {
   print "Usage: $PROGRAM_NAME <options>\n\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-13s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

$PROGRAM_NAME runs table maintenance commands on MySQL tables.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################
my %conn = ( h => 'host', P => 'port', S => 'socket');

# Connect to the database
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(h P S))
   . ';mysql_read_default_group=mysql';
my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

my @databases = @{$dbh->selectcol_arrayref('SHOW DATABASES')};
my @whole_batch;
my $exit_code;

my %code_for = (
   ANALYZE  => \&make_analyze_query,
   CHECK    => \&make_check_query,
   OPTIMIZE => \&make_optimize_query,
   REPAIR   => \&make_repair_query,
);

DATABASE:
foreach my $database ( @databases ) {

   # Ignore databases as instructed.  Also ignore INFORMATION_SCHEMA and skip
   # databases caused by lost+found directories created in the root of ext3
   # filesystems; they are not really databases.
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^(information_schema|lost\+found)$/mi
      || exists $opts{g}->{$database};

   my $query = "SHOW TABLE STATUS FROM `$database`";
   debug_print($query);
   my @tables = @{$dbh->selectall_arrayref($query, { Slice => {} })};
   next DATABASE unless @tables;

   my @to_print;

   TABLE:
   foreach my $spec ( @tables ) {
      my $table = $spec->{Name};
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || exists $opts{n}->{$table};

      $exit_code = 1;

      ACTION:
      foreach my $action ( qw(ANALYZE CHECK OPTIMIZE REPAIR) ) {
         if ( $opts{lc(substr($action, 0, 1))} ) { # 1st letter same as option
            my $query = $code_for{$action}->($database, $table, $spec);
            next ACTION unless $query;
            debug_print($query);
            my $res = $dbh->selectall_arrayref($query, { Slice => {} } );
            push @to_print, map {
               {  db   => $database,
                  tbl  => $table,
                  eng  => $spec->{Engine} || $spec->{Comment},
                  op   => $_->{Op},
                  type => $_->{Msg_type},
                  msg  => $_->{Msg_text},
               }
            } @$res;
         }
      }
   }

   next DATABASE unless @to_print;

   print_batch(@to_print);
}

exit($exit_code);

# ############################################################################
# Subroutines
# ############################################################################

# See http://dev.mysql.com/doc/refman/4.1/en/analyze-table.html
sub make_analyze_query {
   my ( $database, $table, $spec ) = @_;

   if ( $spec->{Engine}
      && ( $spec->{Engine} =~ m/^(?:MyISAM|BDB)$/
         || ( $spec->{Engine} eq 'InnoDB' && version_ge('4.0.13'))))
   {
      my $binlog = make_binlog_option();
      my $query = "ANALYZE $binlog TABLE `$database`.`$table`";
      return $query;
   }
}

# See http://dev.mysql.com/doc/refman/4.1/en/optimize-table.html
# and http://dev.mysql.com/doc/refman/5.0/en/archive-storage-engine.html
sub make_optimize_query {
   my ( $database, $table, $spec ) = @_;

   if ( $spec->{Engine}
      && ( $spec->{Engine} =~ m/^(?:MyISAM|BDB|InnoDB)$/
         || ( $spec->{Engine} eq 'ARCHIVE' && version_ge('5.0.16'))))
   {
      my $binlog = make_binlog_option();
      my $query = "OPTIMIZE $binlog TABLE `$database`.`$table`";
      return $query;
   }
}

# TODO use a conditional comment
sub make_binlog_option {
   return !$opts{m} && version_ge('4.1.1') ? 'NO_WRITE_TO_BINLOG' : '';
}

# Compares versions like 5.0.27 and 4.1.15-standard-log
sub version_ge {
   my ( $target ) = @_;
   my @version = $dbh->{mysql_serverinfo} =~ m/(\d+)/g;
   my @target  = $target  =~ m/(\d+)/g;
   return $version[0] >= $target[0]
       && $version[1] >= $target[1]
       && $version[2] >= $target[2];
}

# All output has to be prefixed with SQL comments so the output can be piped
# right into MySQL if desired.
sub debug_print {
   print '-- ', @_, "\n" if $opts{b};
}

sub print_batch {
   my ( @batch ) = @_;

   my $max_db   = max( 8, map { length( $_->{db} ) } @batch );
   my $max_tbl  = max( 5, map { length( $_->{tbl} ) } @batch );
   my $max_op   = max( 2, map { length( $_->{op} ) } @batch );
   my $max_type = max( 4, map { length( $_->{type} ) } @batch );
   my $hdr      = "%-${max_db}s %-${max_tbl}s %-6s %-${max_op}s %-${max_type}s %s\n";

   printf($hdr, qw(DATABASE TABLE ENGINE OP TYPE MSG));
   foreach my $thing ( @batch ) {
      printf($hdr, @{$thing}{qw(db tbl eng op type msg)});
   }

}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-duplicate-index-checker - Find possible duplicate indexes and foreign keys on
MySQL tables.

=head1 DESCRIPTION

This program examines the output of SHOW CREATE TABLE on MySQL tables, and if
it finds indexes that a) cover the same columns as another index in the same
order, or b) cover an exact leftmost prefix of another index, it prints out
the suspicious indexes.  By default, indexes must be of the same type, so a
BTREE index is not a duplicate of a FULLTEXT index, even if they have the same
colums.  You can override this.

It also looks for duplicate foreign keys.  A duplicate foreign key covers the
same columns as another in the same table, and references the same parent
table.

If possible, it will read your .my.cnf file so you don't have to specify
username and password.

By default it scans every table in every database, and prints out every
duplicated index and foreign key.  You can specify only to check foreign keys
or indexes.  You can also tell it to check only certain databases and tables,
ignore databases and tables, and so on.

You can specify to print out every index and/or foreign key without checking
for duplicates.  This is an easy way to get a full listing, and it's pretty
fast, since SHOW CREATE TABLE is very quick.

=head1 OUTPUT

Output is to STDOUT, one line per server and table, with header lines for each
database.  I tried to make the output easy to process with awk.  For this reason
columns are always present.  If there's no value, the script prints 'NULL'.

The default is column-aligned output for human readability, but you can change
it to tab-separated.  Output is sorted by database and table.

The columns in the output are as follows.

=over

=item DATABASE

The database the table is in.

=item TABLE

The table name.

=item ENGINE

The table's storage engine.

=item OBJECT

The index or constraint's name, e.g. `tbl_ibfk_3` (the default InnoDB name for
the third foreign key on a table named tbl).

=item TYPE

'KEY' for indexes, 'FK' for foreign keys.

=item STRUCT

The type of index: BTREE, FULLTEXT, HASH etc.  By default MySQL's indexes are
BTREE in most cases.  This does not apply to foreign keys.

=item PARENT

The parent table to which the foreign key constraint refers.  This does not
apply to indexes.

=item COLUMNS

The columns included in the index or foreign key constraint.  For indexes,
this column list is output verbatim, as shown in SHOW CREATE TABLE.  For
foreign keys, the columns are ordered so string comparison can find
duplicates, since column order in a foreign key is immaterial.

=back

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI, DBD::mysql, and Term::ReadKey.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
