#!/usr/bin/perl

# This is mysql-table-maintainer, a program to run table maintenance
# statements against MySQL tables.
# 
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max maxstr);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# TODO: include ability to issue ALTER engine=engine for older versions.

my @opt_spec = (
   { s => 'analyze|a',        d => 'Run ANALYZE TABLE' },
   { s => 'check|c',          d => 'Run CHECK TABLE' },
   { s => 'checkoptimize|z',  d => 'Run OPTIMIZE if CHECK found NO problems (implies -co) '},
   { s => 'checkopts=s',      d => 'Options to CHECK TABLE' },
   { s => 'checkrepair|k',    d => 'Run REPAIR if CHECK found problems (implies -cr) '},
   { s => 'databases|d=s',    d => 'Only do this comma-separated list of databases' },
   { s => 'debug|b',          d => 'Print SQL statements executed' },
   { s => 'engines|e=s',      d => 'Only do this comma-separated list of engines' },
   { s => 'help',             d => 'Show this help message' },
   { s => 'host|h=s',         d => 'Connect to host' },
   { s => 'ignoredb|g=s',     d => 'Ignore this comma-separated list of databases' },
   { s => 'ignoretbl|n=s',    d => 'Ignore this comma-separated list of tables' },
   { s => 'longnum|l',        d => 'Do not shorten size and row count' },
   { s => 'minsize|m=s',      d => 'Ignore tables smaller than SIZE' },
   { s => 'minage=s',         d => 'Ignore tables newer than TIME' },
   { s => 'optimize|o',       d => 'Run OPTIMIZE TABLE' },
   { s => 'password|p=s',     d => 'Password to use when connecting' },
   { s => 'port|P=i',         d => 'Port number to use for connection' },
   { s => 'quiet|q+',         d => 'Be quieter.  Specify twice for no output' },
   { s => 'repairopts=s',     d => 'Options to REPAIR TABLE' },
   { s => 'repair|r',         d => 'Run REPAIR TABLE' },
   { s => 'socket|S=s',       d => 'Socket file to use for connection' },
   { s => 'stoponerror',      d => 'Stop if there is an error' },
   { s => 'tables|t=s',       d => 'Only do this comma-separated list of tables' },
   { s => 'user|u=s',         d => 'User for login if not current user' },
   { s => 'views|v',          d => 'Do views also' },
   { s => 'nobinlog|w!',      d => 'Do not write the statement to the binlog' },
);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   d => '',
   g => '',
   t => '',
   n => '',
   w => 1,
);
# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# Process some options...
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g}) };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n}) };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}
if ( $opts{k} ) {
   $opts{c} = $opts{r} = 1;
}
if ( $opts{z} ) {
   $opts{c} = $opts{o} = 1;
}
# Convert sizes into units
if ( $opts{m} ) {
   $opts{m} = lengthen($opts{m});
}
# Convert time into datetime string
if ( $opts{minage} ) {
   $opts{minage} = to_datetime($opts{minage});
}

# You gotta tell me what to do...
$opts{help} = 1 unless $opts{a} || $opts{c} || $opts{o} || $opts{r};

if ( $opts{help} ) {
   print "Usage: $PROGRAM_NAME <options>\n\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-13s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

$PROGRAM_NAME runs table maintenance commands on MySQL tables.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################
my %conn = ( h => 'host', P => 'port', S => 'socket');

# Connect to the database
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(h P S))
   . ';mysql_read_default_group=mysql';
my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

my $ok_pattern = qr/^(?:OK|Table is already up to date)$/;

my %code_for = (
   a => \&make_analyze_query,
   c => \&make_check_query,
   o => \&make_optimize_query,
   r => \&make_repair_query,
);

my @databases = @{$dbh->selectcol_arrayref('SHOW DATABASES')};
DATABASE:
foreach my $database ( @databases ) {

   # Ignore databases as instructed.  Also ignore INFORMATION_SCHEMA and skip
   # databases caused by lost+found directories created in the root of ext3
   # filesystems; they are not really databases.
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^(information_schema|lost\+found)$/mi
      || exists $opts{g}->{$database};

   my $query = "SHOW TABLE STATUS FROM `$database`";
   debug_print($query);
   my @tables = @{$dbh->selectall_arrayref($query, { Slice => {} })};
   next DATABASE unless @tables;

   my $max_db  = max( 8, length($database));
   my $max_tbl = max( 5, map { length( $_->{Name} ) } @tables );
   my $hdr     = "%-${max_db}s %-${max_tbl}s %-7s %6s %6s %6s %-8s %-8s %3s %4s %s\n";
   my $printed = 0;

   TABLE:
   foreach my $spec ( @tables ) {
      my $table = $spec->{Name};
      my $engine = $spec->{Engine}
                 || ($spec->{Comment} eq 'VIEW' ? 'VIEW' : 'NULL');
      my $size   = $spec->{Data_length}
                 ? (($spec->{Data_length} || 0) + ($spec->{Index_length} || 0))
                 : undef;
      my $ibfree = $spec->{Engine} && $spec->{Engine} eq 'InnoDB'
                   && $spec->{Comment} && $spec->{Comment} =~ m/InnoDB free: (\d+) kB/
                 ? lengthen("${1}k")
                 : undef;

      my $needs_repair = 0;

      # Detect crashed tables, which should certainly be repaired if needed.  A
      # typical comment in a crashed table:
      # Table './test/smallhist' is marked as crashed and should be repaired
      if ( $spec->{Comment} =~ m/marked as crashed/ ) {
         my ( $db, $tbl ) = $spec->{Comment} =~ m{Table './(\w+)/(\w+)' is marked};
         if ( $db eq $database && $tbl eq $table ) {
            # It's the same table, so it's this table (as opposed to a view
            # complaining about a base table on which it depends).
            $needs_repair = 1;
         }
         else {
            # It is a view after all, but the Comment saying VIEW has been
            # replaced with the text of the problem.
            $engine = 'VIEW';
         }
      }

      my $tbl_time = maxstr( '', map { $_ || '' } @{$spec}{qw(Check_time Create_time Update_time)});

      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || exists $opts{n}->{$table}
         || ($opts{e} && $engine !~m/NULL|VIEW/ && !exists $opts{e}->{lc $engine})
         || ($opts{m} && (!$size || $size < $opts{m}))
         || ($opts{minage} && $tbl_time && $tbl_time gt $opts{minage})
         || ($engine eq 'VIEW' && !$opts{v});

      ACTION:
      foreach my $action ( grep { defined $opts{$_} } qw(a c o r) ) { # ANALYZE CHECK OPTIMIZE REPAIR

         if (  ($action eq 'r' && $opts{k} && !$needs_repair)
            || ($action eq 'o' && $opts{z} && $needs_repair) ) {
            next ACTION;
         }

         my $query = $code_for{$action}->($database, $table, $engine);
         next ACTION unless $query;
         debug_print($query);
         my $start = time();
         my $res = eval { $dbh->selectall_arrayref($query, { Slice => {} } ) };
         exit(1) if $opts{stoponerror} && $EVAL_ERROR; # Already printed by DBI
         next ACTION unless $res;
         my $time_str = sprintf('%d', time() - $start);

         # Sometimes there are a ton of repeated messages, so I try to
         # collapse them into one with a count.
         my %to_print;
         my $order = 0;
         foreach my $row ( @$res ) {
            my $key = join(',', @{$row}{ qw(Msg_type Msg_text) });
            if ( $to_print{$key} ) {
               $to_print{$key}->{count}++;
            }
            else {
               $row->{order} = $order++;
               $row->{count} = 1;
               $to_print{$key} = $row;
            }
         }

         foreach my $row ( sort { $a->{order} <=> $b->{order} } values %to_print ) {
            if ( !$opts{q} || ($opts{q} <= 1 && $row->{Msg_text} !~ m/$ok_pattern/ )) {
               printf($hdr, qw(DATABASE TABLE ENGINE SIZE IBFREE ROWS OP TYPE CNT TIME MSG))
                  unless $printed++;
               printf($hdr, $database, $table, $engine, shorten($size || 0),
                  shorten($ibfree || 0),
                  shorten($spec->{Rows} || 0), $row->{Op}, $row->{Msg_type}, $row->{count},
                  $time_str, $row->{Msg_text});
            }
         }

         # Check the LAST row to see whether table needs repair.  Last ROW,
         # not last %to_print value.
         if ( $action eq 'c' ) {
            my $msg = $res->[ scalar(@$res) - 1 ]->{Msg_text};
            if ( $engine ne 'VIEW' && $msg !~ m/$ok_pattern/ ) {
               $needs_repair = 1;
            }
         }

      }
   }

}

exit(0);

# ############################################################################
# Subroutines
# ############################################################################

sub to_datetime {
   my ( $str ) = @_;

   # Maybe it's already in some fragment of YYYY-MM-DD HH:MM:SS format.
   my ( $year, $mon, $day, $hour, $min, $sec )
      = $str =~ m/
         ^
         (\d{4})     # Year
         (?:-
            (\d{2})  # Mon
         )?
         (?:-
            (\d{2})  # Day
         )?
         (?:[\sT]
            (\d{2})  # Hour
         )?
         (?::
            (\d{2})  # Min
         )?
         (?::
            (\d{2})  # Sec
         )?
         $/xms;
   if ( !defined $year ) {
      # It must be something like 1y or 5d or 2w.
      my ( $num, $suffix ) = $str =~ m/^([\d\.]+)([hdwmy])$/;
      die "Unrecognized time '$str'; it must be in ISO format or like 1h, 2d etc"
         unless $num;
      my %sec_factors = (
         h => 3_600,
         d => 3_600 * 24,
         w => 3_600 * 24 * 7,
         m => 3_600 * 24 * 30,
         y => 3_600 * 24 * 365,
      );
      $num = int(time() - $num * $sec_factors{$suffix});
      ($sec, $min, $hour, $day, $mon, $year) = localtime($num);
      $mon++;
      $year += 1900;
   }

   # Fill in anything missing and return the string
   $mon  ||= 1;
   $day  ||= 1;
   $hour ||= 0;
   $min  ||= 0;
   $sec  ||= 0;
   return sprintf('%d-%02d-%02d %02d:%02d:%02d',
      $year, $mon, $day, $hour, $min, $sec );
}

sub lengthen {
   my ( $str ) = @_;
   my ( $num, $suffix ) = $str =~ m/^([\d\.]+)([kMGT])?$/;
   die "Unrecognized size format '$str'; must be like 5, 1k, 5G, etc"
      unless defined $num;
   return $num unless $suffix;
   my %len_factors = (
      k => 1_024,
      M => 1_024 ** 2,
      G => 1_024 ** 3,
      T => 1_024 ** 4,
   );
   return $num * $len_factors{$suffix};
}

sub shorten {
   my ( $num ) = @_;
   return $num if $opts{l};
   my $n = 0;
   while ( $num >= 1_024 && $n < 5) {
      $num /= 1_024;
      ++$n;
   }
   return sprintf( "%.1f%s", $num, (' ','k','M','G', 'T')[$n]);
}

# See http://dev.mysql.com/doc/refman/4.1/en/analyze-table.html
sub make_analyze_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:MyISAM|BDB)$/
         || ( $engine eq 'InnoDB' && version_ge('4.0.13'))))
   {
      my $binlog = make_binlog_option();
      my $query = "ANALYZE $binlog TABLE `$database`.`$table`";
      return $query;
   }
}

# See http://dev.mysql.com/doc/refman/5.1/en/check-table.html and previous
# versions of it.
sub make_check_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:MyISAM|InnoDB)$/
         || $engine eq 'NULL'
         || ( $engine eq 'VIEW'    && version_ge('5.0.2'))
         || ( $engine eq 'ARCHIVE' && version_ge('5.0.16'))
         || ( $engine eq 'CSV'     && version_ge('5.1.9'))
      ))
   {
      my $check_options = $opts{checkopts} || '';
      my $query = "CHECK TABLE `$database`.`$table` $check_options";
      return $query;
   }
}

# See http://dev.mysql.com/doc/refman/4.1/en/optimize-table.html
# and http://dev.mysql.com/doc/refman/5.0/en/archive-storage-engine.html
sub make_optimize_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:MyISAM|BDB|InnoDB)$/
         || ( $engine eq 'ARCHIVE' && version_ge('5.0.16'))))
   {
      my $binlog = make_binlog_option();
      my $query = "OPTIMIZE $binlog TABLE `$database`.`$table`";
      return $query;
   }
}

sub make_repair_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:NULL|MyISAM|ARCHIVE)$/
         || ( $engine eq 'CSV' && version_ge('5.1.9'))))
   {
      my $binlog = make_binlog_option();
      my $repair_opts = $opts{repairopts} || '';
      my $query = "REPAIR $binlog TABLE `$database`.`$table` $repair_opts";
      return $query;
   }
}

sub make_binlog_option {
   return !$opts{w} && version_ge('4.1.1') ? 'NO_WRITE_TO_BINLOG' : '';
}

# Compares versions like 5.0.27 and 4.1.15-standard-log
sub version_ge {
   my ( $target ) = @_;
   my @version = $dbh->{mysql_serverinfo} =~ m/(\d+)/g;
   my @target  = $target  =~ m/(\d+)/g;
   return $version[0] >= $target[0]
       && $version[1] >= $target[1]
       && $version[2] >= $target[2];
}

# All output has to be prefixed with SQL comments so the output can be piped
# right into MySQL if desired.
sub debug_print {
   print '-- ', @_, "\n" if $opts{b};
}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-table-maintainer - Conveniently run MySQL table maintenance commands
(ANALYZE, CHECK, OPTIMIZE, REPAIR).

=head1 DESCRIPTION

This program allows you to conveniently run table maintenance commands on your
MySQL tables.  You can run any or all of ANALYZE, CHECK, OPTIMIZE, and REPAIR on
selected tables.  By default it will run on all tables in all databases, but you
need to specify what actions to take.  Some options allow you to run one thing,
check the result, then run another depending on the result.

I've included features to detect what version of MySQL you're connected to and
only take certain actions depending on that.  For example, in version 5.1.9 and
newer, you can run REPAIR against tables using the CSV storage engine.  If I've
missed any special cases in this behavior, be sure to let me know!  I consulted
the MySQL documentation to design these exceptions.

I've also tried to detect when there's a problem and do the right thing with
regards to optimizing and repairing tables.  For example, a view's status is all
NULL, except for the Comment field, which says "VIEW."  But, when the view or a
table it's based on is bad, the Comment field has the error message -- just like
a bad table.  In this case it might be hard to tell whether you're looking at a
bad table, bad view, or a view on a bad table!  I've added some logic to try to
work it out and avoid double-repairing or checking the wrong object.

=head1 USAGE

I'll only discuss options I don't think are obvious.

=over

=item --checkopts

Specific options you want added to the CHECK command, such as FAST.

=item --checkoptimize

This two-for-one option will check the table, then optimize it, but only if
check found no problems.  You can still pass specific arguments to CHECK with
the --checkopts option.

=item --checkrepair

This two-for-one option will check the table, and if it finds problems, try to
repair it.  You can pass specific arguments to CHECK and REPAIR with the
--checkopts and --repairopts options.

=item --longnum

By default the row count and table size are shortened to units of kibibytes,
mebibytes, etc (multiples of 1024).  You can disable that with this option.

=item --minsize

You can specify only to do tables larger than a certain size with this option.
You can specify it in number of bytes, kibibytes, mebibytes etc with k through T
suffixes.  Example: 999, 5.3G, etc.

=item --minage

You can specify only to do tables "older than" a certain point in time.  The
"age" of the table is the maximum of the Create_time, Update_time, and
Check_time columns from SHOW TABLE STATUS.  I think this will do the right
thing.  Let me know if you find exceptions.

The age itself can be specified either as a fractional or full datetime value,
or as an interval of time in the past.  For example, if you say 2006, it expands
to '2006-01-01 00:00:00'.  If you want to specify the full argument, you can
join the date and time parts with a capital T, thusly: 2004-09-21T14:39:32.
This might help you avoid quotes on the command line.

If you don't specify a time, the script tries to interpret it as an interval of
hours, days, weeks, months, or years.  For example, 5h or 3w.  These just get
multiplied out to a number of seconds (assuming every day is 24 hours, every
month is 30 days, every year is 365 days) and subtracted from the current time.
This will definitely not do The Right Thing in all cases, but it's a
low-fidelity, easy way to get the job done without making you install
date-manipulation modules from CPAN.

=item --stoponerror

If the script detects an error with a query, it'll stop.  This is a genuine
error, not just a row of output that says there was an error with the
maintenance command.

=item --views

By default views are skipped.  Specify this option to include them.

=item --nobinlog

By default the table maintenance commands get written to the binlog and
replicated to slaves.  Specify this option to disable that.  This only works on
some versions of MySQL.

=back

=head1 OUTPUT

Output is to STDOUT, with header lines for each database.  I tried to make the
output easy to process with awk.  For this reason columns are always present.
If there's no value, the script prints 'NULL'.

For each action the script takes, it prints the result from MySQL, combined with
information from SHOW TABLE STATUS.  There may be many lines from the result.
If lines have repeated messages, they collapse together with a count greater
than 1.

By default all output is shown.  If you say --quiet once, you'll only see
worrisome output; if you say --quiet twice, you won't see any output at all.

The columns in the output are as follows.

=over

=item DATABASE

The database the table is in.

=item TABLE

The table name.

=item ENGINE

The table's storage engine.

=item SIZE

The total combined index and data size, or 0 if unknown.  You can control the
format with the --longnum option.

=item IBFREE

The amount of InnoDB free space, if it's an InnoDB table (it will appear as 0 if
it's not).  This might differ from table to table if you are using the
innodb_file_per_table option.  You can control the number format with the
--longnum option.  InnoDB reports this in kB, so you can't get it accurate to
the byte.

=item ROWS

The number of rows reported by SHOW TABLE STATUS, or 0 if unknown.  You can
control the format with the --longnum option.

=item OP

The operation as reported by the maintenance command.  It is usually the command
itself.

=item TYPE

The type of message as reported by the maintenance command.

=item CNT

The number of duplicate lines of output collaped together.  Sometimes an
operation like REPAIR will print the same message, for example "Duplicate key for
record at 0 against record at 0," many times.  I try to compact the output for
obvious reasons.

=item TIME

How many seconds the operation took.

=item MSG

The message from the maintenance command.  Anything other than 'OK' or 'Table is
already up to date' is probably worrisome.

=back

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI and DBD::mysql.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
