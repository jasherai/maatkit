#!/usr/bin/perl

# This is mysql-table-maintainer, a program to run table maintenance
# statements against MySQL tables.
# 
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);
use Time::HiRes qw(time);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# TODO: add an option to only do tables of a certain size
#            Name: api
#          Engine: InnoDB
#         Version: 10
#      Row_format: Compact
#            Rows: 5
#  Avg_row_length: 3276
#     Data_length: 16384
# Max_data_length: 0
#    Index_length: 16384
#       Data_free: 0
#  Auto_increment: NULL
#     Create_time: 2007-03-22 11:12:27
#     Update_time: NULL
#      Check_time: NULL
#       Collation: latin1_swedish_ci
#        Checksum: NULL
#  Create_options: 
#         Comment: InnoDB free: 6899712 kB
# 
#            Name: apiusage
#          Engine: MyISAM
#         Version: 10
#      Row_format: Dynamic
#            Rows: 129798
#  Avg_row_length: 54
#     Data_length: 7062432
# Max_data_length: 281474976710655
#    Index_length: 3989504
#       Data_free: 0
#  Auto_increment: NULL
#     Create_time: 2006-11-15 10:32:53
#     Update_time: 2007-03-23 02:25:02
#      Check_time: NULL
#       Collation: latin1_swedish_ci
#        Checksum: NULL
#  Create_options: 
#         Comment: 
# 
# TODO: add an option to only do tables like %pattern%
# TODO: or only do tables that are x old, or not checked in x (units):
# http://perldoc.perl.org/perlfaq4.html#How-can-I-compare-two-dates-and-find-the-difference%3F
# TODO: report data, index, total size change before/after and InnoDB free
my @opt_spec = (
   { s => 'analyze|a',        d => 'Run ANALYZE TABLE' },
   { s => 'check|c',          d => 'Run CHECK TABLE' },
   { s => 'checkopts=s',      d => 'Options to CHECK TABLE' },
   { s => 'checkrepair|k',    d => 'Run REPAIR if CHECK found problems (implies -cr) '},
   { s => 'databases|d=s',    d => 'Only do this comma-separated list of databases' },
   { s => 'debug|b',          d => 'Print SQL statements executed' },
   { s => 'engines|e=s',      d => 'Only do this comma-separated list of engines' },
   { s => 'help',             d => 'Show this help message' },
   { s => 'host|h=s',         d => 'Connect to host' },
   { s => 'ignoredb|g=s',     d => 'Ignore this comma-separated list of databases' },
   { s => 'ignoretbl|n=s',    d => 'Ignore this comma-separated list of tables' },
   { s => 'writetobinlog|w!', d => 'Write the statement to the binlog (default)' },
   { s => 'optimize|o',       d => 'Run OPTIMIZE TABLE' },
   { s => 'password|p=s',     d => 'Password to use when connecting' },
   { s => 'port|P=i',         d => 'Port number to use for connection' },
   { s => 'quiet|q+',         d => 'Be quieter.  Specify twice for no output' },
   { s => 'repair|r',         d => 'Run REPAIR TABLE' },
   { s => 'repairopts=s',     d => 'Options to REPAIR TABLE' },
   { s => 'socket|S=s',       d => 'Socket file to use for connection' },
   { s => 'tables|t=s',       d => 'Only do this comma-separated list of tables' },
   { s => 'user|u=s',         d => 'User for login if not current user' },
   { s => 'views|v',          d => 'Do views also' },
);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   d => '',
   g => '',
   t => '',
   n => '',
   w => 1,
);
# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g}) };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n}) };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}
if ( $opts{k} ) {
   $opts{c} = $opts{r} = 1;
}

# You gotta tell me what to do...
$opts{help} = 1 unless $opts{a} || $opts{c} || $opts{o} || $opts{r};

if ( $opts{help} ) {
   print "Usage: $PROGRAM_NAME <options>\n\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-13s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

$PROGRAM_NAME runs table maintenance commands on MySQL tables.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################
my %conn = ( h => 'host', P => 'port', S => 'socket');

# Connect to the database
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(h P S))
   . ';mysql_read_default_group=mysql';
my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

my $ok_pattern = qr/^(?:OK|Table is already up to date)$/;
my @engines    = qw(myisam innodb memory heap merge archive federated ndb csv
                    blackhole example falcon solid pbxt);
my $engine_re  = join('|', @engines);
my @whole_batch;
my $exit_code = 0;

my %code_for = (
   a => \&make_analyze_query,
   c => \&make_check_query,
   o => \&make_optimize_query,
   r => \&make_repair_query,
);

my @databases = @{$dbh->selectcol_arrayref('SHOW DATABASES')};
DATABASE:
foreach my $database ( @databases ) {

   # Ignore databases as instructed.  Also ignore INFORMATION_SCHEMA and skip
   # databases caused by lost+found directories created in the root of ext3
   # filesystems; they are not really databases.
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^(information_schema|lost\+found)$/mi
      || exists $opts{g}->{$database};

   # TODO like %pattern%
   my $query = "SHOW TABLE STATUS FROM `$database`";
   debug_print($query);
   my @tables = @{$dbh->selectall_arrayref($query, { Slice => {} })};
   next DATABASE unless @tables;

   my $max_db  = max( 8, length($database));
   my $max_tbl = max( 5, map { length( $_->{Name} ) } @tables );
   my $hdr     = "%-${max_db}s %-${max_tbl}s %-7s %-8s %-8s %3s %6s %s\n";
   my $printed = 0;

   TABLE:
   foreach my $spec ( @tables ) {
      my $table = $spec->{Name};
      my $engine = $spec->{Engine} || $spec->{Comment};

      $exit_code = 0;
      my $needs_repair = 0;

      # Detect crashed tables, which should certainly be repaired if needed.  A
      # typical comment in a crashed table:
      # Table './test/smallhist' is marked as crashed and should be repaired
      if ( $spec->{Comment} =~ m/marked as crashed/ ) {
         my ( $db, $tbl ) = $spec->{Comment} =~ m{Table './(\w+)/(\w+)' is marked};
         if ( $db eq $database && $tbl eq $table ) {
            # It's the same table, so it's this table (as opposed to a view
            # complaining about a base table on which it depends).
            $engine       = 'CORRUPT';
            $needs_repair = 1;
         }
         else {
            $engine = 'VIEW';
         }
      }
      elsif ( !$spec->{Engine} || $spec->{Engine} !~ m/^(?:$engine_re)$/ ) {
         $engine = 'CORRUPT';
      }

      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || exists $opts{n}->{$table}
         || ($opts{e} && $engine !~m/CORRUPT|VIEW|UNKNOWN/ && !exists $opts{e}->{lc $engine})
         || ($engine eq 'VIEW' && !$opts{v});

      ACTION:
      foreach my $action ( qw(a c o r) ) { # ANALYZE CHECK OPTIMIZE REPAIR
         if ( defined $opts{$action} ) {
            next ACTION if $action eq 'r' && $opts{k} && !$needs_repair;
            my $query = $code_for{$action}->($database, $table, $engine);
            next ACTION unless $query;
            debug_print($query);
            my $start = time();
            my $res = eval { $dbh->selectall_arrayref($query, { Slice => {} } ) };
            next ACTION unless $res;
            my $time_str = sprintf('%.2f', time() - $start);

            # Sometimes there are a ton of repeated messages, so I try to
            # collapse them into one with a count.
            my %to_print;
            my $order = 0;
            foreach my $row ( @$res ) {
               my $key = join(',', @{$row}{ qw(Msg_type Msg_text) });
               if ( $to_print{$key} ) {
                  $to_print{$key}->{count}++;
               }
               else {
                  $row->{order} = $order++;
                  $row->{count} = 1;
                  $to_print{$key} = $row;
               }
            }

            foreach my $row ( sort { $a->{order} <=> $b->{order} } values %to_print ) {
               if ( !$opts{q} || ($opts{q} <= 1 && $row->{Msg_text} !~ m/$ok_pattern/ )) {
                  printf($hdr, qw(DATABASE TABLE ENGINE OP TYPE CNT TIME MSG))
                     unless $printed++;
                  printf($hdr, $database, $table, $engine, $row->{Op},
                     $row->{Msg_type}, $row->{count}, $time_str, $row->{Msg_text});
               }
            }

            # Check the LAST row to see whether table needs repair.  Last ROW,
            # not last %to_print value.
            if ( $action eq 'c' ) {
               my $msg = $res->[ scalar(@$res) - 1 ]->{Msg_text};
               if ( $engine ne 'VIEW' && $msg !~ m/$ok_pattern/ ) {
                  $needs_repair = 1;
               }
            }

         }
      }
   }

}

exit($exit_code);

# ############################################################################
# Subroutines
# ############################################################################

# See http://dev.mysql.com/doc/refman/4.1/en/analyze-table.html
sub make_analyze_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:MyISAM|BDB)$/
         || ( $engine eq 'InnoDB' && version_ge('4.0.13'))))
   {
      my $binlog = make_binlog_option();
      my $query = "ANALYZE $binlog TABLE `$database`.`$table`";
      return $query;
   }
}

# See http://dev.mysql.com/doc/refman/5.1/en/check-table.html and previous
# versions of it.
sub make_check_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:MyISAM|InnoDB)$/
         || $engine eq 'CORRUPT'
         || ( $engine eq 'VIEW'    && version_ge('5.0.2'))
         || ( $engine eq 'ARCHIVE' && version_ge('5.0.16'))
         || ( $engine eq 'CSV'     && version_ge('5.1.9'))
      ))
   {
      my $check_options = $opts{checkopts} || '';
      my $query = "CHECK TABLE `$database`.`$table` $check_options";
      return $query;
   }
}

# See http://dev.mysql.com/doc/refman/4.1/en/optimize-table.html
# and http://dev.mysql.com/doc/refman/5.0/en/archive-storage-engine.html
sub make_optimize_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:MyISAM|BDB|InnoDB)$/
         || ( $engine eq 'ARCHIVE' && version_ge('5.0.16'))))
   {
      my $binlog = make_binlog_option();
      my $query = "OPTIMIZE $binlog TABLE `$database`.`$table`";
      return $query;
   }
}

sub make_repair_query {
   my ( $database, $table, $engine ) = @_;

   if ( $engine
      && ( $engine =~ m/^(?:CORRUPT|MyISAM|ARCHIVE)$/
         || ( $engine eq 'CSV' && version_ge('5.1.9'))))
   {
      my $binlog = make_binlog_option();
      my $repair_opts = $opts{repairopts} || '';
      my $query = "REPAIR $binlog TABLE `$database`.`$table` $repair_opts";
      return $query;
   }
}

sub make_binlog_option {
   return !$opts{m} && version_ge('4.1.1') ? 'NO_WRITE_TO_BINLOG' : '';
}

# Compares versions like 5.0.27 and 4.1.15-standard-log
sub version_ge {
   my ( $target ) = @_;
   my @version = $dbh->{mysql_serverinfo} =~ m/(\d+)/g;
   my @target  = $target  =~ m/(\d+)/g;
   return $version[0] >= $target[0]
       && $version[1] >= $target[1]
       && $version[2] >= $target[2];
}

# All output has to be prefixed with SQL comments so the output can be piped
# right into MySQL if desired.
sub debug_print {
   print '-- ', @_, "\n" if $opts{b};
}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-duplicate-index-checker - Find possible duplicate indexes and foreign keys on
MySQL tables.

=head1 DESCRIPTION

This program examines the output of SHOW CREATE TABLE on MySQL tables, and if
it finds indexes that a) cover the same columns as another index in the same
order, or b) cover an exact leftmost prefix of another index, it prints out
the suspicious indexes.  By default, indexes must be of the same type, so a
BTREE index is not a duplicate of a FULLTEXT index, even if they have the same
colums.  You can override this.

It also looks for duplicate foreign keys.  A duplicate foreign key covers the
same columns as another in the same table, and references the same parent
table.

If possible, it will read your .my.cnf file so you don't have to specify
username and password.

By default it scans every table in every database, and prints out every
duplicated index and foreign key.  You can specify only to check foreign keys
or indexes.  You can also tell it to check only certain databases and tables,
ignore databases and tables, and so on.

You can specify to print out every index and/or foreign key without checking
for duplicates.  This is an easy way to get a full listing, and it's pretty
fast, since SHOW CREATE TABLE is very quick.

=head1 OUTPUT

Output is to STDOUT, one line per server and table, with header lines for each
database.  I tried to make the output easy to process with awk.  For this reason
columns are always present.  If there's no value, the script prints 'NULL'.

The default is column-aligned output for human readability, but you can change
it to tab-separated.  Output is sorted by database and table.

The columns in the output are as follows.

=over

=item DATABASE

The database the table is in.

=item TABLE

The table name.

=item ENGINE

The table's storage engine.

=item OBJECT

The index or constraint's name, e.g. `tbl_ibfk_3` (the default InnoDB name for
the third foreign key on a table named tbl).

=item TYPE

'KEY' for indexes, 'FK' for foreign keys.

=item STRUCT

The type of index: BTREE, FULLTEXT, HASH etc.  By default MySQL's indexes are
BTREE in most cases.  This does not apply to foreign keys.

=item PARENT

The parent table to which the foreign key constraint refers.  This does not
apply to indexes.

=item COLUMNS

The columns included in the index or foreign key constraint.  For indexes,
this column list is output verbatim, as shown in SHOW CREATE TABLE.  For
foreign keys, the columns are ordered so string comparison can find
duplicates, since column order in a foreign key is immaterial.

=back

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI, DBD::mysql, and Term::ReadKey.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
