#!/usr/bin/env perl

# This program is copyright 2010 Percona Inc.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", (q$Revision$ =~ m/(\d+)/g, 0));

# ###########################################################################
# OptionParser package 5985
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/OptionParser.pm
#   trunk/common/t/OptionParser.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################
package OptionParser;

use strict;
use warnings FATAL => 'all';

use Getopt::Long;
use List::Util qw(max);
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

my $POD_link_re = '[LC]<"?([^">]+)"?>';

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(description) ) {
      die "I need a $arg argument" unless $args{$arg};
   }

   my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
   $program_name ||= $PROGRAM_NAME;
   my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';

   my %attributes = (
      'type'       => 1,
      'short form' => 1,
      'group'      => 1,
      'default'    => 1,
      'cumulative' => 1,
      'negatable'  => 1,
   );

   my $self = {
      strict            => 1,
      prompt            => '<options>',
      head1             => 'OPTIONS',
      skip_rules        => 0,
      item              => '--(.*)',
      attributes        => \%attributes,
      parse_attributes  => \&_parse_attribs,

      %args,

      program_name      => $program_name,
      opts              => {},
      got_opts          => 0,
      short_opts        => {},
      defaults          => {},
      groups            => {},
      allowed_groups    => {},
      errors            => [],
      rules             => [],  # desc of rules for --help
      mutex             => [],  # rule: opts are mutually exclusive
      atleast1          => [],  # rule: at least one opt is required
      disables          => {},  # rule: opt disables other opts 
      defaults_to       => {},  # rule: opt defaults to value of other opt
      DSNParser         => undef,
      default_files     => [
         "/etc/maatkit/maatkit.conf",
         "/etc/maatkit/$program_name.conf",
         "$home/.maatkit.conf",
         "$home/.$program_name.conf",
      ],
      types             => {
         string => 's', # standard Getopt type
         int    => 'i', # standard Getopt type
         float  => 'f', # standard Getopt type
         Hash   => 'H', # hash, formed from a comma-separated list
         hash   => 'h', # hash as above, but only if a value is given
         Array  => 'A', # array, similar to Hash
         array  => 'a', # array, similar to hash
         DSN    => 'd', # DSN
         size   => 'z', # size with kMG suffix (powers of 2^10)
         time   => 'm', # time, with an optional suffix of s/h/m/d
      },
   };

   return bless $self, $class;
}

sub get_specs {
   my ( $self, $file ) = @_;
   $file ||= __FILE__;
   my @specs = $self->_pod_to_specs($file);
   $self->_parse_specs(@specs);

   open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
   my $contents = do { local $/ = undef; <$fh> };
   close $file;
   if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
      MKDEBUG && _d('Parsing DSN OPTIONS');
      my $dsn_attribs = {
         dsn  => 1,
         copy => 1,
      };
      my $parse_dsn_attribs = sub {
         my ( $self, $option, $attribs ) = @_;
         map {
            my $val = $attribs->{$_};
            if ( $val ) {
               $val    = $val eq 'yes' ? 1
                       : $val eq 'no'  ? 0
                       :                 $val;
               $attribs->{$_} = $val;
            }
         } keys %$attribs;
         return {
            key => $option,
            %$attribs,
         };
      };
      my $dsn_o = new OptionParser(
         description       => 'DSN OPTIONS',
         head1             => 'DSN OPTIONS',
         dsn               => 0,         # XXX don't infinitely recurse!
         item              => '\* (.)',  # key opts are a single character
         skip_rules        => 1,         # no rules before opts
         attributes        => $dsn_attribs,
         parse_attributes  => $parse_dsn_attribs,
      );
      my @dsn_opts = map {
         my $opts = {
            key  => $_->{spec}->{key},
            dsn  => $_->{spec}->{dsn},
            copy => $_->{spec}->{copy},
            desc => $_->{desc},
         };
         $opts;
      } $dsn_o->_pod_to_specs($file);
      $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
   }

   return;
}

sub DSNParser {
   my ( $self ) = @_;
   return $self->{DSNParser};
};

sub get_defaults_files {
   my ( $self ) = @_;
   return @{$self->{default_files}};
}

sub _pod_to_specs {
   my ( $self, $file ) = @_;
   $file ||= __FILE__;
   open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";

   my @specs = ();
   my @rules = ();
   my $para;

   local $INPUT_RECORD_SEPARATOR = '';
   while ( $para = <$fh> ) {
      next unless $para =~ m/^=head1 $self->{head1}/;
      last;
   }

   while ( $para = <$fh> ) {
      last if $para =~ m/^=over/;
      next if $self->{skip_rules};
      chomp $para;
      $para =~ s/\s+/ /g;
      $para =~ s/$POD_link_re/$1/go;
      MKDEBUG && _d('Option rule:', $para);
      push @rules, $para;
   }

   die "POD has no $self->{head1} section" unless $para;

   do {
      if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
         chomp $para;
         MKDEBUG && _d($para);
         my %attribs;

         $para = <$fh>; # read next paragraph, possibly attributes

         if ( $para =~ m/: / ) { # attributes
            $para =~ s/\s+\Z//g;
            %attribs = map {
                  my ( $attrib, $val) = split(/: /, $_);
                  die "Unrecognized attribute for --$option: $attrib"
                     unless $self->{attributes}->{$attrib};
                  ($attrib, $val);
               } split(/; /, $para);
            if ( $attribs{'short form'} ) {
               $attribs{'short form'} =~ s/-//;
            }
            $para = <$fh>; # read next paragraph, probably short help desc
         }
         else {
            MKDEBUG && _d('Option has no attributes');
         }

         $para =~ s/\s+\Z//g;
         $para =~ s/\s+/ /g;
         $para =~ s/$POD_link_re/$1/go;

         $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
         MKDEBUG && _d('Short help:', $para);

         die "No description after option spec $option" if $para =~ m/^=item/;

         if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
            $option = $base_option;
            $attribs{'negatable'} = 1;
         }

         push @specs, {
            spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
            desc  => $para
               . ($attribs{default} ? " (default $attribs{default})" : ''),
            group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
         };
      }
      while ( $para = <$fh> ) {
         last unless $para;
         if ( $para =~ m/^=head1/ ) {
            $para = undef; # Can't 'last' out of a do {} block.
            last;
         }
         last if $para =~ m/^=item /;
      }
   } while ( $para );

   die "No valid specs in $self->{head1}" unless @specs;

   close $fh;
   return @specs, @rules;
}

sub _parse_specs {
   my ( $self, @specs ) = @_;
   my %disables; # special rule that requires deferred checking

   foreach my $opt ( @specs ) {
      if ( ref $opt ) { # It's an option spec, not a rule.
         MKDEBUG && _d('Parsing opt spec:',
            map { ($_, '=>', $opt->{$_}) } keys %$opt);

         my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
         if ( !$long ) {
            die "Cannot parse long option from spec $opt->{spec}";
         }
         $opt->{long} = $long;

         die "Duplicate long option --$long" if exists $self->{opts}->{$long};
         $self->{opts}->{$long} = $opt;

         if ( length $long == 1 ) {
            MKDEBUG && _d('Long opt', $long, 'looks like short opt');
            $self->{short_opts}->{$long} = $long;
         }

         if ( $short ) {
            die "Duplicate short option -$short"
               if exists $self->{short_opts}->{$short};
            $self->{short_opts}->{$short} = $long;
            $opt->{short} = $short;
         }
         else {
            $opt->{short} = undef;
         }

         $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
         $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
         $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;

         $opt->{group} ||= 'default';
         $self->{groups}->{ $opt->{group} }->{$long} = 1;

         $opt->{value} = undef;
         $opt->{got}   = 0;

         my ( $type ) = $opt->{spec} =~ m/=(.)/;
         $opt->{type} = $type;
         MKDEBUG && _d($long, 'type:', $type);


         $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );

         if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
            $self->{defaults}->{$long} = defined $def ? $def : 1;
            MKDEBUG && _d($long, 'default:', $def);
         }

         if ( $long eq 'config' ) {
            $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
         }

         if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
            $disables{$long} = $dis;
            MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
         }

         $self->{opts}->{$long} = $opt;
      }
      else { # It's an option rule, not a spec.
         MKDEBUG && _d('Parsing rule:', $opt); 
         push @{$self->{rules}}, $opt;
         my @participants = $self->_get_participants($opt);
         my $rule_ok = 0;

         if ( $opt =~ m/mutually exclusive|one and only one/ ) {
            $rule_ok = 1;
            push @{$self->{mutex}}, \@participants;
            MKDEBUG && _d(@participants, 'are mutually exclusive');
         }
         if ( $opt =~ m/at least one|one and only one/ ) {
            $rule_ok = 1;
            push @{$self->{atleast1}}, \@participants;
            MKDEBUG && _d(@participants, 'require at least one');
         }
         if ( $opt =~ m/default to/ ) {
            $rule_ok = 1;
            $self->{defaults_to}->{$participants[0]} = $participants[1];
            MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
         }
         if ( $opt =~ m/restricted to option groups/ ) {
            $rule_ok = 1;
            my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
            my @groups = split(',', $groups);
            %{$self->{allowed_groups}->{$participants[0]}} = map {
               s/\s+//;
               $_ => 1;
            } @groups;
         }

         die "Unrecognized option rule: $opt" unless $rule_ok;
      }
   }

   foreach my $long ( keys %disables ) {
      my @participants = $self->_get_participants($disables{$long});
      $self->{disables}->{$long} = \@participants;
      MKDEBUG && _d('Option', $long, 'disables', @participants);
   }

   return; 
}

sub _get_participants {
   my ( $self, $str ) = @_;
   my @participants;
   foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
      die "Option --$long does not exist while processing rule $str"
         unless exists $self->{opts}->{$long};
      push @participants, $long;
   }
   MKDEBUG && _d('Participants for', $str, ':', @participants);
   return @participants;
}

sub opts {
   my ( $self ) = @_;
   my %opts = %{$self->{opts}};
   return %opts;
}

sub short_opts {
   my ( $self ) = @_;
   my %short_opts = %{$self->{short_opts}};
   return %short_opts;
}

sub set_defaults {
   my ( $self, %defaults ) = @_;
   $self->{defaults} = {};
   foreach my $long ( keys %defaults ) {
      die "Cannot set default for nonexistent option $long"
         unless exists $self->{opts}->{$long};
      $self->{defaults}->{$long} = $defaults{$long};
      MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
   }
   return;
}

sub get_defaults {
   my ( $self ) = @_;
   return $self->{defaults};
}

sub get_groups {
   my ( $self ) = @_;
   return $self->{groups};
}

sub _set_option {
   my ( $self, $opt, $val ) = @_;
   my $long = exists $self->{opts}->{$opt}       ? $opt
            : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
            : die "Getopt::Long gave a nonexistent option: $opt";

   $opt = $self->{opts}->{$long};
   if ( $opt->{is_cumulative} ) {
      $opt->{value}++;
   }
   else {
      $opt->{value} = $val;
   }
   $opt->{got} = 1;
   MKDEBUG && _d('Got option', $long, '=', $val);
}

sub get_opts {
   my ( $self ) = @_; 

   foreach my $long ( keys %{$self->{opts}} ) {
      $self->{opts}->{$long}->{got} = 0;
      $self->{opts}->{$long}->{value}
         = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
         : $self->{opts}->{$long}->{is_cumulative} ? 0
         : undef;
   }
   $self->{got_opts} = 0;

   $self->{errors} = [];

   if ( @ARGV && $ARGV[0] eq "--config" ) {
      shift @ARGV;
      $self->_set_option('config', shift @ARGV);
   }
   if ( $self->has('config') ) {
      my @extra_args;
      foreach my $filename ( split(',', $self->get('config')) ) {
         eval {
            push @extra_args, $self->_read_config_file($filename);
         };
         if ( $EVAL_ERROR ) {
            if ( $self->got('config') ) {
               die $EVAL_ERROR;
            }
            elsif ( MKDEBUG ) {
               _d($EVAL_ERROR);
            }
         }
      }
      unshift @ARGV, @extra_args;
   }

   Getopt::Long::Configure('no_ignore_case', 'bundling');
   GetOptions(
      map    { $_->{spec} => sub { $self->_set_option(@_); } }
      grep   { $_->{long} ne 'config' } # --config is handled specially above.
      values %{$self->{opts}}
   ) or $self->save_error('Error parsing options');

   if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
      printf("%s  Ver %s Distrib %s Changeset %s\n",
         $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
            or die "Cannot print: $OS_ERROR";
      exit 0;
   }

   if ( @ARGV && $self->{strict} ) {
      $self->save_error("Unrecognized command-line options @ARGV");
   }

   foreach my $mutex ( @{$self->{mutex}} ) {
      my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      if ( @set > 1 ) {
         my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
                      @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
                 . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
                 . ' are mutually exclusive.';
         $self->save_error($err);
      }
   }

   foreach my $required ( @{$self->{atleast1}} ) {
      my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      if ( @set == 0 ) {
         my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
                      @{$required}[ 0 .. scalar(@$required) - 2] )
                 .' or --'.$self->{opts}->{$required->[-1]}->{long};
         $self->save_error("Specify at least one of $err");
      }
   }

   $self->_check_opts( keys %{$self->{opts}} );
   $self->{got_opts} = 1;
   return;
}

sub _check_opts {
   my ( $self, @long ) = @_;
   my $long_last = scalar @long;
   while ( @long ) {
      foreach my $i ( 0..$#long ) {
         my $long = $long[$i];
         next unless $long;
         my $opt  = $self->{opts}->{$long};
         if ( $opt->{got} ) {
            if ( exists $self->{disables}->{$long} ) {
               my @disable_opts = @{$self->{disables}->{$long}};
               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
               MKDEBUG && _d('Unset options', @disable_opts,
                  'because', $long,'disables them');
            }

            if ( exists $self->{allowed_groups}->{$long} ) {

               my @restricted_groups = grep {
                  !exists $self->{allowed_groups}->{$long}->{$_}
               } keys %{$self->{groups}};

               my @restricted_opts;
               foreach my $restricted_group ( @restricted_groups ) {
                  RESTRICTED_OPT:
                  foreach my $restricted_opt (
                     keys %{$self->{groups}->{$restricted_group}} )
                  {
                     next RESTRICTED_OPT if $restricted_opt eq $long;
                     push @restricted_opts, $restricted_opt
                        if $self->{opts}->{$restricted_opt}->{got};
                  }
               }

               if ( @restricted_opts ) {
                  my $err;
                  if ( @restricted_opts == 1 ) {
                     $err = "--$restricted_opts[0]";
                  }
                  else {
                     $err = join(', ',
                               map { "--$self->{opts}->{$_}->{long}" }
                               grep { $_ } 
                               @restricted_opts[0..scalar(@restricted_opts) - 2]
                            )
                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
                  }
                  $self->save_error("--$long is not allowed with $err");
               }
            }

         }
         elsif ( $opt->{is_required} ) { 
            $self->save_error("Required option --$long must be specified");
         }

         $self->_validate_type($opt);
         if ( $opt->{parsed} ) {
            delete $long[$i];
         }
         else {
            MKDEBUG && _d('Temporarily failed to parse', $long);
         }
      }

      die "Failed to parse options, possibly due to circular dependencies"
         if @long == $long_last;
      $long_last = @long;
   }

   return;
}

sub _validate_type {
   my ( $self, $opt ) = @_;
   return unless $opt;

   if ( !$opt->{type} ) {
      $opt->{parsed} = 1;
      return;
   }

   my $val = $opt->{value};

   if ( $val && $opt->{type} eq 'm' ) {  # type time
      MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
      if ( !$suffix ) {
         my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
         $suffix = $s || 's';
         MKDEBUG && _d('No suffix given; using', $suffix, 'for',
            $opt->{long}, '(value:', $val, ')');
      }
      if ( $suffix =~ m/[smhd]/ ) {
         $val = $suffix eq 's' ? $num            # Seconds
              : $suffix eq 'm' ? $num * 60       # Minutes
              : $suffix eq 'h' ? $num * 3600     # Hours
              :                  $num * 86400;   # Days
         $opt->{value} = ($prefix || '') . $val;
         MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
      }
      else {
         $self->save_error("Invalid time suffix for --$opt->{long}");
      }
   }
   elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
      MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
      my $prev = {};
      my $from_key = $self->{defaults_to}->{ $opt->{long} };
      if ( $from_key ) {
         MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
         if ( $self->{opts}->{$from_key}->{parsed} ) {
            $prev = $self->{opts}->{$from_key}->{value};
         }
         else {
            MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
               $from_key, 'parsed');
            return;
         }
      }
      my $defaults = $self->{DSNParser}->parse_options($self);
      $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
   }
   elsif ( $val && $opt->{type} eq 'z' ) {  # type size
      MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
      $self->_parse_size($opt, $val);
   }
   elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
      $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
   }
   elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
      $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
   }
   else {
      MKDEBUG && _d('Nothing to validate for option',
         $opt->{long}, 'type', $opt->{type}, 'value', $val);
   }

   $opt->{parsed} = 1;
   return;
}

sub get {
   my ( $self, $opt ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   die "Option $opt does not exist"
      unless $long && exists $self->{opts}->{$long};
   return $self->{opts}->{$long}->{value};
}

sub got {
   my ( $self, $opt ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   die "Option $opt does not exist"
      unless $long && exists $self->{opts}->{$long};
   return $self->{opts}->{$long}->{got};
}

sub has {
   my ( $self, $opt ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   return defined $long ? exists $self->{opts}->{$long} : 0;
}

sub set {
   my ( $self, $opt, $val ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   die "Option $opt does not exist"
      unless $long && exists $self->{opts}->{$long};
   $self->{opts}->{$long}->{value} = $val;
   return;
}

sub save_error {
   my ( $self, $error ) = @_;
   push @{$self->{errors}}, $error;
}

sub errors {
   my ( $self ) = @_;
   return $self->{errors};
}

sub prompt {
   my ( $self ) = @_;
   return "Usage: $PROGRAM_NAME $self->{prompt}\n";
}

sub descr {
   my ( $self ) = @_;
   my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
              . "  For more details, please use the --help option, "
              . "or try 'perldoc $PROGRAM_NAME' "
              . "for complete documentation.";
   $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
      unless $ENV{DONT_BREAK_LINES};
   $descr =~ s/ +$//mg;
   return $descr;
}

sub usage_or_errors {
   my ( $self ) = @_;
   if ( $self->{opts}->{help}->{got} ) {
      print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
      exit 0;
   }
   elsif ( scalar @{$self->{errors}} ) {
      print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
      exit 0;
   }
   return;
}

sub print_errors {
   my ( $self ) = @_;
   my $usage = $self->prompt() . "\n";
   if ( (my @errors = @{$self->{errors}}) ) {
      $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
              . "\n";
   }
   return $usage . "\n" . $self->descr();
}

sub print_usage {
   my ( $self ) = @_;
   die "Run get_opts() before print_usage()" unless $self->{got_opts};
   my @opts = values %{$self->{opts}};

   my $maxl = max(
      map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
      @opts);

   my $maxs = max(0,
      map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
      values %{$self->{short_opts}});

   my $lcol = max($maxl, ($maxs + 3));
   my $rcol = 80 - $lcol - 6;
   my $rpad = ' ' x ( 80 - $rcol );

   $maxs = max($lcol - 3, $maxs);

   my $usage = $self->descr() . "\n" . $self->prompt();

   my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
   push @groups, 'default';

   foreach my $group ( reverse @groups ) {
      $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
      foreach my $opt (
         sort { $a->{long} cmp $b->{long} }
         grep { $_->{group} eq $group }
         @opts )
      {
         my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
         my $short = $opt->{short};
         my $desc  = $opt->{desc};
         if ( $opt->{type} && $opt->{type} eq 'm' ) {
            my ($s) = $desc =~ m/\(suffix (.)\)/;
            $s    ||= 's';
            $desc =~ s/\s+\(suffix .\)//;
            $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
                   . "d=days; if no suffix, $s is used.";
         }
         $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
         $desc =~ s/ +$//mg;
         if ( $short ) {
            $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
         }
         else {
            $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
         }
      }
   }

   if ( (my @rules = @{$self->{rules}}) ) {
      $usage .= "\nRules:\n\n";
      $usage .= join("\n", map { "  $_" } @rules) . "\n";
   }
   if ( $self->{DSNParser} ) {
      $usage .= "\n" . $self->{DSNParser}->usage();
   }
   $usage .= "\nOptions and values after processing arguments:\n\n";
   foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      my $val   = $opt->{value};
      my $type  = $opt->{type} || '';
      my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
      $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
                : !defined $val      ? '(No value)'
                : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
                : $type =~ m/H|h/    ? join(',', sort keys %$val)
                : $type =~ m/A|a/    ? join(',', @$val)
                :                    $val;
      $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
   }
   return $usage;
}

sub prompt_noecho {
   shift @_ if ref $_[0] eq __PACKAGE__;
   my ( $prompt ) = @_;
   local $OUTPUT_AUTOFLUSH = 1;
   print $prompt
      or die "Cannot print: $OS_ERROR";
   my $response;
   eval {
      require Term::ReadKey;
      Term::ReadKey::ReadMode('noecho');
      chomp($response = <STDIN>);
      Term::ReadKey::ReadMode('normal');
      print "\n"
         or die "Cannot print: $OS_ERROR";
   };
   if ( $EVAL_ERROR ) {
      die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
   }
   return $response;
}

if ( MKDEBUG ) {
   print '# ', $^X, ' ', $], "\n";
   my $uname = `uname -a`;
   if ( $uname ) {
      $uname =~ s/\s+/ /g;
      print "# $uname\n";
   }
   printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
      $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
      ($main::SVN_REV || ''), __LINE__);
   print('# Arguments: ',
      join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
}

sub _read_config_file {
   my ( $self, $filename ) = @_;
   open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
   my @args;
   my $prefix = '--';
   my $parse  = 1;

   LINE:
   while ( my $line = <$fh> ) {
      chomp $line;
      next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
      $line =~ s/\s+#.*$//g;
      $line =~ s/^\s+|\s+$//g;
      if ( $line eq '--' ) {
         $prefix = '';
         $parse  = 0;
         next LINE;
      }
      if ( $parse
         && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
      ) {
         push @args, grep { defined $_ } ("$prefix$opt", $arg);
      }
      elsif ( $line =~ m/./ ) {
         push @args, $line;
      }
      else {
         die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
      }
   }
   close $fh;
   return @args;
}

sub read_para_after {
   my ( $self, $file, $regex ) = @_;
   open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
   local $INPUT_RECORD_SEPARATOR = '';
   my $para;
   while ( $para = <$fh> ) {
      next unless $para =~ m/^=pod$/m;
      last;
   }
   while ( $para = <$fh> ) {
      next unless $para =~ m/$regex/;
      last;
   }
   $para = <$fh>;
   chomp($para);
   close $fh or die "Can't close $file: $OS_ERROR";
   return $para;
}

sub clone {
   my ( $self ) = @_;

   my %clone = map {
      my $hashref  = $self->{$_};
      my $val_copy = {};
      foreach my $key ( keys %$hashref ) {
         my $ref = ref $hashref->{$key};
         $val_copy->{$key} = !$ref           ? $hashref->{$key}
                           : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
                           : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
                           : $hashref->{$key};
      }
      $_ => $val_copy;
   } qw(opts short_opts defaults);

   foreach my $scalar ( qw(got_opts) ) {
      $clone{$scalar} = $self->{$scalar};
   }

   return bless \%clone;     
}

sub _parse_size {
   my ( $self, $opt, $val ) = @_;

   if ( lc($val || '') eq 'null' ) {
      MKDEBUG && _d('NULL size for', $opt->{long});
      $opt->{value} = 'null';
      return;
   }

   my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
   my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
   if ( defined $num ) {
      if ( $factor ) {
         $num *= $factor_for{$factor};
         MKDEBUG && _d('Setting option', $opt->{y},
            'to num', $num, '* factor', $factor);
      }
      $opt->{value} = ($pre || '') . $num;
   }
   else {
      $self->save_error("Invalid size for --$opt->{long}");
   }
   return;
}

sub _parse_attribs {
   my ( $self, $option, $attribs ) = @_;
   my $types = $self->{types};
   return $option
      . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
      . ($attribs->{'negatable'}  ? '!'                              : '' )
      . ($attribs->{'cumulative'} ? '+'                              : '' )
      . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End OptionParser package
# ###########################################################################

# ###########################################################################
# DSNParser package 6057
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/DSNParser.pm
#   trunk/common/t/DSNParser.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################
package DSNParser;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Data::Dumper;
$Data::Dumper::Indent    = 0;
$Data::Dumper::Quotekeys = 0;

eval {
   require DBI;
};
my $have_dbi = $EVAL_ERROR ? 0 : 1;

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(opts) ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my $self = {
      opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
   };
   foreach my $opt ( @{$args{opts}} ) {
      if ( !$opt->{key} || !$opt->{desc} ) {
         die "Invalid DSN option: ", Dumper($opt);
      }
      MKDEBUG && _d('DSN option:',
         join(', ',
            map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
               keys %$opt
         )
      );
      $self->{opts}->{$opt->{key}} = {
         dsn  => $opt->{dsn},
         desc => $opt->{desc},
         copy => $opt->{copy} || 0,
      };
   }
   return bless $self, $class;
}

sub prop {
   my ( $self, $prop, $value ) = @_;
   if ( @_ > 2 ) {
      MKDEBUG && _d('Setting', $prop, 'property');
      $self->{$prop} = $value;
   }
   return $self->{$prop};
}

sub parse {
   my ( $self, $dsn, $prev, $defaults ) = @_;
   if ( !$dsn ) {
      MKDEBUG && _d('No DSN to parse');
      return;
   }
   MKDEBUG && _d('Parsing', $dsn);
   $prev     ||= {};
   $defaults ||= {};
   my %given_props;
   my %final_props;
   my $opts = $self->{opts};

   foreach my $dsn_part ( split(/,/, $dsn) ) {
      if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
         $given_props{$prop_key} = $prop_val;
      }
      else {
         MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
         $given_props{h} = $dsn_part;
      }
   }

   foreach my $key ( keys %$opts ) {
      MKDEBUG && _d('Finding value for', $key);
      $final_props{$key} = $given_props{$key};
      if (   !defined $final_props{$key}
           && defined $prev->{$key} && $opts->{$key}->{copy} )
      {
         $final_props{$key} = $prev->{$key};
         MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
      }
      if ( !defined $final_props{$key} ) {
         $final_props{$key} = $defaults->{$key};
         MKDEBUG && _d('Copying value for', $key, 'from defaults');
      }
   }

   foreach my $key ( keys %given_props ) {
      die "Unknown DSN option '$key' in '$dsn'.  For more details, "
            . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
            . "for complete documentation."
         unless exists $opts->{$key};
   }
   if ( (my $required = $self->prop('required')) ) {
      foreach my $key ( keys %$required ) {
         die "Missing required DSN option '$key' in '$dsn'.  For more details, "
               . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
               . "for complete documentation."
            unless $final_props{$key};
      }
   }

   return \%final_props;
}

sub parse_options {
   my ( $self, $o ) = @_;
   die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
   my $dsn_string
      = join(',',
          map  { "$_=".$o->get($_); }
          grep { $o->has($_) && $o->get($_) }
          keys %{$self->{opts}}
        );
   MKDEBUG && _d('DSN string made from options:', $dsn_string);
   return $self->parse($dsn_string);
}

sub as_string {
   my ( $self, $dsn, $props ) = @_;
   return $dsn unless ref $dsn;
   my %allowed = $props ? map { $_=>1 } @$props : ();
   return join(',',
      map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
      grep { defined $dsn->{$_} && $self->{opts}->{$_} }
      grep { !$props || $allowed{$_}                   }
      sort keys %$dsn );
}

sub usage {
   my ( $self ) = @_;
   my $usage
      = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
      . "  KEY  COPY  MEANING\n"
      . "  ===  ====  =============================================\n";
   my %opts = %{$self->{opts}};
   foreach my $key ( sort keys %opts ) {
      $usage .= "  $key    "
             .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
             .  ($opts{$key}->{desc} || '[No description]')
             . "\n";
   }
   $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
   return $usage;
}

sub get_cxn_params {
   my ( $self, $info ) = @_;
   my $dsn;
   my %opts = %{$self->{opts}};
   my $driver = $self->prop('dbidriver') || '';
   if ( $driver eq 'Pg' ) {
      $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(h P));
   }
   else {
      $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(F h P S A))
         . ';mysql_read_default_group=client';
   }
   MKDEBUG && _d($dsn);
   return ($dsn, $info->{u}, $info->{p});
}

sub fill_in_dsn {
   my ( $self, $dbh, $dsn ) = @_;
   my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
   my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
   $user =~ s/@.*//;
   $dsn->{h} ||= $vars->{hostname}->{Value};
   $dsn->{S} ||= $vars->{'socket'}->{Value};
   $dsn->{P} ||= $vars->{port}->{Value};
   $dsn->{u} ||= $user;
   $dsn->{D} ||= $db;
}

sub get_dbh {
   my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
   $opts ||= {};
   my $defaults = {
      AutoCommit         => 0,
      RaiseError         => 1,
      PrintError         => 0,
      ShowErrorStatement => 1,
      mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
   };
   @{$defaults}{ keys %$opts } = values %$opts;

   if ( $opts->{mysql_use_result} ) {
      $defaults->{mysql_use_result} = 1;
   }

   if ( !$have_dbi ) {
      die "Cannot connect to MySQL because the Perl DBI module is not "
         . "installed or not found.  Run 'perl -MDBI' to see the directories "
         . "that Perl searches for DBI.  If DBI is not installed, try:\n"
         . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
         . "  RHEL/CentOS    yum install perl-DBI\n"
         . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";

   }

   my $dbh;
   my $tries = 2;
   while ( !$dbh && $tries-- ) {
      MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
         join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');

      eval {
         $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);

         if ( $cxn_string =~ m/mysql/i ) {
            my $sql;

            $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
                 . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
            MKDEBUG && _d($dbh, ':', $sql);
            $dbh->do($sql);

            if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
               $sql = "/*!40101 SET NAMES $charset*/";
               MKDEBUG && _d($dbh, ':', $sql);
               $dbh->do($sql);
               MKDEBUG && _d('Enabling charset for STDOUT');
               if ( $charset eq 'utf8' ) {
                  binmode(STDOUT, ':utf8')
                     or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
               }
               else {
                  binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
               }
            }

            if ( $self->prop('set-vars') ) {
               $sql = "SET " . $self->prop('set-vars');
               MKDEBUG && _d($dbh, ':', $sql);
               $dbh->do($sql);
            }
         }
      };
      if ( !$dbh && $EVAL_ERROR ) {
         MKDEBUG && _d($EVAL_ERROR);
         if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
            MKDEBUG && _d('Going to try again without utf8 support');
            delete $defaults->{mysql_enable_utf8};
         }
         elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
            die "Cannot connect to MySQL because the Perl DBD::mysql module is "
               . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
               . "the directories that Perl searches for DBD::mysql.  If "
               . "DBD::mysql is not installed, try:\n"
               . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
               . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
               . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
         }
         if ( !$tries ) {
            die $EVAL_ERROR;
         }
      }
   }

   MKDEBUG && _d('DBH info: ',
      $dbh,
      Dumper($dbh->selectrow_hashref(
         'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
      'Connection info:',      $dbh->{mysql_hostinfo},
      'Character set info:',   Dumper($dbh->selectall_arrayref(
                     'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
      '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
      '$DBI::VERSION:',        $DBI::VERSION,
   );

   return $dbh;
}

sub get_hostname {
   my ( $self, $dbh ) = @_;
   if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
      return $host;
   }
   my ( $hostname, $one ) = $dbh->selectrow_array(
      'SELECT /*!50038 @@hostname, */ 1');
   return $hostname;
}

sub disconnect {
   my ( $self, $dbh ) = @_;
   MKDEBUG && $self->print_active_handles($dbh);
   $dbh->disconnect;
}

sub print_active_handles {
   my ( $self, $thing, $level ) = @_;
   $level ||= 0;
   printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
      or die "Cannot print: $OS_ERROR";
   foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      $self->print_active_handles( $handle, $level + 1 );
   }
}

sub copy {
   my ( $self, $dsn_1, $dsn_2, %args ) = @_;
   die 'I need a dsn_1 argument' unless $dsn_1;
   die 'I need a dsn_2 argument' unless $dsn_2;
   my %new_dsn = map {
      my $key = $_;
      my $val;
      if ( $args{overwrite} ) {
         $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
      }
      else {
         $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
      }
      $key => $val;
   } keys %{$self->{opts}};
   return \%new_dsn;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End DSNParser package
# ###########################################################################

# ###########################################################################
# Quoter package 6240
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/Quoter.pm
#   trunk/common/t/Quoter.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################
package Quoter;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

sub new {
   my ( $class ) = @_;
   return bless {}, $class;
}

sub quote {
   my ( $self, @vals ) = @_;
   foreach my $val ( @vals ) {
      $val =~ s/`/``/g;
   }
   return join('.', map { '`' . $_ . '`' } @vals);
}

sub quote_val {
   my ( $self, $val ) = @_;

   return 'NULL' unless defined $val;         # undef = NULL
   return "''" if $val eq '';                 # blank string = ''
   return $val if $val =~ m/^0x[0-9a-fA-F]/;  # hex value like 0xe5f190

   $val =~ s/(['\\])/\\$1/g;
   return "'$val'";
}

sub split_unquote {
   my ( $self, $db_tbl, $default_db ) = @_;
   $db_tbl =~ s/`//g;
   my ( $db, $tbl ) = split(/[.]/, $db_tbl);
   if ( !$tbl ) {
      $tbl = $db;
      $db  = $default_db;
   }
   return ($db, $tbl);
}

sub literal_like {
   my ( $self, $like ) = @_;
   return unless $like;
   $like =~ s/([%_])/\\$1/g;
   return "'$like'";
}

sub join_quote {
   my ( $self, $default_db, $db_tbl ) = @_;
   return unless $db_tbl;
   my ($db, $tbl) = split(/[.]/, $db_tbl);
   if ( !$tbl ) {
      $tbl = $db;
      $db  = $default_db;
   }
   $db  = "`$db`"  if $db  && $db  !~ m/^`/;
   $tbl = "`$tbl`" if $tbl && $tbl !~ m/^`/;
   return $db ? "$db.$tbl" : $tbl;
}

1;

# ###########################################################################
# End Quoter package
# ###########################################################################

# ###########################################################################
# Daemon package 6255
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/Daemon.pm
#   trunk/common/t/Daemon.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################

package Daemon;

use strict;
use warnings FATAL => 'all';

use POSIX qw(setsid);
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(o) ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my $o = $args{o};
   my $self = {
      o        => $o,
      log_file => $o->has('log') ? $o->get('log') : undef,
      PID_file => $o->has('pid') ? $o->get('pid') : undef,
   };

   check_PID_file(undef, $self->{PID_file});

   MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
   return bless $self, $class;
}

sub daemonize {
   my ( $self ) = @_;

   MKDEBUG && _d('About to fork and daemonize');
   defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
   if ( $pid ) {
      MKDEBUG && _d('I am the parent and now I die');
      exit;
   }

   $self->{PID_owner} = $PID;
   $self->{child}     = 1;

   POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
   chdir '/'       or die "Cannot chdir to /: $OS_ERROR";

   $self->_make_PID_file();

   $OUTPUT_AUTOFLUSH = 1;

   if ( -t STDIN ) {
      close STDIN;
      open  STDIN, '/dev/null'
         or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
   }

   if ( $self->{log_file} ) {
      close STDOUT;
      open  STDOUT, '>>', $self->{log_file}
         or die "Cannot open log file $self->{log_file}: $OS_ERROR";

      close STDERR;
      open  STDERR, ">&STDOUT"
         or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
   }
   else {
      if ( -t STDOUT ) {
         close STDOUT;
         open  STDOUT, '>', '/dev/null'
            or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
      }
      if ( -t STDERR ) {
         close STDERR;
         open  STDERR, '>', '/dev/null'
            or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
      }
   }

   MKDEBUG && _d('I am the child and now I live daemonized');
   return;
}

sub check_PID_file {
   my ( $self, $file ) = @_;
   my $PID_file = $self ? $self->{PID_file} : $file;
   MKDEBUG && _d('Checking PID file', $PID_file);
   if ( $PID_file && -f $PID_file ) {
      my $pid;
      eval { chomp($pid = `cat $PID_file`); };
      die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
      MKDEBUG && _d('PID file exists; it contains PID', $pid);
      if ( $pid ) {
         my $pid_is_alive = kill 0, $pid;
         if ( $pid_is_alive ) {
            die "The PID file $PID_file already exists "
               . " and the PID that it contains, $pid, is running";
         }
         else {
            warn "Overwriting PID file $PID_file because the PID that it "
               . "contains, $pid, is not running";
         }
      }
      else {
         die "The PID file $PID_file already exists but it does not "
            . "contain a PID";
      }
   }
   else {
      MKDEBUG && _d('No PID file');
   }
   return;
}

sub make_PID_file {
   my ( $self ) = @_;
   if ( exists $self->{child} ) {
      die "Do not call Daemon::make_PID_file() for daemonized scripts";
   }
   $self->_make_PID_file();
   $self->{PID_owner} = $PID;
   return;
}

sub _make_PID_file {
   my ( $self ) = @_;

   my $PID_file = $self->{PID_file};
   if ( !$PID_file ) {
      MKDEBUG && _d('No PID file to create');
      return;
   }

   $self->check_PID_file();

   open my $PID_FH, '>', $PID_file
      or die "Cannot open PID file $PID_file: $OS_ERROR";
   print $PID_FH $PID
      or die "Cannot print to PID file $PID_file: $OS_ERROR";
   close $PID_FH
      or die "Cannot close PID file $PID_file: $OS_ERROR";

   MKDEBUG && _d('Created PID file:', $self->{PID_file});
   return;
}

sub _remove_PID_file {
   my ( $self ) = @_;
   if ( $self->{PID_file} && -f $self->{PID_file} ) {
      unlink $self->{PID_file}
         or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
      MKDEBUG && _d('Removed PID file');
   }
   else {
      MKDEBUG && _d('No PID to remove');
   }
   return;
}

sub DESTROY {
   my ( $self ) = @_;

   $self->_remove_PID_file() if ($self->{PID_owner} || 0) == $PID;

   return;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End Daemon package
# ###########################################################################

# ###########################################################################
# Transformers package 5715
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/Transformers.pm
#   trunk/common/t/Transformers.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################

package Transformers;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Time::Local qw(timegm timelocal);
use Digest::MD5 qw(md5_hex);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

require Exporter;
our @ISA         = qw(Exporter);
our %EXPORT_TAGS = ();
our @EXPORT      = ();
our @EXPORT_OK   = qw(
   micro_t
   percentage_of
   secs_to_time
   time_to_secs
   shorten
   ts
   parse_timestamp
   unix_timestamp
   any_unix_timestamp
   make_checksum
);

our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks

sub micro_t {
   my ( $t, %args ) = @_;
   my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
   my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
   my $f;

   $t = 0 if $t < 0;

   $t = sprintf('%.17f', $t) if $t =~ /e/;

   $t =~ s/\.(\d{1,6})\d*/\.$1/;

   if ($t > 0 && $t <= 0.000999) {
      $f = ($t * 1000000) . 'us';
   }
   elsif ($t >= 0.001000 && $t <= 0.999999) {
      $f = sprintf("%.${p_ms}f", $t * 1000);
      $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
   }
   elsif ($t >= 1) {
      $f = sprintf("%.${p_s}f", $t);
      $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
   }
   else {
      $f = 0;  # $t should = 0 at this point
   }

   return $f;
}

sub percentage_of {
   my ( $is, $of, %args ) = @_;
   my $p   = $args{p} || 0; # float precision
   my $fmt = $p ? "%.${p}f" : "%d";
   return sprintf $fmt, ($is * 100) / ($of ||= 1);
}

sub secs_to_time {
   my ( $secs, $fmt ) = @_;
   $secs ||= 0;
   return '00:00' unless $secs;

   $fmt ||= $secs >= 86_400 ? 'd'
          : $secs >= 3_600  ? 'h'
          :                   'm';

   return
      $fmt eq 'd' ? sprintf(
         "%d+%02d:%02d:%02d",
         int($secs / 86_400),
         int(($secs % 86_400) / 3_600),
         int(($secs % 3_600) / 60),
         $secs % 60)
      : $fmt eq 'h' ? sprintf(
         "%02d:%02d:%02d",
         int(($secs % 86_400) / 3_600),
         int(($secs % 3_600) / 60),
         $secs % 60)
      : sprintf(
         "%02d:%02d",
         int(($secs % 3_600) / 60),
         $secs % 60);
}

sub time_to_secs {
   my ( $val, $default_suffix ) = @_;
   die "I need a val argument" unless defined $val;
   my $t = 0;
   my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
   $suffix = $suffix || $default_suffix || 's';
   if ( $suffix =~ m/[smhd]/ ) {
      $t = $suffix eq 's' ? $num * 1        # Seconds
         : $suffix eq 'm' ? $num * 60       # Minutes
         : $suffix eq 'h' ? $num * 3600     # Hours
         :                  $num * 86400;   # Days

      $t *= -1 if $prefix && $prefix eq '-';
   }
   else {
      die "Invalid suffix for $val: $suffix";
   }
   return $t;
}

sub shorten {
   my ( $num, %args ) = @_;
   my $p = defined $args{p} ? $args{p} : 2;     # float precision
   my $d = defined $args{d} ? $args{d} : 1_024; # divisor
   my $n = 0;
   my @units = ('', qw(k M G T P E Z Y));
   while ( $num >= $d && $n < @units - 1 ) {
      $num /= $d;
      ++$n;
   }
   return sprintf(
      $num =~ m/\./ || $n
         ? "%.${p}f%s"
         : '%d',
      $num, $units[$n]);
}

sub ts {
   my ( $time, $gmt ) = @_;
   my ( $sec, $min, $hour, $mday, $mon, $year )
      = $gmt ? gmtime($time) : localtime($time);
   $mon  += 1;
   $year += 1900;
   my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
      $year, $mon, $mday, $hour, $min, $sec);
   if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
      $us = sprintf("%.6f", $us);
      $us =~ s/^0\././;
      $val .= $us;
   }
   return $val;
}

sub parse_timestamp {
   my ( $val ) = @_;
   if ( my($y, $m, $d, $h, $i, $s, $f)
         = $val =~ m/^$mysql_ts$/ )
   {
      return sprintf "%d-%02d-%02d %02d:%02d:"
                     . (defined $f ? '%02.6f' : '%02d'),
                     $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
   }
   return $val;
}

sub unix_timestamp {
   my ( $val, $gmt ) = @_;
   if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
      $val = $gmt
         ? timegm($s, $i, $h, $d, $m - 1, $y)
         : timelocal($s, $i, $h, $d, $m - 1, $y);
      if ( defined $us ) {
         $us = sprintf('%.6f', $us);
         $us =~ s/^0\././;
         $val .= $us;
      }
   }
   return $val;
}

sub any_unix_timestamp {
   my ( $val, $callback ) = @_;

   if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      $n = $suffix eq 's' ? $n            # Seconds
         : $suffix eq 'm' ? $n * 60       # Minutes
         : $suffix eq 'h' ? $n * 3600     # Hours
         : $suffix eq 'd' ? $n * 86400    # Days
         :                  $n;           # default: Seconds
      MKDEBUG && _d('ts is now - N[shmd]:', $n);
      return time - $n;
   }
   elsif ( $val =~ m/^\d{9,}/ ) {
      MKDEBUG && _d('ts is already a unix timestamp');
      return $val;
   }
   elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
      MKDEBUG && _d('ts is MySQL slow log timestamp');
      $val .= ' 00:00:00' unless $hms;
      return unix_timestamp(parse_timestamp($val));
   }
   elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
      MKDEBUG && _d('ts is properly formatted timestamp');
      $val .= ' 00:00:00' unless $hms;
      return unix_timestamp($val);
   }
   else {
      MKDEBUG && _d('ts is MySQL expression');
      return $callback->($val) if $callback && ref $callback eq 'CODE';
   }

   MKDEBUG && _d('Unknown ts type:', $val);
   return;
}

sub make_checksum {
   my ( $val ) = @_;
   my $checksum = uc substr(md5_hex($val), -16);
   MKDEBUG && _d($checksum, 'checksum for', $val);
   return $checksum;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End Transformers package
# ###########################################################################

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
#
# Check at the end of this package for the call to main() which actually runs
# the program.
# ###########################################################################
package mysql_replication_monitor;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

use sigtrap 'handler', \&sig_int, 'normal-signals';

Transformers->import qw(ts secs_to_time);

$OUTPUT_AUTOFLUSH = 1;

my $oktorun;
my $quiet;

sub main {
   @ARGV = @_;  # set global ARGV for this package

   # Reset global vars else testing will break.
   $oktorun = 1;
   $quiet   = 0;

   # ##########################################################################
   # Get configuration information.
   # ##########################################################################
   my $o = new OptionParser(
      strict      => 0,
      prompt      => '[OPTION...] --servers DSN --state DSN',
      description => 'updates the --state table for each server listed in '
                   . 'the --servers DSN.'

   );
   $o->get_specs();
   $o->get_opts();

   my $dp = $o->DSNParser();
   $dp->prop('set-vars', $o->get('set-vars'));

   # Check that both --servers and --state specify a database and table.
   my $q = new Quoter();
   foreach my $opt ( qw(servers state) ) {
      my $dsn = $o->get($opt);
      my ($db, $tbl) = ($dsn->{D}, $dsn->{t});
      if ( !$tbl ) {
         $o->save_error("--$opt DSN does not specify a table (t)");
      }
      else {
         # There's a table, but is there a database?
         ($db, undef) = $q->split_unquote($tbl) unless $db;
         if ( !$db ) {
            $o->save_error("--$opt DSN specifies a table (t) but not a database (D)");
         }
      }
   }

   my $observer = $o->get('observer-name');
   if ( !$observer ) {
      chomp(my $hostname = `hostname`);
      if ( !$hostname ) {
         $o->save_error("Cannot get hostname.  You will need to specify "
            . " --observer-name");
      }
      else {
         $observer = $hostname;
         $o->set('observer-name', $observer);
      }
   }

   if ( $o->get('check-logs') !~ m/all|none|failed/i ) {
      $o->save_error("--check-logs=" . $o->get('check-logs') . " is invalid, "
         . "value must be all, none or failed");
   }

   if ( $o->get('run-time') && $o->get('interval') > $o->get('run-time') ) {
      $o->save_error("--interval=" . $o->get('interval') . " is greater than "
         . "--run-time=" . $o->get('run-time'));
   }

   $quiet = $o->get('quiet');  # global for _log()

   $o->usage_or_errors();

   # ########################################################################
   # Make common modules to pass to various subroutines.
   # ########################################################################
   my %common_modules = (
      OptionParser => $o,
      DSNParser    => $dp,
      Quoter       => $q,
   );
   
   # ########################################################################
   # Ask for the password before daemonizing, while we still have a terminal.
   # ########################################################################
   if ( $o->get('ask-pass') ) {
      my $pass = OptionParser::prompt_noecho("Enter password: ");
      foreach my $opt ( qw(servers state) ) {
         my $dsn       = $o->get($opt);
         next if $dsn->{p};
         $dsn->{p}     = $pass;
         $o->get($opt) = $dsn;
      }
   }

   # ########################################################################
   # Create servers and state tables.  Terminate early if they can't be
   # created.
   # ########################################################################
   foreach my $tbl ( qw(servers state) ) {
      if ( $o->get("create-$tbl-table") ) {
         eval {
            create_table(
               tbl => $tbl,
               %common_modules,
            );
         };
         if ( $EVAL_ERROR ) {
            warn "--create-$tbl-table failed: $EVAL_ERROR";
            return 1;
         }
         _log("Created $tbl table");
      }
   }


   # ########################################################################
   # Daemonize now that everything is setup and ready to work.
   # ########################################################################
   my $daemon;
   if ( $o->get('daemonize') ) {
      $daemon = new Daemon(o=>$o);
      $daemon->daemonize();
      MKDEBUG && _d('I am a daemon now');
   }
   elsif ( $o->get('pid') ) {
      # We're not daemoninzing, it just handles PID stuff.
      $daemon = new Daemon(o=>$o);
      $daemon->make_PID_file();
   }

   # #########################################################################
   # Ready to run.
   # #########################################################################
   _log("$PROGRAM_NAME started, observer $observer, PID $PID");
   
   my $run_time = $o->get('run-time');
   _log("Ready to run; run time: "
         . (  $o->get('run-once') ? 'once'
            : $run_time           ? secs_to_time($run_time)
            :                       'forever'));

   my $start       = time();
   my $end         = $run_time ? $start + $run_time : 0;
   my $checkno     = 0;
   my $exit_status = 0;
   while (                         # Quit if:
      $oktorun                     # instructed to quit
      && (!$end || time < $end)    # or time is exceeded
      && !-f $o->get('sentinel') ) # or stop file exists
   {
      $checkno++;
      _log("Start check number $checkno");

      # ######################################################################
      # Get list of monitored servers from --servers.
      # ######################################################################
      my @monitored_servers = get_monitored_servers(
         dsn   => $o->get('servers'),
         where => $o->get('where'),
         %common_modules,
      );

      # ######################################################################
      # Check monitored servers and update --state DSN.
      # ######################################################################
      if ( @monitored_servers ) {

         # Try to connect to state server.  Hopefully it's alive because
         # if not we're out of luck and it's not worth checking the monitored
         # servers if we can't save the results... yet: TODO: save results
         # until a state server comes back online.
         eval {
            my $state_dbh = get_cxn(dsn=>$o->get('state'), %common_modules);
            $state_dbh->disconnect();
         };
         if ( $EVAL_ERROR ) {
            chomp $EVAL_ERROR;
            my $host = $dp->as_string($o->get('state'));
            _log("Cannot connect to --state $host: $EVAL_ERROR");

            $exit_status |= 1;
         }
         else {
            $exit_status |= check_servers(
               servers    => \@monitored_servers,
               state_dsn  => $o->get('state'),
               observer   => $observer,
               replace    => $o->get('replace'),
               %common_modules,
            )
         }
      }
      else {
         _log("No servers to monitor");
      }

      # ######################################################################
      # Sleep before next check or exit for --run-once.
      # ######################################################################
      _log("End check number $checkno");

      if ( $o->get('run-once') ) {
         _log("Ending for --run-once");
         last;
      }

      my $sleep = $o->get('interval');
      _log("Sleeping $sleep seconds for --interval");
      sleep $sleep;
   }

   _log("$PROGRAM_NAME ended, exit status $exit_status");
   return $exit_status;
} # End main()

# ############################################################################
# Subroutines.
# ############################################################################

sub get_monitored_servers {
   my ( %args ) = @_;
   my @required_args = qw(dsn DSNParser Quoter OptionParser);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($dsn, $dp, $q) = @args{@required_args};

   my $host = $dp->as_string($dsn); 
   _log("Getting servers to monitor from $host");

   my $dbh;
   eval {
      $dbh = get_cxn(%args);
   };
   if ( $EVAL_ERROR ) {
      chomp $EVAL_ERROR;
      _log("Cannot connect to --servers $host: $EVAL_ERROR");
      return;
   }

   my $tbl = $q->join_quote($dsn->{D}, $dsn->{t});
   my @servers;
   eval {
      @servers = get_servers_from_table(
         dbh => $dbh,
         tbl => $tbl,
         %args,
      );
   };
   if ( $EVAL_ERROR ) {
      chomp $EVAL_ERROR;
      _log("Failed to get monitored server from $tbl: $EVAL_ERROR");
      $dbh->disconnect();
      return;
   }
   _log("Got " . (scalar @servers) . " servers");

   # Parse the server dsn strings into real dsn structs.
   for my $i ( 0..$#servers ) {
      my $server = $servers[$i];
      eval {
         my $dsn = $dp->parse($server->{dsn});
         $server->{dsn} = $dsn;
      };
      if ( $EVAL_ERROR ) {
         chomp $EVAL_ERROR;
         _log("Failed to parse server $server->{name} DSN $server->{dsn}: "
            . $EVAL_ERROR);
         _log("Server $server->{name} will not be checked");
         delete $servers[$i];
      }
   }

   $dbh->disconnect();

   # Some servers may have been deleted.  Return only defined servers.
   return grep { $_ } @servers;
}

sub get_servers_from_table {
   my ( %args ) = @_;
   my @required_args = qw(dbh tbl);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($dbh, $tbl, $dp) = @args{@required_args};

   my $sql = "SELECT server AS name, dsn, mk_heartbeat_file "
           . "FROM $tbl WHERE "
           . ($args{where} ? $args{where} : "1=1");
   MKDEBUG && _d($dbh, $sql);
   my $rows = $dbh->selectall_hashref($sql, 'name');
   my @servers;
   foreach my $row ( values %$rows ) {
      push @servers, $row;
   };
   return @servers;
}

sub create_table {
   my ( %args ) = @_;
   my @required_args = qw(tbl OptionParser Quoter DSNParser);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($tbl, $o, $q) = @args{@required_args};

   my $dbh;
   my $magic;
   my $db_tbl;
   if ( $tbl =~ m/servers|state/ ) {
      my $dsn = $o->get($tbl);
      $dbh    = get_cxn(dsn=>$dsn, %args);
      $db_tbl = $q->join_quote($dsn->{D}, $dsn->{t});
      $magic  = qr/MAGIC_${tbl}_table/;
   }
   else {
      die "Invalid table: $tbl; must be either 'servers' or 'state'"
   }

   _log("Creating $tbl table");
   my $sql = $o->read_para_after(__FILE__, $magic);
   $sql    =~ s/CREATE TABLE (\S+)/CREATE TABLE IF NOT EXISTS $db_tbl/;
   MKDEBUG && _d($dbh, $sql);
   $dbh->do($sql);
   $dbh->disconnect();
   return;
}

sub check_servers {
   my ( %args ) = @_;
   my @required_args = qw(servers state_dsn observer Quoter DSNParser);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($servers) = @args{@required_args};

   _log("Checking servers");

   return unless @$servers;

   # This signal handler will do nothing but wake up the sleeping parent
   # process and record the exit status and time of the child that exited
   # (as a side effect of not discarding the signal).
   my %kids;
   my %exited_children;
   $SIG{CHLD} = sub {
      my $kid;
      while (($kid = waitpid(-1, &POSIX::WNOHANG)) > 0) {
         MKDEBUG && _d('Process', $kid, 'exited with', $CHILD_ERROR);
         # Must right-shift to get the actual exit status of the child.
         $exited_children{$kid} = $CHILD_ERROR >> 8;
      }
   };

   my $exit_status = 0;
   foreach my $server ( @$servers ) {
      my $pid = fork();
      die "Failed to fork: $OS_ERROR" unless defined $pid;
      if ( $pid ) {                 # parent
         _log("Forked process $pid to check $server->{name}");
         $kids{$pid} = $server;
      }
      else {                        # child
         $SIG{CHLD} = 'DEFAULT';
         my $child_exit_status = check_server(
            server => $server,
            %args
         );
         exit $child_exit_status;
      }
   }

   # Wait for the kids.
   while ( scalar keys %kids ) {
      my $reaped = 0;
      foreach my $pid ( keys %exited_children ) {
         _log("Child process $pid finished checking $kids{$pid}->{name}, "
            . "exit status " . $exited_children{$pid});
         $reaped       = 1;
         $exit_status |= $exited_children{$pid};
         delete $kids{$pid};
         delete $exited_children{$pid};
      }
      if ( !$reaped ) {
         # Don't busy-wait.  But don't wait forever either, as a child
         # may exit and signal while we're not sleeping, so if we sleep
         # forever we may not get the signal.
         MKDEBUG && _d('No children reaped, sleeping');
         sleep 1;
      }
      _log("Waiting for " . (scalar keys %kids) . " processes")
         if scalar keys %kids;
   }

   _log("Done checking server");

   return $exit_status;
}

sub check_server {
   my ( %args ) = @_;
   my @required_args = qw(server state_dsn observer OptionParser Quoter DSNParser);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($server, $state_dsn, $observer, $o, $q, $dp) = @args{@required_args};

   my $exit_status = 0;

   # $quiet is global and we inherit it from the parent and determines
   # if _log() prints or not but as a child proc our check log is always
   # written and --check-logs controls whether the log is kept or not.
   # So reset our global copy of $quiet; this won't affect the parent.
   $quiet = 0;

   # First, ready our check log that the world may know of our exploits.
   # If check-logs=none we could just redirect STDOUT/STDERR >/dev/null
   # and then we wouldn't have to delete the check log later, but if we
   # do this and there's a code bug that causes a crash the error will
   # disappear into /dev/null.  By always writing a check log and then
   # deleting it later we can catch any code bugs/crashes even if
   # check-logs=none.
   local *STDOUT;
   local *STDERR;
   my $check_logs_dir = $o->get('check-logs-dir');
   my $check_log      = "$check_logs_dir/$observer.$PID";
   if ( !open STDOUT, '>', $check_log ) {
      # We can't reopen STDOUT to our check log.  Try to warn about
      # this on STDERR then continue.  We can still work.
      warn "Child process $PID failed to reopen STDOUT to "
            . "check log $check_log: $OS_ERROR";
   }
   open  STDERR, ">&STDOUT"
      or warn "Child process $PID failed dupe STDERR to STDOUT: $OS_ERROR";

   $OUTPUT_AUTOFLUSH = 1;

   _log("$PROGRAM_NAME child process started, check log $check_log, observer $observer, PID $PID");

   # Get a dbh to the monitored server.
   my $connection_ok = 1;
   my ($master_status, $slave_status);
   my $server_host = $dp->as_string($server->{dsn});
   _log("Checking monitored server $server->{name} $server_host");
   my $server_dbh;
   eval {
      $server_dbh = get_cxn(dsn=>$server->{dsn}, %args);
   };
   if ( $EVAL_ERROR ) {
      chomp $EVAL_ERROR;
      _log("Cannot connect to monitored server: $EVAL_ERROR");
      $connection_ok = 0;
      $exit_status  |= 1;
   }
   else {
      # Get master and slave status from the monitored server.
      $master_status = get_status('master', $server_dbh);
      _log("Got master status: " . ($master_status ? 'yes' : 'no'));

      $slave_status = get_status('slave', $server_dbh);
      _log("Got slave status: " . ($slave_status ? 'yes' : 'no'));

      $server_dbh->disconnect();

      if ( !$master_status && !$slave_status ) {
         _log("Got neither master nor slave status");
         $exit_status |= 1;
      }
   }

   my $real_lag;
   if ( $server->{mk_heartbeat_file} ) {
      $real_lag = get_real_lag(
         $o->get('mk-heartbeat-dir') . "/$server->{mk_heartbeat_file}");
   }

   # Get a dbh to the state server.
   my $state_dbh;
   eval {
      $state_dbh = get_cxn(dsn=>$state_dsn, %args);
   };
   if ( $EVAL_ERROR ) {
      chomp $EVAL_ERROR;
      my $host = $dp->as_string($state_dsn);
      _log("Cannot connect to --state $host: $EVAL_ERROR");
      return 1;
   }

   # Update the state table.
   my $tbl = $q->join_quote($state_dsn->{D}, $state_dsn->{t});
   my $sql = make_update_state_sql(
      tbl           => $tbl,
      master_status => $master_status,
      slave_status  => $slave_status,
      real_lag      => $real_lag,
      connection_ok => $connection_ok,
      %args,
   );

   _log("Updating state table on --state " . $dp->as_string($state_dsn) . ": "
      . $sql);
   MKDEBUG && _d($state_dbh, $sql);
   eval {
      $state_dbh->do($sql);
   };
   if ( $EVAL_ERROR ) {
      chomp $EVAL_ERROR;
      _log("Update failed: $EVAL_ERROR");
      $exit_status |= 1;
   }

   _log("$PROGRAM_NAME child process ended, exit status $exit_status");

   # Possibly delete our check log.
   my $check_logs = $o->get('check-logs');
   if (     $check_logs eq 'none'
        || ($check_logs eq 'failed' && $exit_status == 0) )
   {
      if ( !unlink $check_log ) {
         _log("Failed to delete check log $check_log: $OS_ERROR");
         $exit_status |= 1;
      }
   }

   return $exit_status;
}

sub make_update_state_sql {
   my ( %args ) = @_;
   my @required_args = qw(tbl observer server Quoter);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($tbl, $observer, $server, $q) = @args{@required_args};

   my $sql = ($args{replace} ? "REPLACE" : "INSERT") . " INTO $tbl SET "
           . "observer='$observer', "
           . "server='$server->{name}', "
           . "ts=NOW(), ";

   my @vals;

   # Add values from master status.
   if ( my $master_status = $args{master_status} ) {
      foreach my $stat ( qw(file position) ) {
         push @vals, "$stat=" . $q->quote_val($master_status->{$stat});
      }
   }
   
   # Add values from slave status.
   if ( my $slave_status = $args{slave_status} ) {
      foreach my $stat (
         qw(master_host master_port master_log_file read_master_log_pos
            relay_master_log_file exec_master_log_pos seconds_behind_master
            slave_io_running slave_sql_running) ) {
         if ( $stat =~ m/_running$/ ) {
            my $running = $slave_status->{$stat} || '';
            push @vals, "$stat=" . (  $running eq 'Yes' ? 1
                                    : $running eq 'No'  ? 0
                                    :                    'NULL');
         }
         else {
            push @vals, "$stat=" . $q->quote_val($slave_status->{$stat});
         }
      }
   }

   # Add real_lag.
   if ( defined $args{real_lag} ) {
      push @vals, "real_lag=" . $q->quote_val($args{real_lag});
   }
   
   # Add connection_ok.
   if ( defined $args{connection_ok} ) {
      push @vals, "connection_ok=" . $q->quote_val($args{connection_ok});
   }

   my $vals = join(', ', @vals);
   $sql    .= $vals;

   return $sql;
}

sub get_real_lag {
   my ( $heartbeat_file ) = @_;
   my $real_lag;
   _log("Getting real lag from mk-heartbeat file $heartbeat_file");
   if ( -f $heartbeat_file ) {
      my $fh;
      if ( open $fh, "<", $heartbeat_file ) {
         $real_lag = <$fh>;
         close $fh;
         if ( $real_lag ) {
            _log("Real lag: $real_lag");
            ($real_lag) = $real_lag =~ m/^\s*(\d+)/;
         }
         else {
            _log("mk-heartbeat file is empty");
         }
      }
      else {
         _log("Cannot open $heartbeat_file: $OS_ERROR");
      }
   }
   else {
      _log("mk-heartbeat file does not exist");
   }
   return $real_lag;
}

sub get_status {
   my ( $what, $dbh ) = @_;
   return unless $what;
   return unless $dbh;

   my $sql = "SHOW " . uc($what) . " STATUS";
   MKDEBUG && _d($dbh, $sql);
   my $status = $dbh->selectrow_hashref($sql);
   if ( $status && %$status ) {
      # lowercase the keys
      $status = { map { lc($_) => $status->{$_} } keys %$status };
      return $status;
   }

   return;
}

sub get_cxn {
   my ( %args ) = @_;
   my @required_args = qw(dsn OptionParser DSNParser);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($dsn, $o, $dp) = @args{@required_args};
   my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit=>1});
   $dbh->{InactiveDestroy} = 1;  # Don't die on fork().
   MKDEBUG && _d('Connected dbh', $dbh);
   return $dbh;
}

# Catches signals so we can exit gracefully.
sub sig_int {
   my ( $signal ) = @_;
   if ( $oktorun ) {
      _log("Caught SIG$signal");
      $oktorun = 0;
   }
   else {
      _log("Exiting on SIG$signal");
      exit 1;
   }
}

sub _log {
   my ( $msg ) = @_;
   if ( $quiet ) {
      MKDEBUG && _d(ts(time), $msg);
   }
   else {
      my $ts = ts(time);
      print "# $ts $msg\n";
   }
   return;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

# ############################################################################
# Run the program.
# ############################################################################
if ( !caller ) { exit main(@ARGV); }

1; # Because this is a module as well as a script.

# #############################################################################
# Documentation.
# #############################################################################

=pod

=head1 NAME

mysql-replication-monitor - MySQL replication state monitor.

=head1 SYNOPSIS

Check servers listed in `rmf`.`monitored_servers` on localhost,
update `rmf`.`state` on master1, daemonize, log all output to mysql-rmf.log,
check every minute and run forever:

   mysql-replication-monitor                        \
      --servers h=localhost,t=rmf.monitored_servers \
      --state h=master1,t=rmf.state                 \
      --daemonize                                   \
      --log mysql-rmf.log

Check servers once and exit:

   mysql-replication-monitor                        \
      --servers h=localhost,t=rmf.monitored_servers \
      --state h=master1,t=rmf.state                 \
      --run-once

Check only server "db2" every 10 minutes for 1 hour, save all check logs
in /var/log/checks/:

   mysql-replication-monitor                        \
      --servers h=localhost,t=rmf.monitored_servers \
      --where "server='db2'"                        \
      --state h=master1,t=rmf.state                 \
      --run-time 1h                                 \
      --interval 10m                                \
      --check-logs all                              \
      --check-logs-dir /var/log/checks/

=head1 DESCRIPTION

mysql-replication-monitor is a tool for constantly monitoring and logging
the state of replication of multiple MySQL servers.  Each host that runs
the tool is an "observer" which checks a list of "monitored servers."  The
list of monitored servers is selected from the table specified by the tool's
required L<"--servers"> option.  The tool forks a child process for each
monitored server to check and log its SHOW MASTER STATUS, SHOW SLAVE STATUS
and (optionally) mk-heartbeat real lag to the table specified by the tool's
required L<"--state"> option.  By default the tool run forever, performing
checks every minute on all the monitored servers.

The L<"--servers"> and L<"--state"> tables are usually shared so that all
observers check the same monitored servers and update the same state table.
For example, consider this replication topology:

  S1 <- M1 <=> M2 -> S2

There are two slaves (S1, S2) and two masters (M1, M2) in a master-master
setup.  If the tables are created and updated on M1 they will replicate to
all the servers.  For full, redundant monitoring, every server is an
observer that monitors every other server, including itself.  All observers
update the state table on M1.  Each check will produce 16 new rows in the
state table: S1 checking itself, M1, M2 and S2; M1 checking S1, itself, M2
and S2; etc.

Each update to the state table is actually an C<INESRT> statement.  This
builds a history of the state of replication of the observered servers over
time because each update is timestamped and records which observer was
checking which monitored server.

The tool is designed to run "forever" and retry after any failures.  Before
each check the list of monitored server is selected from the L<"--servers">
table.  Therefore you can add and remove servers from this table and every
observer will refesh its list at its next check.

If, during a check, a connection cannot be made to a monitored server, the
L<"--state"> table is updated with C<NULL> values for the master and slave
status values (C<position>, C<slave_io_running>, etc.), C<connection_ok> is
set to zero and the child process that attempted the check will log something
like "Cannot connect to monitored server: ..." in its check log.  Since check
logs from failed checks are saved, you can review this log to see why the
connection failed.  If the child process cannot connect to the L<"--state">
server no new row will be inserted.

As long as the child process doing a check can connect to both the monitored
server and the L<"--state"> server, then it should update the state table
with whatever SHOW MASTER STATUS, SHOW SLAVE STATUS, and (optionally)
mk-heartbeat return for the monitored server.

=head1 OUTPUT

By default the tool's output is very verbose; the parent process prints
information like:

  # 2010-05-06T12:05:52 Creating state table
  # 2010-05-06T12:05:52 Created state table
  # 2010-05-06T12:05:52 mysql-replication-monitor started, observer dante, PID 9
  # 2010-05-06T12:05:52 Ready to run; run time: once
  # 2010-05-06T12:05:52 Start check number 1
  # 2010-05-06T12:05:52 Getting servers to monitor from h=127.1,t=test.servers
  # 2010-05-06T12:05:52 Got 1 servers
  # 2010-05-06T12:05:52 Checking servers
  # 2010-05-06T12:05:52 Forked process 15224 to check master
  # 2010-05-06T12:05:52 Waiting for 1 processes
  # 2010-05-06T12:05:52 Child process 15224 finished checking master
  # 2010-05-06T12:05:52 Done checking server
  # 2010-05-06T12:05:52 End check number 1
  # 2010-05-06T12:05:52 Ending for --run-once
  # 2010-05-06T12:05:52 mysql-replication-monitor ended

Each child process that the parent process forks to perform checks on the
monitored servers also writes verbose logs by default; these are called
L<"--check-logs">.

Specifying L<"--quiet"> disables all output from the parent process (check
logs are still written and controlled by L<"--check-logs">) but you probably
shouldn't do this because the tool may fail silently even though it continues
to run.

=head1 CHECK RESOLUTION

Checks have a one second resolution because the C<ts> column of the
L<"--state"> table has a one second resolution.  For normal runs this should
be sufficient.  However, if two checks are back-to-back (e.g. two
L<"--run-once"> runs) the second check will probably fail with duplicate key
errors because the primary key of the state table covers columns
C<server, ts, observer> and the timestamp will be the same for the two
runs.  You can specify the L<"--replace"> option to use C<REPLACE> instead
of C<INSERT> statements when updating the state table.  This prevents
duplicate key errors but does not increase the resolution of checks
beyond one second--i.e. there is currently no way to check and log the
state of the monitored servers multiple times in less than one second.

=head1 INTEGRATION WITH mk-heartbeat

mysql-replication-monitor can integrate with already running instances of
Maatkit's mk-heartbeat tool which measures and records "real" slave lag.
Each instance of mk-heartbeat must be ran with its C<--file> option to
save its output to a file that is accessible by the observer.  This base
file name--just the file name, no paths/directories--is saved in the
C<mk_heartbeat_file> column of the L<"--servers"> table for the server
that it applies to.  Therefore, mk-heartbeat file names are the same
on every observer for each monitored server.

For example, suppose the topology is:

  S1 <- M -> S2

There is one master (M) and two slave, each is an observer monitoring all
three servers.  Real lag is monitored on the slaves, so the L<"--servers">
table has rows like:

              server: master
                 dsn: ...
   mk_heartbeat_file: NULL

              server: slave1
                 dsn: ...
   mk_heartbeat_file: slave1-heartbeat

              server: slave2
                 dsn: ...
   mk_heartbeat_file: slave2-heartbeat

Notice that the C<mk_heartbeat_file> column for the master server's row is
NULL because it's not being monitored by mk-heartbeat.

First, to create the heartbeat, mk-heartbeat is ran on just the master like:

  mk-heartbeat -D repl --update h=master --daemonize

(This assumes that you've already created the heartbeat table
C<repl.heartbeat>.)  Then on each server, including the master, mk-heartbeat
is ran like:

  mk-heartbeat -D repl --monitor h=slave1           \
                       --file /tmp/slave1-heartbeat \
                       --daemonize

  mk-heartbeat -D repl --monitor h=slave2           \
                       --file /tmp/slave2-heartbeat \
                       --daemonize

Finally, since each server is saving its heartbeat files in C</tmp/>,
mysql-replication-monitor is started with L<"--mk-heartbeat-dir">=C</tmp/>.

When a check happens and the C<mk_heartbeat_file> column is not null,
the tool looks for that file in the L<"--mk-heartbeat-dir">.  So each
server/observer can save its heartbeat files to different directores, but
since the values in the L<"--servers"> table are shared, the heartbeat files
must be the same on each server/observer.

If mk-heartbeat integration is setup correctly, the L<"--check-logs"> (if
they're kept) will contain output like,

  # 2010-05-07T08:50:28 Getting real lag from mk-heartbeat file /tmp/mk-heartbeat.slave
  # 2010-05-07T08:50:28 Real lag:    0s [  0.00s,  0.00s,  0.00s ]

and the C<real_lag> column in the L<"--state"> table will not be null.

=head1 EXIT STATUS

The tool exits 0 if there were no errors, else it exits 1 if either the
parent or any child process ever had an error.

=head1 OPTIONS

=over

=item --ask-pass

group: Connection

Prompt for a password when connecting to MySQL.

=item --charset

short form: -A; type: string; group: Connection

Default character set.  If the value is utf8, sets Perl's binmode on
STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
binmode on STDOUT without the utf8 layer, and runs SET NAMES after
connecting to MySQL.

=item --check-logs

type: string; default: all

Save logs from child processes that check the L<"--servers">.

A child process is forked to check each server in L<"--servers"> in parallel.
These child processes do not share STDOUT/STDERR with the parent process
so, instead, they log to separate files under L<"--check-logs-dir">.  These
files are named "observer-name.PID" where observer-name is L<"--observer-name">
and PID is the process ID of the child process that wrote the log.  The parent
process reports the PID of every child process it forks, so if there is a
problem and check logs are saved, the problem can be found in the corresponding
child process's check log.

There are three possible values for this option:

  VALUE   SAVES
  ======  ================================================
  failed  Only check logs from child processes that failed
          or had an error; delete check logs from children
          that do not fail
  all     Every check log from both successful and failed
          child processes
  none    Do not save any check logs

With the default value of "all", you will need to set up something like
logrotate to make sure the logs don't fill your hard disk over time.

=item --check-logs-dir

type: string; default: /tmp

Save L<"--check-logs"> in this directory.

=item --config

type: Array; group: Connection

Read this comma-separated list of config files; if specified, this must be the
first option on the command line.

=item --create-servers-table

Create monitored servers table on the L<"--servers"> DSN if it does not exist.

If the monitored servers table is missing on the L<"--servers">, specifying
this option will cause it to be created.  The following MAGIC_servers_table
will be created, with the table name replace by the one given in the DSN:

  CREATE TABLE `servers` (
    `server`            VARCHAR(64) NOT NULL,
    `dsn`               VARCHAR(128) NOT NULL,
    `virtual_ip`        VARCHAR(16) NOT NULL,
    `interface`         VARCHAR(8) NOT NULL,
    `ssh_user_host`     VARCHAR(128),
    `mk_heartbeat_file` VARCHAR(128),
    `comment`           VARCHAR(255),
    PRIMARY KEY (`server`)
  )

If the table cannot be created the tool will terminate with exit status 1.

=item --create-state-table

Create state table on the L<"--state"> DSN if it does not exist.

If the state table is missing on the L<"--state"> DSN, specifying
this option will cause it to be created.  The following MAGIC_state_table will 
be created, with the table name replace by the one given in the DSN:

  CREATE TABLE `state` (
    `observer`              VARCHAR(24) NOT NULL,
    `server`                VARCHAR(64) NOT NULL,
    `ts`                    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    `file`                  VARCHAR(128) DEFAULT NULL,
    `position`              INT UNSIGNED DEFAULT NULL,
    `master_host`           VARCHAR(64) DEFAULT NULL,
    `master_port`           SMALLINT UNSIGNED DEFAULT NULL,
    `master_log_file`       VARCHAR(128) DEFAULT NULL,
    `read_master_log_pos`   INT UNSIGNED DEFAULT NULL,
    `relay_master_log_file` VARCHAR(128) DEFAULT NULL,
    `exec_master_log_pos`   INT UNSIGNED DEFAULT NULL,
    `seconds_behind_master` INT UNSIGNED DEFAULT NULL,
    `slave_io_running`      TINYINT UNSIGNED DEFAULT NULL,
    `slave_sql_running`     TINYINT UNSIGNED DEFAULT NULL,
    `real_lag`              INT UNSIGNED DEFAULT NULL,
    `connection_ok`         TINYINT UNSIGNED DEFAULT NULL,
    PRIMARY KEY (`server`, `ts`, `observer`)
  )

If the table cannot be created the tool will terminate with exit status 1.

=item --daemonize

Fork to the background and detach from the shell.  POSIX
operating systems only.

=item --defaults-file

short form: -F; type: string; group: Connection

Only read mysql options from the given file.  You must give an absolute pathname.

=item --help

Show help and exit.

=item --host

short form: -h; type: string; group: Connection

Connect to host.

=item --interval

type: time; default: 1m; group: Run time

How frequently to check the L<"--servers">.

=item --log

type: string

Print all output to this file when daemonized.

=item --mk-heartbeat-dir

type: string; default: ./

Directory that has mk-heartbeat files.

The L<"--servers"> may specify an mk-heartbeat file.  The file names
should be the same on every observer but the directory they're stored in
can be different on each observer.  This option specifies the directory for
mk-heartbeat files on this observer.

See L<"INTEGRATION WITH mk-heartbeat">.

=item --observer-name

type: string

Set the name of this observer.  If not explicitly set C<`hostname`> is used.

=item --password

short form: -p; type: string; group: Connection

Password to use when connecting.

=item --pid

type: string

Create the given PID file when daemonized.  The file contains the process
ID of the daemonized instance.  The PID file is removed when the
daemonized instance exits.  The program checks for the existence of the
PID file when starting; if it exists and the process with the matching PID
exists, the program exits.

=item --port

short form: -P; type: int; group: Connection

Port number to use for connection.

=item --quiet

short form: -q

Disable all output to STDOUT except L<"--check-logs">.

=item --replace

REPLACE INTO L<"--state"> table instead of INSERT.

=item --run-once

group: Run time

Check L<"--servers">, update L<"--state"> table once, then exit.

Normally the tool runs for L<"--run-time"> amount of time, checking the
L<"--servers"> and updating the L<"--state"> table at each L<"--interval">.
Specifying this option causes the tool to run, do its work and exit.

=item --run-time

type: time; group: Run time

How long to run before exiting.  The default is to run forever (you can
interrupt with CTRL-C).  See also L<"--interval">.

=item --sentinel

type: string; default: /tmp/mysql-replication-monitor-sentinel

Exit if this file exists.

=item --servers

type: DSN; group: Required

Monitor each server listed in the table on this DSN (required).

This required DSN specifies the host and table which lists the servers
to monitor.  The table should already exist.  For each server, the L<"--state">
table is updated.

See L<"--create-servers-table"> for the minimum necessary table schema.

=item --set-vars

type: string; default: wait_timeout=10000; group: Connection

Set these MySQL variables.  Immediately after connecting to MySQL, this
string will be appended to SET and executed.

=item --socket

short form: -S; type: string; group: Connection

Socket file to use for connection.

=item --state

type: DSN; group: Required

Update the state table on this DSN (required).

This required DSN specifies the host and state table to update for each
server listed in the monitored servers table on the L<"--servers"> DSN.
The state table should already exist.

See L<"--create-state-table"> for the minimum necessary table schema.

=item --user

short form: -u; type: string; group: Connection

User for login if not current user.

=item --version

Show version and exit.

=item --where

type: string

Filter the list of L<"--servers"> by this C<WHERE> clause.

By default all servers in the L<"--servers"> table are monitored.  To
select and monitor specific servers, specify a C<WHERE> clause (without
the word C<WHERE>) with this option.

For example, to select and update the L<"--state"> table for only server "db1",
specify C<--where "server='db1'">.

Valid C<WHERE> clauses depend on the table being used for L<"--servers">.
See L<"--create-servers-table"> for the default table.

=back

=head1 DSN OPTIONS

These DSN options are used to create a DSN.  Each option is given like
C<option=value>.  The options are case-sensitive, so P and p are not the
same option.  There cannot be whitespace before or after the C<=> and
if the value contains whitespace it must be quoted.  DSN options are
comma-separated.  See the L<maatkit> manpage for full details.

=over

=item * A

dsn: charset; copy: yes

Default character set.

=item * D

dsn: database; copy: yes

Database that contains the query review table.

=item * F

dsn: mysql_read_default_file; copy: yes

Only read default options from the given file

=item * h

dsn: host; copy: yes

Connect to host.

=item * p

dsn: password; copy: yes

Password to use when connecting.

=item * P

dsn: port; copy: yes

Port number to use for connection.

=item * S

dsn: mysql_socket; copy: yes

Socket file to use for connection.

=item * t

Table to use as the query review table.

=item * u

dsn: user; copy: yes

User for login if not current user.

=back

=head1 SYSTEM REQUIREMENTS

You need Perl and some core packages that ought to be installed in any
reasonably new version of Perl.

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright 2010 Percona Inc.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Daniel Nichter, Peter Zaitsev

=head1 VERSION

This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision$.

=cut
