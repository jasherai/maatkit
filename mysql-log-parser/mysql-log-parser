#!/usr/bin/perl

# This program is copyright (c) 2007 Baron Schwartz.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
# ###########################################################################

package LogParser;

use English qw(-no_match_vars);

sub new {
   bless {}, shift;
}

sub parse_event {
   my ( $self, $fh, $code ) = @_;
   my $event = { ts => '', id => '', cmd => '', arg => '' };
   my ($line, $done);
   while ( !$done && defined($line = <$fh>) ) {

      # Match the beginning of an event
      my ( $ts, $id, $rest ) = $line =~ m{
            ^
            (?:(\d{6}\s+\d{1,2}:\d\d:\d\d)|\t)?
            \t
            (?:\s*(\d+))
            \s
            (.*)
            $
         }x;
      if ( defined $id ) {
         my ( $cmd, $arg ) = $rest =~ m{
               ^(
                  Connect
                  Field\sList
                  Init\sDB
                  Query
                  Quit
               )
               (?:\s+(.*))?
            }x;
         $event = {
            ts  => $ts || '',
            id  => $id,
            cmd => $cmd,
            arg => $arg || '',
         };
         $done = 1;
      }

   }
   $code->($event);
}

# ###########################################################################
# And now for the "program".
# ###########################################################################
package main;

use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", q$Revision$ =~ m/(\d+)/g || 0);

if ( !caller ) {

   # ############################################################################
   # Get configuration information.
   # ############################################################################

   my @opt_spec = (
      { s => 'help',              d => 'Show this help message' },
      { s => 'version',           d => 'Output version information and exit' },
   );

   my %opts;
   my %opt_seen;
   foreach my $spec ( @opt_spec ) {
      my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
      $spec->{k} = $short || $long;
      $spec->{l} = $long;
      $spec->{t} = $short;
      $spec->{n} = $spec->{s} =~ m/!/;
      $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
      die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
   }

   Getopt::Long::Configure('no_ignore_case', 'bundling');
   GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

   if ( $opts{version} ) {
      print "$PROGRAM_NAME  Ver $VERSION Distrib $DISTRIB Changeset $SVN_REV\n";
      exit(0);
   }

   if ( $opts{help} ) {
      print "Usage: mysql-log-parser <options> [FILE ..]\n\n";
      my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
      foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
         my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
         my $short = $spec->{t} ? "-$spec->{t}" : '';
         printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
      }
      (my $usage = <<"      USAGE") =~ s/^         //gm;

         mysql-log-parser reads from FILE.  With no FILE, or when FILE is -, read
         standard input.  For more details, please read the documentation:

            perldoc mysql-log-parser

      USAGE
      print $usage;
      exit(0);
   }
}

1; # Because this is a runnable module.
