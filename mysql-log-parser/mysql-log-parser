#!/usr/bin/perl

# This program is copyright (c) 2007 Baron Schwartz.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
# ###########################################################################

package LogParser;

use English qw(-no_match_vars);

sub new {
   bless {}, shift;
}

# This method accepts an open filehandle and a callback function.  It reads an
# event from the filehandle and calls the callback with it.
#
# Each event looks like this:
#  my $event = {
#     ts  => '',    # Timestamp
#     id  => '',    # Connection ID
#     cmd => '',    # Command (type of event)
#     arg => '',    # Argument to the command
#  };
#
# Returns true if it was able to find an event.
sub parse_event {
   my ( $self, $fh, $code ) = @_;
   my $event;

   my $done = 0;
   my $i    = 0;
   my $line = defined $self->{last_line} ? $self->{last_line} : <$fh>;

   LINE:
   while ( !$done && defined $line ) {

      # These can appear in the log file when it's opened -- for example, when
      # someone runs FLUSH LOGS.
      if ( $line !~ m/^Time\s+Id\s+Command\s+Argument|Version:.*?started with:|Tcp port:|Unix socket:/ ) {

         # Match the beginning of an event
         my ( $ts, $id, $rest ) = $line =~ m{
               \A
               (?:(\d{6}\s+\d{1,2}:\d\d:\d\d)|\t)?
               \t
               (?:\s*(\d+))
               \s
               (.*)
               \Z
            }xs;
         if ( defined $id ) {
            $self->{last_line} = undef;
            if ( $i == 0 ) {
               my ( $cmd, $arg ) = $rest =~ m{
                     \A(
                        Connect
                        |Field\sList
                        |Init\sDB
                        |Query
                        |Quit
                     )
                     (?:\s+(.*\Z))?
                  }xs;
               $event = {
                  ts  => $ts || '',
                  id  => $id,
                  cmd => $cmd,
                  arg => $arg || '',
               };
               if ( $cmd ne 'Query' ) {
                  $done = 1;
                  chomp $event->{arg};
               }
            }
            else {
               # The last line was the end of the query; this is the beginning of
               # the next.  Save it for the next round.
               $self->{last_line} = $line;
               $done = 1;
               chomp $event->{arg};
            }
         }
         else {
            $event->{arg} .= $line;
         }

         $i++;
      }
      $line = <$fh> unless $done;
   }

   $code->($event) if $event;
   return $event;
}

# ###########################################################################
# And now for the "program".
# ###########################################################################
package main;

use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", q$Revision$ =~ m/(\d+)/g || 0);

if ( !caller ) {

   # ############################################################################
   # Get configuration information.
   # ############################################################################

   my @opt_spec = (
      { s => 'help',              d => 'Show this help message' },
      { s => 'version',           d => 'Output version information and exit' },
   );

   my %opts;
   my %opt_seen;
   foreach my $spec ( @opt_spec ) {
      my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
      $spec->{k} = $short || $long;
      $spec->{l} = $long;
      $spec->{t} = $short;
      $spec->{n} = $spec->{s} =~ m/!/;
      $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
      die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
   }

   Getopt::Long::Configure('no_ignore_case', 'bundling');
   GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

   if ( $opts{version} ) {
      print "$PROGRAM_NAME  Ver $VERSION Distrib $DISTRIB Changeset $SVN_REV\n";
      exit(0);
   }

   if ( $opts{help} ) {
      print "Usage: mysql-log-parser <options> [FILE ..]\n\n";
      my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
      foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
         my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
         my $short = $spec->{t} ? "-$spec->{t}" : '';
         printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
      }
      (my $usage = <<"      USAGE") =~ s/^         //gm;

         mysql-log-parser reads from FILE.  With no FILE, or when FILE is -, read
         standard input.  For more details, please read the documentation:

            perldoc mysql-log-parser

      USAGE
      print $usage;
      exit(0);
   }
}

1; # Because this is a runnable module.
