#!/usr/bin/perl

# This is mysql-archiver, a program to archive records from one MySQL table to
# a file and/or another table.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);
use IO::File;

# Output to a file or to STDOUT
# Specify where to archive to (file, other DB)
# specify table, index to use
# specify earliest date range
# specify how many in a chunk, whether to use txn
# specify maximum runtime
# Allow to ANALYZE TABLE or OPTIMIZE TABLE after or before
# whether to print progress to output, and how often (how many rows, how many
# secs?)
# Use HANDLER interface: http://dev.mysql.com/doc/refman/5.0/en/handler.html

our $VERSION = '@VERSION@';

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args.
my @opt_spec = (
   { s => 'defaults-file|F=s', d => 'Only read default options from the given file' },
   { s => 'dest|d=s',          d => 'Table to archive to' },
   { s => 'file|f=s',          d => 'File to archive to' },
   { s => 'header',            d => 'Print column header at top of --file' },
   { s => 'help',              d => 'Show this help message' },
   { s => 'source|s=s',        d => 'Table to archive from' },
);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts;

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

my $source = parse_dsn($opts{s});
my $dest   = parse_dsn($opts{d}, $source) if $source;

if ( $opts{help} || !$source || (!$dest && !$opts{f}) ) {
   print "Usage: mysql-archiver <options>\n\n";
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

mysql-archiver nibbles records from a table.  Connection options are read from
MySQL option files.  For more details, please read the documentation:

   perldoc mysql-archiver

USAGE
   exit(1);
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################
my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');

foreach my $table ( $source, $dest ) {
   my $dbh        = get_dbh($table);
   $table->{dbh}  = $dbh;

   $table->{db_tbl} =
      join('.',
      map  { $dbh->quote_identifier($_) }
      grep { $_ }
      map  { $_ =~ s/(^`|`$)//g; $_; }
      grep { $_ }
      ( $table->{D}, $table->{t} ));
   $table->{info} = get_tbl_struct($table);
}

# TODO: catch signals and exit gracefully
# Discover tbl structure
# Design first-row, next-row, insert, delete stmts
# notice if climbing a unique, single-column index

# Design statements for finding and manipulating data
my $sth;
my %queries;

my $get_first = $dbh->prepare(
   "select * from rkmain.ad use index(PRIMARY)
      where not exists (
         select * from rktrack2.adday where rkmain.ad.ad = rktrack2.adday.ad)
      limit 1");

my $get_next = $dbh->prepare(
   "select * from rkmain.ad use index(PRIMARY)
      where not exists (
         select * from rktrack2.adday where rkmain.ad.ad = rktrack2.adday.ad)
      and ad > ?
      limit 1");

$get_first->execute;
my $row = $get_first->fetchrow_arrayref();
exit(0) unless $row;

# Open the file and print the header to it.
my $file;
if ( $opts{f} ) {
   my $need_hdr = $opts{header} && !-f $opts{f};
   $file = IO::File->new($opts{f}, ">>") or die $OS_ERROR;
   $file->autoflush(1);
   if ( $need_hdr ) {
      print $file escape($get_first->{NAME}), "\n";
   }
}

while ( $row ) {
   if ( $file ) {
      print $file escape($row), "\n";
   }
}

# Formats a row the same way SELECT INTO OUTFILE does by default.  This is
# described in the LOAD DATA INFILE section of the MySQL manual,
# http://dev.mysql.com/doc/refman/5.0/en/load-data.html
sub escape {
   my ($row) = @_;
   return join("\t", map {
      s/([\t\n\\])/\\$1/g if defined $_;  # Escape tabs etc
      defined $_ ? $_ : '\N';             # NULL = \N
   } @$row);
}

# Compares versions like 5.0.27 and 4.1.15-standard-log
sub version_ge {
   my ( $dbh, $target ) = @_;
   my $version = sprintf('%03d%03d%03d', $dbh->{mysql_serverinfo} =~ m/(\d+)/g);
   return $version ge sprintf('%03d%03d%03d', $target =~ m/(\d+)/g);
}

sub get_tbl_struct {
   my ( $dbh, $db, $tbl ) = @_;
   my $ddl = ($dbh->selectrow_array("SHOW CREATE TABLE $db.$tbl"))[1];
   my @defs = $ddl =~ m/^(\s+`.*?),?$/gm;
   my @cols = map { $_ =~ m/`([^`]+)`/g } @defs;
   my @null = map { $_ =~ m/`([^`]+)`/g } grep { $_ !~ m/NOT NULL/ } @defs;
   my %keys =
      map {
         my ($name) = $_ =~ m/(PRIMARY|`[^`]*`)/;
         my ($cols) = $_ =~ m/\((.+)\),?$/;
         $name =~ s/`//g;
         ($name, [ grep { m/[^,]/ } split('`', $cols) ])
      }
      $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm;

   return {
      cols      => \@cols,
      col_hash  => { map { $_ => 1 } @cols },
      null      => \@null,
      null_hash => { map { $_ => 1 } @null },
      keys      => \%keys,
      defs      => \%alldefs,
   };
}

# Parses a DSN in login:pass@host:port/database.table:key format
sub parse_dsn {
   my ($dsn, $prev) = @_;
   return unless $dsn;
   $prev ||= {};

   my ( $user, $pass, $host, $port, $database, $table, $key) = $dsn =~ m{
      (?:
         (.+?)       # Username
         (?::(.+))?  # Optional password
      @)?            # User-pass is optional
      (?:
         (.+?)       # Hostname
         (?::(.+))?  # Optional port
      /)?            # Host-port is optional
      (?:
         (.+?)       # Database
      \.)?           # Database is optional
      ([^:]+)        # Table is required
      (?::
         (.+)        # Key/index
      )?             # Index is optional
      }xsm or return undef;

   return {
      u => $user     || $prev->{u},
      p => $pass     || $prev->{p},
      h => $host     || $prev->{h},
      P => $port     || $prev->{P},
      D => $database || $prev->{D},
      t => $table    || $prev->{t},
      k => $key      || $prev->{k} || 'PRIMARY',
      F => $opts{F},
   };
}

sub get_dbh {
   my ( $info ) = @_;
   my $db_options = {
      AutoCommit => 1, # TODO
      RaiseError => 1,
      PrintError => 1,
   };
   my %conn = ( F => 'mysql_read_default_file', h => 'host', P => 'port', S => 'socket');
   my $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
      . join(';', map  { "$conn{$_}=$info->{$_}" } grep { defined $info->{$_} } qw(F h P S))
      . ';mysql_read_default_group=mysql';
   return DBI->connect($dsn, @{$info}{qw(u p)}, $db_options )
      or die("Can't connect to DB: $OS_ERROR");
}

