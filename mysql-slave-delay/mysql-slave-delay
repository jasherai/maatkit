#!/usr/bin/perl

# This is mysql-slave-delay, a program that makes a slave server lag its master
# by a specified amount.
#
# This program is copyright (c) 2007 Baron Schwartz.  Feedback and improvements
# are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);
use Term::ReadKey;

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", q$Revision$ =~ m/(\d+)/g);

# Define cmdline args
my @opt_spec = (
   { s => 'askpass',       d => 'Prompt for username and password for connections' },
   { s => 'delay|d=s',     d => 'Slave delay (default 1h); suffix: s/m/h/d' },
   { s => 'help',          d => 'Show this help message' },
   { s => 'tolerance|t=s', d => 'Lag tolerance (default 5%); suffix: s/m/h/d/%' },
   { s => 'usemaster|u',   d => 'Get binlog positions from master, not slave' },
   { s => 'verbose|v',     d => 'Verbose output' },
   { s => 'version',       d => 'Output version information and exit' },
);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   d => '1h',
   t => '5%',
);

my %opt_seen;
foreach my $spec (@opt_spec) {
   my ( $long, $short ) = $spec->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{ $spec->{k} } = undef unless defined $opts{ $spec->{k} };
   die "Duplicate option $spec->{k}" if $opt_seen{ $spec->{k} }++;
}

Getopt::Long::Configure( 'no_ignore_case', 'bundling' );
GetOptions( map { $_->{s} => \$opts{ $_->{k} } } @opt_spec )
   or $opts{help} = 1;

if ( $opts{version} ) {
   print "mysql-slave-delay  Ver $VERSION Distrib $DISTRIB Changeset $SVN_REV\n";
   exit(0);
}

my %conn = (
   h => 'host',
   P => 'port',
   S => 'socket',
   u => 'user',
   p => 'pass',
   F => 'mysql_read_default_file',
   D => 'database',
);

my ($slave, $slave_dsn, $master, $master_dsn);
if ( @ARGV ) {
   $slave_dsn  = parse_dsn(shift @ARGV);
   $slave      = get_dbh($slave_dsn);
   $master_dsn = parse_dsn(shift(@ARGV), $slave_dsn) if $slave && @ARGV;
   $master     = get_dbh($master_dsn) if $master_dsn;
}

if ( !$opts{help} ) {
   if ( !$slave ) {
      warn "Missing or invalid slave host\n";
      $opts{help} = 1;
   }

   if ( !$opts{help} ) {
      my ($num, $suf ) = $opts{d} =~ m/(\d+)([smhd])$/;
      if ( !defined $num || $num <= 0 ) {
         warn "Invalid --delay argument\n";
         $opts{help} = 1;
      }
      else {
         $opts{d} = $suf eq 's' ? $num            # Seconds
                  : $suf eq 'm' ? $num * 60       # Minutes
                  : $suf eq 'h' ? $num * 3600     # Hours
                  :               $num * 86400;   # Days
      }
   }

   if ( !$opts{help} ) {
      my ($num, $suf ) = $opts{t} =~ m/(\d+)([smhd%])$/;
      if ( !defined $num || $num <= 0 ) {
         warn "Invalid --tolerance argument\n";
         $opts{help} = 1;
      }
      else {
         $opts{t} = $suf eq 's' ? $num                         # Seconds
                  : $suf eq 'm' ? $num * 60                    # Minutes
                  : $suf eq 'h' ? $num * 3600                  # Hours
                  : $suf eq 'd' ? $num * 86400                 # Days
                  :               int($opts{d} * $num / 100);  # pct of delay
         $opts{t} = max($opts{t}, 1);
      }
   }

}

if ( $opts{help} ) {
   print "Usage: mysql-slave-delay [OPTION]... SLAVE-HOST [MASTER-HOST]\n\n";
   my $maxw = max( map { length( $_->{l} ) + ( $_->{n} ? 4 : 0 ) } @opt_spec );
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}"    : '';
      printf( "  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d} );
   }
   print <<USAGE;

mysql-slave-delay starts and stops a slave server as needed to make it delay
its master a specified amount.  There is a special key=value,key=value syntax
for specifying how to connect to the slave (and optionally the master).  For
more information, please read the documentation:

   perldoc mysql-slave-delay

USAGE
   exit(0);
}

# ############################################################################
# Ready to work now.
# ############################################################################
my ( $TS, $FILE, $POS ) = ( 0, 1, 2 );

my @positions;
my $next_start = 0;
my $now;

while (1) {

   $now = time();

   my $status = $slave->selectrow_hashref("SHOW SLAVE STATUS");

   if ( $opts{u} && !$master ) {
      # Try to connect to the slave's master just by looking at its SLAVE STATUS.
      my $spec = "h=$status->{master_host},P=$status->{master_port}";
      $master  = get_dbh(parse_dsn($spec, $slave_dsn));
   }

   # Get binlog position.
   if ( $master ) {
      my $res = $master->selectrow_hashref("SHOW MASTER STATUS");
      push @positions,
         [ $now, $res->{file}, $res->{position} ];
   }
   else {
      # Use the position on master at which the I/O thread is reading.  If the
      # I/O thread is not far behind, which it usually is not, this is basically
      # the same as the master's File/Position.
      push @positions,
         [ $now, $status->{master_log_file}, $status->{read_master_log_pos} ];
   }

   if ( ( $status->{slave_sql_running} || '' ) eq 'No' ) {
      # Find the most recent binlog position that's older than the delay amount.
      my $pos;
      my $i = 0;
      while ( $i < @positions && $positions[$i]->[$TS] <= $now - $opts{d} ) {
         $pos = $i;
         $i++;
      }

      # Make the slave server delay if possible; otherwise sleep and check
      # again.
      if ( $now >= $next_start && defined $pos ) {
         my $position = $positions[$pos];
         $slave->do(
            "START SLAVE SQL_THREAD UNTIL /*$position->[$TS]*/ "
               . "MASTER_LOG_FILE = '$position->[$FILE]', "
               . "MASTER_LOG_POS = $position->[$POS]"
         );

         print ts($now)
            . " START SLAVE until master "
            . ts($position->[$TS])
            . " $position->[$FILE]/$position->[$POS]\n";

         # Throw away positions we're going to replicate past.
         @positions = @positions[$pos + 1 .. $#positions];
      }
      else {
         my $position = $positions[-1];
         print ts($now)
            . " slave stopped at master position $position->[$FILE]/$position->[$POS]\n";
      }
   }
   elsif ( $status->{seconds_behind_master} < $opts{d} ) {
      my $position = $positions[-1];
      my $behind = $status->{seconds_behind_master};
      $next_start = $now + $opts{d} - $behind;
      print ts($now)
         . " STOP SLAVE until "
         . ts($next_start)
         . " at master position $position->[$FILE]/$position->[$POS]\n";

      $slave->do("STOP SLAVE SQL_THREAD");
   }
   else {
      my $position = $positions[-1];
      my $behind = $status->{seconds_behind_master};
      print ts($now)
         . " slave running $behind seconds behind at"
         . " master position $position->[$FILE]/$position->[$POS]\n";
   }

   sleep($opts{t});
}

# ############################################################################
# Subroutines
# ############################################################################

sub ts {
   my ( $time ) = @_;
   my ( $sec, $min, $hour, $mday, $mon, $year )
      = localtime($time);
   $mon  += 1;
   $year += 1900;
   return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
      $year, $mon, $mday, $hour, $min, $sec);
}

sub parse_dsn {
   my ( $dsn, $prev ) = @_;
   return unless $dsn;
   $prev ||= {};

   my %vals;
   if ( $dsn =~ m/=/ ) {
      my %hash = map {m/^(.)=(.*)$/g} split( /,/, $dsn );
      %vals = map { $_ => $hash{$_} } keys %conn;
   }
   else {
      $vals{h} = $dsn;
   }
   map { $vals{$_} ||= $prev->{$_} || $opts{$_} } keys %conn;
   die "Missing host (h) part in $dsn\n" unless $vals{h};
   return \%vals;
}

sub get_dbh {
   my ( $info, $db ) = @_;

   if ( $opts{askpass} ) {
      print "Enter password for $info->{h}: ";
      ReadMode('noecho');
      my $pass = <STDIN>;
      chomp $pass;
      ReadMode('normal');
      print "\n";
      $info->{p} = $pass;
   }

   my $db_options = {
      RaiseError => 1,
      PrintError => 0,
   };

   $info->{D} ||= '';
   my $dsn = "DBI:mysql:$info->{D};host=$info->{h};"
      . join( ';',
      map     {"$conn{$_}=$info->{$_}"}
         grep { defined $info->{$_} } qw(F h P S) )
      . ';mysql_read_default_group=mysql';
   my $dbh = DBI->connect( $dsn, @{$info}{qw(u p)}, $db_options )
      or die("Can't connect to DB: $OS_ERROR");
   $dbh->{FetchHashKeyName} = 'NAME_lc'; # Lowercases all column names for fetchrow_hashref
   return $dbh;
}
