#!/usr/bin/perl

# This program creates random MySQL tables and fills them with random data.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;

our $VERSION = '@VERSION@';

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my @opt_spec = (
   { s => 'database|D=s', d => 'Database to use' },
   { s => 'host|h=s',     d => 'Connect to host' },
   { s => 'help',         d => 'Show this help message' },
   { s => 'password|p=s', d => 'Password to use when connecting' },
   { s => 'port|P=i',     d => 'Port number to use for connection' },
   { s => 'socket|S=s',   d => 'Socket file to use for connection' },
   { s => 'user|u=s',     d => 'User for login if not current user' },
   { s => 'size|s=i',     d => 'Size of test table, default 500 rows' },
   { s => 'name|n=s',     d => 'Table name (default is test1)' },
   { s => 'dropfirst|d',  d => 'Drop the table before creating it' },
   { s => 'print|r',      d => 'Print SQL' },
);
# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ( s => 500, n => 'test1' );
# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# If a filename or other argument(s) is required after the other arguments,
# add "|| !@ARGV" inside the parens on the next line.
if ( $opts{help} ) {
   print "Usage: $PROGRAM_NAME <options> batch-file\n\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-13s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

$PROGRAM_NAME makes random MySQL tables and fills them with random data.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################
my %conn = ( h => 'host', P => 'port', S => 'socket');

# Connect to the database
my $dsn = 'DBI:mysql:' . ( $opts{D} || '' ) . ';'
   . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(h P S))
   . ';mysql_read_default_group=mysql';
my $dbh = DBI->connect($dsn, @opts{qw(u p)}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

my %types = (
   tinyint => {
      arg => [ -128, 127, 255 ],
      gen => \&rand_int,
   },
   smallint => {
      arg => [ -32768, 32767, 65535 ],
      gen => \&rand_int,
   },
   mediumint => {
      arg => [ -8388608, 8388607, 16777215 ],
      gen => \&rand_int,
   },
   int => {
      arg => [ -2147483648, 2147483647, 4294967295 ],
      gen => \&rand_int,
   },
   bigint => {
      arg => [ -9223372036854775808, 9223372036854775807, 18446744073709551615 ],
      gen => \&rand_int,
   },
   date => {
      arg => '%4d-%02d-%02d',
      gen => \&rand_date,
   },
   datetime => {
      arg => '%4d-%02d-%02d %02d:%02d:%02d',
      gen => \&rand_date,
   },
   timestamp => {
      arg => '%4d-%02d-%02d %02d:%02d:%02d',
      gen => \&rand_date,
   },
);
my @types = keys %types;
my $max_int = 2 ** 32 - 1;

my ( $tbl, $pk, $cols ) = generate_random_table();
$dbh->do("DROP TABLE IF EXISTS `$opts{n}`") if $opts{d};
print "$tbl;\n" if $opts{r};
$dbh->do($tbl);
insert_data($pk, $cols);

sub insert_data {
   my ( $pk, $cols ) = @_;
   my $sql = "INSERT IGNORE INTO `$opts{n}`(" . join(",", map{$_->{name}}@$cols)
      . ") VALUES (" . join(",", map { '?' } @$cols) . ")";
   my $sth = $dbh->prepare($sql);
   foreach my $i ( 0 .. $opts{s} ) {
      my @vals = map{ $types{$_->{type}}->{gen}->($_)  } @$cols;
      $sth->execute(@vals);
   }
}

sub rand_int {
   my ( $spec ) = @_;
   my $range = $types{$spec->{type}}->{arg};
   my $bottom = $spec->{unsigned} ? 0 : $range->[0];
   my $top    = $spec->{unsigned} ? $range->[1] : $range->[2];
   return $bottom + int(rand() * ($top-$bottom));
}

# TODO: need to generate character data too.
# TODO: returns datetimes before 1970, which is no good I think...
sub rand_date {
   my ($spec) = @_;
   my $fmt = $types{$spec->{type}}->{arg};
   my $time = int( rand() * $max_int );
   my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime($time);
   return sprintf( $fmt, $year + 1900, $mon + 1, $mday, $hour, $min, $sec);
}

sub generate_random_table {
   my $num_cols = int(5 + rand() * 20);
   my $pk = 1 + int(rand() * 3);
   my @cols;
   foreach my $i ( 1 .. $num_cols ) {
      my $col = generate_coldef($i, $i <= $pk);
      push @cols, $col;
   }
   my $sql = "CREATE TABLE `$opts{n}` (" . join(",", map { $_->{def} }@cols)
      . ", PRIMARY KEY(" . join(",", map { $_->{name} }@cols[0..$pk-1])
      . "))engine=innodb";
   return ($sql, [ @cols[0..$pk] ], [ @cols ]);
}

sub generate_coldef {
   my ( $i, $is_pk ) = @_;
   my $type;
   do {
      $type = $types[int(rand() * @types)];
   } while ( $is_pk && $type eq 'timestamp' ); # Don't put timestamp in PK
   my $notnull = $is_pk || rand() > .5 ? 'not null' : '';
   return {
      name => "col$i",
      type => $type,
      def => "col$i $type $notnull",
   };
}
