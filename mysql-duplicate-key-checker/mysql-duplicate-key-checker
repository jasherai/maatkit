#!/usr/bin/perl

# This is mysql-duplicate-key-checker, a program to analyze MySQL tables for
# duplicated or redundant indexes and foreign keys.
# 
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);
use Term::ReadLine;

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

my %opt_spec = (
   l => { s => 'help',           d => 'Show this help message' },
   d => { s => 'databases|d=s',  d => 'Only do this comma-separated list of databases' },
   g => { s => 'ignoredb|g=s',   d => 'Ignore this comma-separated list of databases' },
   t => { s => 'tables|t=s',     d => 'Only do this comma-separated list of tables' },
   n => { s => 'ignoretbl|n=s',  d => 'Ignore this comma-separated list of tables' },
   f => { s => 'function|f=s',   d => 'Do f=foreign keys, k=keys.  Default is do both.' },
   h => { s => 'host|h=s',       d => 'Database server hostname' },
   o => { s => 'port|P=i',       d => 'Database server port' },
   p => { s => 'pass|p=s',       d => 'Database password' },
   u => { s => 'user|u=s',       d => 'Database username' },
   v => { s => 'verbose|v',      d => 'Output everything, not just dupes' },
   s => { s => 'allstruct|s',    d => 'Compare indexes with different structs (BTREE, HASH, etc)' },
   b => { s => 'tab|b',          d => 'Output separated with tabs' },
);

# Define the order cmdline opts will appear in help output.  If it's not in
# this list, it's not an option to this program.
my @opt_keys = qw( l d g t n f h o u p v s b );

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   l => 0,
   d => '',
   g => '',
   t => '',
   n => '',
   f => 'fk',
   o => 0,
   p => 0,
   u => '',
   v => 0,
   b => 0,
   s => 1,
);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => \$opts{$_} }  @opt_keys );

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g}) };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n}) };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}

if ( $opts{l} ) {
   print "Usage: $PROGRAM_NAME <options>\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^=]*))?/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME examines MySQL tables for duplicate or redundant indexes and
foreign keys.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# This will end up containing what's needed to connect to MySQL.
my $conn = {
   h  => $opts{h},
   u  => $opts{u},
   p  => $opts{p},
   o  => $opts{o},
};

if ( grep { !$conn->{$_} } keys %$conn ) {
   # Try to use the user's .my.cnf file.
   eval {
      my $homedir = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE};
      open my $conf_file, "<", "$homedir/.my.cnf" or die $OS_ERROR;
      while ( my $line = <$conf_file> ) {
         chomp $line;
         $line =~ s/(^\s*)|(\s*#.*$)//g;
         next unless $line;
         my ( $key, $val ) = split( /\s*=\s*/, $line );
         next unless defined $val;
         if ( $key eq 'host' )     { $conn->{h}  ||= $val; }
         if ( $key eq 'user' )     { $conn->{u}  ||= $val; }
         if ( $key =~ m/^pass/ )   { $conn->{p}  ||= $val; }
         if ( $key eq 'port' )     { $conn->{o}  ||= $val; }
      }
      close $conf_file;
   };
   if ( $EVAL_ERROR && $EVAL_ERROR !~ m/No such file/ ) {
      print "I tried to read your .my.cnf file, but got '$EVAL_ERROR'\n";
   }
}

# Fill in defaults for some things
$conn->{o} ||= 3306;
$conn->{h} ||= 'localhost';
$conn->{u} ||= getlogin() || getpwuid($UID);
$conn->{p} ||= '';

my %prompts = (
   o  => "Port number: ",
   h  => "Database host: ",
   u  => "Database user: ",
   p  => "Database password: ",
);

# If anything remains, prompt the terminal
my $term;
while ( my ( $thing ) = grep { !$conn->{$_} } keys %$conn ) {
   $term ||= Term::ReadLine->new('terminal');
   $conn->{$thing} = $term->readline($prompts{$thing});
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my $dbh = DBI->connect(
   "DBI:mysql:;host=$conn->{h};port=$conn->{o}",
   $conn->{u}, $conn->{p}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $!");

my @databases = @{$dbh->selectcol_arrayref('SHOW DATABASES')};

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^information_schema$/mi
      || exists $opts{g}->{$database};

   my @tables = @{$dbh->selectcol_arrayref('SHOW TABLES FROM ' . $database)};
   next DATABASE unless @tables;

   my %info_for;

   TABLE:
   foreach my $table ( @tables ) {
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || exists $opts{n}->{$table};

      my $ddl = ($dbh->selectrow_array("SHOW CREATE TABLE $database.$table"))[1];
      next TABLE if $ddl =~ m/^CREATE ALGORITHM/;

      my ( $engine ) = $ddl =~ m/\) (?:ENGINE|TYPE)=(\w+)/;
      my $hash = {
         engine   => $engine,
         database => $database,
         table    => $table,
         engine   => $engine,
      };
      $hash->{keys} = $opts{f} =~ m/k/ ? [ find_keys($hash, $ddl) ] : [];
      $hash->{fks}  = $opts{f} =~ m/f/ ? [ find_fks($hash, $ddl) ]  : [];
      if ( @{$hash->{keys}} || @{$hash->{fks}} ) {
         $info_for{$table} = $hash;
      }
   }

   my @to_print;
   foreach my $table ( sort keys %info_for ) {
      my $hash = $info_for{$table};

      # Prepare indexes
      if ( $opts{f} =~ m/k/ ) {
         my @keys = sort { $a->{cols} cmp $b->{cols} } @{$hash->{keys}};
         if ( $opts{v} ) { # Print all
            push @to_print, map { make_hash($database, $table, 'KEY', $_) } @keys;
         }
         else { # Find duplicate/redundant by prefix matching.
            my %seen; # Avoid outputting a key more than once.
            foreach my $i ( 0..$#keys - 1 ) {
               my $pat = quotemeta($keys[$i]->{cols});
               foreach my $j ( $i+1..$#keys ) {
                  if ( ($keys[$i]->{struct} eq $keys[$j]->{struct} || $opts{s})
                     && $keys[$j]->{cols} =~ m/^$pat/ )
                  {
                     push @to_print, make_hash($database, $table, 'KEY', $keys[$i]) if !$seen{$i}++;
                     push @to_print, make_hash($database, $table, 'KEY', $keys[$j]) if !$seen{$j}++;
                  }
               }
            }
         }
      }

      # Prepare foreign keys
      if ( $opts{f} =~ m/f/ ) {
         my @fks = sort { $a->{cols} cmp $b->{cols} } @{$hash->{fks}};
         if ( $opts{v} ) { # Print all
            push @to_print, map { make_hash($database, $table, 'FK', $_) } @fks;
         }
         else { # Otherwise output duplicates.  $i $j avoids backtracking.
            my %seen;
            foreach my $i ( 0..$#fks - 1 ) {
               foreach my $j ( $i+1..$#fks ) {
                  if ( $fks[$i]->{parent} eq $fks[$j]->{parent} && $fks[$i]->{cols} eq $fks[$j]->{cols} ) {
                     push @to_print, make_hash($database, $table, 'FK', $fks[$i]) if !$seen{$i}++;
                     push @to_print, make_hash($database, $table, 'FK', $fks[$j]) if !$seen{$j}++;
                  }
               }
            }
         }
      }
   }

   next DATABASE unless @to_print;

   # Design and print header
   my $hdr;
   if ( $opts{b} ) {
      $hdr = ( "%s\t" x 8 ) . "\n";
   }
   else {
      my $max_idx  = max(5, map { length($_->{name}) } @to_print);
      my $max_tbl  = max(5, map { length($_->{table}) } @to_print);
      my $max_db   = max(8, length($database));
      my $max_par  = max(6, map { length($_->{parent} || '') } @to_print);
      $hdr         = "%-${max_db}s %-${max_tbl}s %-6s %-${max_idx}s %-4s %-8s %-${max_par}s %s\n";
   }

   printf($hdr, qw(DATABASE TABLE ENGINE OBJECT TYPE STRUCT PARENT COLUMNS));
   foreach my $thing ( @to_print ) {
      printf($hdr, @{$thing}{qw(database table engine name type struct parent cols)});
   }

}

# ############################################################################
# Subroutines
# ############################################################################

sub make_hash {
   my ( $database, $table, $type, $hash ) = @_;
   return {
      database => $database,
      table    => $table,
      engine   => $hash->{engine},
      name     => $hash->{name},
      type     => $type,
      struct   => $hash->{struct} || 'NULL',
      parent   => $hash->{parent} || 'NULL',
      cols     => $hash->{cols},
   };
}

# The general format of a key is
# [FOREIGN|UNIQUE|PRIMARY|FULLTEXT|SPATIAL] KEY `name` [USING BTREE|HASH] (`cols`).
sub find_keys {
   my ( $info, $ddl ) = @_;

   # Find and filter the indexes.
   my @indexes = $ddl =~ m/((?:\w+ )?KEY .+\))/mg;
   @indexes = grep { $_ !~ m/FOREIGN/ } @indexes;

   # Make allowances for HASH bugs in SHOW CREATE TABLE
   # (http://bugs.mysql.com/bug.php?id=22632).
   if ( $info->{engine} ne 'MEMORY' ) {
      @indexes = map { $_ =~ s/USING HASH/USING BTREE/; $_; } @indexes;
   }

   my @keys = map {
      my ( $struct, $cols ) = $_ =~ m/(?:USING (\w+))? \((.+)\)/;
      my ( $name ) = $_ =~ m/KEY `(.*?)` \(/;
      $struct ||= 'BTREE';
      {
         engine   => $info->{engine},
         struct   => $struct,
         cols     => $cols,
         name     => $name || 'PRIMARY',
      }
   } @indexes;
   return @keys;
}

sub find_fks {
   my ( $info, $ddl ) = @_;

   my @fks = $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg;

   # A foreign key is a duplicate no matter what order the columns are in, so
   # re-order them alphabetically so they can be compared.
   my @result = map {
      my ( $name ) = $_ =~ m/CONSTRAINT `(.*?)`/;
      my ( $cols ) = $_ =~ m/\(([^\)]+)\)/;
      my ( $parent ) = $_ =~ m/REFERENCES (\S+) /;
      if ( $parent !~ m/\./ ) {
         $parent = "`$info->{database}`.$parent";
      }
      {  name   => $name,
         engine => $info->{engine},
         parent => $parent,
         cols   => join(',', sort(split(/`, `/, $cols))),
      };
   } @fks;
   return @result;
}

# ############################################################################
# Perldoc
# ############################################################################

=pod

=head1 NAME

duplicate-index-checker - Find possible duplicate indexes and foreign keys on
MySQL tables.

=head1 DESCRIPTION

This program examines the output of SHOW CREATE TABLE on all tables in a MySQL
database, and if it finds any index in a table that a) covers all the same
columns as another, or b) covers an exact leftmost prefix of another, it
prints out the suspicious indexes.  It does this just by string matching of
the index definition statements.  It also looks for duplicate foreign keys.

This is a very quickly thrown-together script (though as time goes on, I am
less and less able to claim that).  Please tell me if you find anything it
does wrong.  It may not handle FULLTEXT or R-Tree or other fanciness
correctly.  If you find something it doesn't do right, send me the output of
SHOW CREATE TABLE [tablename] and what you think it ought to do, and I'll see
if I can fix it.

=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI, DBD::mysql, and Term::ReadKey.

=head1 LICENSE

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

Copyright (c) 2006 Baron Schwartz, baron at xaprb dot com.  All rights
reserved, except for those granted under the license.

This program is free software.  You may redistribute it under either the GNU
GPL version 2, or the Perl Artistic License, at your option.  For details on
these licenses, please issue `man perlartistic' or `man perlgpl'.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
