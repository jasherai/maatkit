#!/usr/bin/perl

# This is mysql-duplicate-key-checker, a program to analyze MySQL tables for
# duplicated or redundant indexes and foreign key constraints.
# 
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);
use Term::ReadLine;

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

my %opt_spec = (
   l => { s => 'help',           d => 'Show this help message' },
   d => { s => 'databases|d=s',  d => 'Only do this comma-separated list of databases' },
   g => { s => 'ignoredb|g=s',   d => 'Ignore this comma-separated list of databases' },
   t => { s => 'tables|t=s',     d => 'Only do this comma-separated list of tables' },
   n => { s => 'ignoretbl|n=s',  d => 'Ignore this comma-separated list of tables' },
   f => { s => 'function|f=s',   d => 'Do f=foreign keys, k=keys.  Default is do both.' },
   h => { s => 'host|h=s',       d => 'Database server hostname' },
   o => { s => 'port|P=i',       d => 'Database server port' },
   p => { s => 'pass|p=s',       d => 'Database password' },
   u => { s => 'user|u=s',       d => 'Database username' },
   v => { s => 'verbose|v',      d => 'Output everything, not just dupes' },
   a => { s => 'allstruct|a',    d => 'Compare indexes with different structs (BTREE, HASH, etc)' },
   b => { s => 'tab|b',          d => 'Output separated with tabs' },
   s => { s => 'allatonce|s',    d => 'Print only once, instead of one DB at a time' },
);

# Define the order cmdline opts will appear in help output.  If it's not in
# this list, it's not an option to this program.
my @opt_keys = qw( l d g t n f h o u p v a b s );

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   l => 0,
   d => '',
   g => '',
   t => '',
   n => '',
   f => 'fk',
   o => 3306,
   p => undef,
   u => undef,
   v => 0,
   b => 0,
   a => 0,
   s => 0,
);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => \$opts{$_} }  @opt_keys );

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g}) };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n}) };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}

if ( $opts{l} ) {
   print "Usage: $PROGRAM_NAME <options>\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME examines MySQL tables for duplicate or redundant indexes and
foreign keys.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# This will end up containing what's needed to connect to MySQL.
my $conn = {
   h  => $opts{h},
   u  => $opts{u},
   p  => $opts{p},
   o  => $opts{o},
};

if ( grep { !$conn->{$_} } keys %$conn ) {
   # Try to use the user's .my.cnf file.
   eval {
      my $homedir = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE};
      open my $conf_file, "<", "$homedir/.my.cnf" or die $OS_ERROR;
      while ( my $line = <$conf_file> ) {
         chomp $line;
         $line =~ s/(^\s*)|(\s*#.*$)//g;
         next unless $line;
         my ( $key, $val ) = split( /\s*=\s*/, $line );
         next unless defined $val;
         if ( $key eq 'host' )     { $conn->{h}  ||= $val; }
         if ( $key eq 'user' )     { $conn->{u}  ||= $val; }
         if ( $key =~ m/^pass/ )   { $conn->{p}  ||= $val; }
         if ( $key eq 'port' )     { $conn->{o}  ||= $val; }
      }
      close $conf_file;
   };
   if ( $EVAL_ERROR && $EVAL_ERROR !~ m/No such file/ ) {
      print "I tried to read your .my.cnf file, but got '$EVAL_ERROR'\n";
   }
}

# Fill in defaults for some things
$conn->{h} ||= 'localhost';
$conn->{u} ||= getlogin() || getpwuid($UID);

my %prompts = (
   o  => "Port number: ",
   h  => "Database host: ",
   u  => "Database user: ",
   p  => "Database password: ",
);

# If anything remains, prompt the terminal
my $term;
foreach my $thing ( grep { !defined $conn->{$_} } keys %$conn ) {
   $term ||= Term::ReadLine->new('terminal');
   $conn->{$thing} = $term->readline($prompts{$thing});
}

# ############################################################################
# Get ready to do the main work.
# ############################################################################

# Connect to the database
my $dbh = DBI->connect(
   "DBI:mysql:;host=$conn->{h};port=$conn->{o}",
   $conn->{u}, $conn->{p}, { AutoCommit => 1, RaiseError => 1, PrintError => 1 } )
   or die("Can't connect to DB: $OS_ERROR");

my @databases = @{$dbh->selectcol_arrayref('SHOW DATABASES')};
my @whole_batch;

DATABASE:
foreach my $database ( @databases ) {

   # Ignore databases as instructed.  Also ignore INFORMATION_SCHEMA and skip
   # databases caused by lost+found directories created in the root of ext3
   # filesystems; they are not really databases.
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^(information_schema|lost\+found)$/mi
      || exists $opts{g}->{$database};

   my @tables = @{$dbh->selectcol_arrayref('SHOW TABLES FROM `' . $database .  '`')};
   next DATABASE unless @tables;

   my %info_for;

   TABLE:
   foreach my $table ( @tables ) {
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || exists $opts{n}->{$table};

      my $ddl = ($dbh->selectrow_array("SHOW CREATE TABLE `$database`.`$table`"))[1];
      next TABLE if $ddl =~ m/^CREATE ALGORITHM/;

      my ( $engine ) = $ddl =~ m/\) (?:ENGINE|TYPE)=(\w+)/;
      my $hash = {
         engine   => $engine,
         database => $database,
         table    => $table,
         engine   => $engine,
      };
      $hash->{keys} = $opts{f} =~ m/k/ ? [ find_keys($hash, $ddl) ] : [];
      $hash->{fks}  = $opts{f} =~ m/f/ ? [ find_fks($hash, $ddl) ]  : [];
      if ( @{$hash->{keys}} || @{$hash->{fks}} ) {
         $info_for{$table} = $hash;
      }
   }

   my @to_print;
   foreach my $table ( sort keys %info_for ) {
      my $hash = $info_for{$table};

      # Prepare indexes
      if ( $opts{f} =~ m/k/ ) {
         my @keys = sort { $a->{cols} cmp $b->{cols} } @{$hash->{keys}};
         if ( $opts{v} ) { # Print all
            push @to_print, map { make_hash($database, $table, 'KEY', $_) } @keys;
         }
         else { # Find duplicate/redundant by prefix matching.
            my %seen; # Avoid outputting a key more than once.
            foreach my $i ( 0..$#keys - 1 ) {
               my $pat = quotemeta($keys[$i]->{cols});
               foreach my $j ( $i+1..$#keys ) {
                  if ( (($keys[$i]->{struct} eq $keys[$j]->{struct}) || $opts{a})
                     && $keys[$j]->{cols} =~ m/^$pat/ )
                  {
                     push @to_print, make_hash($database, $table, 'KEY', $keys[$i]) if !$seen{$i}++;
                     push @to_print, make_hash($database, $table, 'KEY', $keys[$j]) if !$seen{$j}++;
                  }
               }
            }
         }
      }

      # Prepare foreign keys
      if ( $opts{f} =~ m/f/ ) {
         my @fks = sort { $a->{cols} cmp $b->{cols} } @{$hash->{fks}};
         if ( $opts{v} ) { # Print all
            push @to_print, map { make_hash($database, $table, 'FK', $_) } @fks;
         }
         else { # Otherwise output duplicates.  $i $j avoids backtracking.
            my %seen;
            foreach my $i ( 0..$#fks - 1 ) {
               foreach my $j ( $i+1..$#fks ) {
                  if ( $fks[$i]->{parent} eq $fks[$j]->{parent} && $fks[$i]->{cols} eq $fks[$j]->{cols} ) {
                     push @to_print, make_hash($database, $table, 'FK', $fks[$i]) if !$seen{$i}++;
                     push @to_print, make_hash($database, $table, 'FK', $fks[$j]) if !$seen{$j}++;
                  }
               }
            }
         }
      }
   }

   next DATABASE unless @to_print;

   if ( $opts{s} ) {
      push @whole_batch, @to_print;
   }
   else {
      print_batch(@to_print);
   }
}

if ( @whole_batch && $opts{s} ) {
   print_batch(@whole_batch);
}

# ############################################################################
# Subroutines
# ############################################################################

sub print_batch {
   my ( @batch ) = @_;

   my $hdr;
   if ( $opts{b} ) {
      $hdr = ( "%s\t" x 8 ) . "\n";
   }
   else {
      my $max_idx  = max(5, map { length($_->{name}) } @batch);
      my $max_tbl  = max(5, map { length($_->{table}) } @batch);
      my $max_db   = max(8, map { length($_->{database}) } @batch);
      my $max_par  = max(6, map { length($_->{parent} || '') } @batch);
      $hdr         = "%-${max_db}s %-${max_tbl}s %-6s %-${max_idx}s %-4s %-8s %-${max_par}s %s\n";
   }

   printf($hdr, qw(DATABASE TABLE ENGINE OBJECT TYPE STRUCT PARENT COLUMNS));
   foreach my $thing ( @batch ) {
      printf($hdr, @{$thing}{qw(database table engine name type struct parent cols)});
   }

}

sub make_hash {
   my ( $database, $table, $type, $hash ) = @_;
   return {
      database => $database,
      table    => $table,
      engine   => $hash->{engine},
      name     => $hash->{name},
      type     => $type,
      struct   => $hash->{struct} || 'NULL',
      parent   => $hash->{parent} || 'NULL',
      cols     => $hash->{cols},
   };
}

# The general format of a key is
# [FOREIGN|UNIQUE|PRIMARY|FULLTEXT|SPATIAL] KEY `name` [USING BTREE|HASH] (`cols`).
sub find_keys {
   my ( $info, $ddl ) = @_;

   # Find and filter the indexes.
   my @indexes = $ddl =~ m/((?:\w+ )?KEY .+\))/mg;
   @indexes = grep { $_ !~ m/FOREIGN/ } @indexes;

   # Make allowances for HASH bugs in SHOW CREATE TABLE
   # (http://bugs.mysql.com/bug.php?id=22632).
   if ( $info->{engine} !~ m/MEMORY|HEAP/ ) {
      @indexes = map { $_ =~ s/USING HASH/USING BTREE/; $_; } @indexes;
   }

   my @keys = map {
      my ( $struct, $cols ) = $_ =~ m/(?:USING (\w+))? \((.+)\)/;
      my ( $special ) = $_ =~ m/(FULLTEXT|SPATIAL)/;
      $struct = $struct || $special || 'BTREE';
      if ( $info->{engine} =~ m/HEAP|MEMORY/i ) {
         $struct = 'HASH';
      }
      my ( $name ) = $_ =~ m/KEY `(.*?)` \(/;
      {
         engine   => $info->{engine},
         struct   => $struct,
         cols     => $cols,
         name     => $name || 'PRIMARY',
      }
   } @indexes;
   return @keys;
}

sub find_fks {
   my ( $info, $ddl ) = @_;

   my @fks = $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg;

   # A foreign key is a duplicate no matter what order the columns are in, so
   # re-order them alphabetically so they can be compared.
   my @result = map {
      my ( $name ) = $_ =~ m/CONSTRAINT `(.*?)`/;
      my ( $cols ) = $_ =~ m/\(([^\)]+)\)/;
      my ( $parent ) = $_ =~ m/REFERENCES (\S+) /;
      if ( $parent !~ m/\./ ) {
         $parent = "`$info->{database}`.$parent";
      }
      {  name   => $name,
         engine => $info->{engine},
         parent => $parent,
         cols   => join(',', sort(split(/`, `/, $cols))),
      };
   } @fks;
   return @result;
}

# ############################################################################
# Documentation
# ############################################################################

=pod

=head1 NAME

mysql-duplicate-index-checker - Find possible duplicate indexes and foreign keys on
MySQL tables.

=head1 DESCRIPTION

This program examines the output of SHOW CREATE TABLE on MySQL tables, and if
it finds indexes that a) cover the same columns as another index in the same
order, or b) cover an exact leftmost prefix of another index, it prints out
the suspicious indexes.  By default, indexes must be of the same type, so a
BTREE index is not a duplicate of a FULLTEXT index, even if they have the same
colums.  You can override this.

It also looks for duplicate foreign keys.  A duplicate foreign key covers the
same columns as another in the same table, and references the same parent
table.

If possible, it will read your .my.cnf file so you don't have to specify
username and password.

By default it scans every table in every database, and prints out every
duplicated index and foreign key.  You can specify only to check foreign keys
or indexes.  You can also tell it to check only certain databases and tables,
ignore databases and tables, and so on.

You can specify to print out every index and/or foreign key without checking
for duplicates.  This is an easy way to get a full listing, and it's pretty
fast, since SHOW CREATE TABLE is very quick.

=head1 OUTPUT

Output is to STDOUT, one line per server and table, with header lines for each
database.  I tried to make the output easy to process with awk.  For this reason
columns are always present.  If there's no value, the script prints 'NULL'.

The default is column-aligned output for human readability, but you can change
it to tab-separated.  Output is sorted by database and table.

The columns in the output are as follows.

=over

=item DATABASE

The database the table is in.

=item TABLE

The table name.

=item ENGINE

The table's storage engine.

=item OBJECT

The index or constraint's name, e.g. `tbl_ibfk_3` (the default InnoDB name for
the third foreign key on a table named tbl).

=item TYPE

'KEY' for indexes, 'FK' for foreign keys.

=item STRUCT

The type of index: BTREE, FULLTEXT, HASH etc.  By default MySQL's indexes are
BTREE in most cases.  This does not apply to foreign keys.

=item PARENT

The parent table to which the foreign key constraint refers.  This does not
apply to indexes.

=item COLUMNS

The columns included in the index or foreign key constraint.  For indexes,
this column list is output verbatim, as shown in SHOW CREATE TABLE.  For
foreign keys, the columns are ordered so string comparison can find
duplicates, since column order in a foreign key is immaterial.

=back
=head1 SYSTEM REQUIREMENTS

You need the following Perl modules: DBI, DBD::mysql, and Term::ReadKey.

=head1 LICENSE

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
