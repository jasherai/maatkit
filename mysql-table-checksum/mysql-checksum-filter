#!/usr/bin/perl

# This program sorts and filters table checksums output by mysql-table-checksum,
# and only shows you ones that have problems.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use English qw(-no_match_vars);
use Getopt::Long;

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# TODO: --allatonce option or similar (see duplicate-key-checker)

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my @opt_spec = (
   { s => 'header|h',   d => 'Keep the headers' },
   { s => 'help',       d => 'Show this help message' },
   { s => 'master|m=s', d => 'Name of the master server' },
   { s => 'verbose|v',  d => 'Output lines that have no differences' },
);
# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ( m => '' );
# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

if ( $opts{help} ) {
   print "Usage: $PROGRAM_NAME <options> FILE\n\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-13s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

$PROGRAM_NAME filters checksums so you only see ones that differ.  If you pass
files on the command line it analyzes them; otherwise it reads from standard
input.

For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}
# TODO: standard gnu language about when no file, or file is -, read stdin...

# ############################################################################
# Ready to work now.
# ############################################################################

my $exit_status = 0;
my $one_file    = @ARGV < 2;

my $DATABASE = 0;
my $TABLE    = 1;
my $HOST     = 2;
my $ENGINE   = 3;
my $COUNT    = 4;
my $CRC      = 5;
my $TIME     = 6;
my $WAIT     = 7;
my $STAT     = 8;
my $LAG      = 9;
my $ORIG     = 10;

my %lines_for;    # All lines from all files, if > 1 file on cmdline
my $last_tbl;     # db.tbl of last line read
my $current_set = [];    # working set of lines to process

LINE:
while ( my $line = <> ) {    # Magically reads STDIN or files in @ARGV
   chomp $line;
   next unless $line;

   if ( $one_file && $line =~ m/^DATABASE/ && $opts{h} ) {
      print $line, "\n";
      next LINE;
   }

   my @cols = $line =~ m/(\S+)/g;
   next unless @cols == 10;
   push @cols, $line;
   my $tbl = $cols[$DATABASE] . '.' . $cols[$TABLE];

   if ($one_file) { # Process immediately.
      if ( $last_tbl && $last_tbl ne $tbl ) {
         process_set($current_set);
         $current_set = [ \@cols ];
      }
      else {
         push @$current_set, \@cols;
      }
   }
   else { # Stash into %lines_for and process later.
      $lines_for{$tbl} ||= [];
      push @{ $lines_for{$tbl} }, \@cols;
   }
   $last_tbl = $tbl;
}

if ($one_file) {
   process_set($current_set);
}
else {
   foreach my $set ( values %lines_for ) {
      process_set($set);
   }
}

sub process_set {
   my ($set) = @_;
   return unless @$set;

   # Sort the "master" to the front, all others in aphabetical order
   @$set = sort {
           $a->[$HOST] eq $opts{m} ? -1
         : $b->[$HOST] eq $opts{m} ? 1
         : $a->[$HOST] cmp $b->[$HOST]
   } @$set;

   # If the verbose flag is set, or if anything differs, print it
   my $first = $set->[0];

   my $print = $opts{v} || grep {
            $_->[$CRC]   ne $first->[$CRC]
         || $_->[$COUNT] ne $first->[$COUNT]
   } @{$set}[ 1 .. ( scalar(@$set) - 1 ) ];

   if ($print) {
      foreach my $line (@$set) {
         print $line->[$ORIG], "\n";
      }
   }
}

exit $exit_status;

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-checksum-filter - Filter checksums from mysql-table-checksum

=head1 OVERVIEW

This script takes the unsorted, verbose output from mysql-table-checksum and
sorts it, then filters it so you only see tables that have different checksums.

You can pipe input directly into it from mysql-table-checksum, or you can save
the output from that script and run this script on the resulting file(s).  If
you run it against just one file, or pipe output directly into it, it'll output
results during processing.  Processing multiple files is slightly more
expensive, and you won't see any output until they're all read.

Of course, you could also process multiple files like this:

 cat file1 file2 file3 | sort -u | mysql-checksum-filter

but that still doesn't output anything until all files are read.

If you give the -m argument, the script will sort lines for that host first, so
you can see the checksum values on the master server before the slave.

If you give the -v argument, the script will always output all lines (but not
header lines).  You might want to do this in combination with -m.

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
