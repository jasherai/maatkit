#!/usr/bin/perl

# TODO:
# Is it possible to XOR rows so the result is order-independent?
# Add a --paranoid flag that'll checksum each column separately
# Allow using GROUP_CONCAT
# Allow to specify separator
# Allow to use different user/pass on diffeerent servers
# TODO: warn if the MySQL server versions don't match.  Figure out in what
# version concat_ws changed behavior.  (It was MySQL 4.0.14, and it skips empty
# strings, so
# CONCAT_WS(',', 'a', '')
# will produce either 'a,' or just 'a'
# TODO: CRC32 can be used for checksums.

# This program checksums MySQL tables on one or more servers.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my @opt_spec = (
   { s => 'databases|d=s',  d => 'Only do this comma-separated list of databases' },
   { s => 'engine|e=s',     d => 'Only do this comma-separated list of storage engines' },
   { s => 'function|f=s',   d => 'CRC function (SHA1, MD5...) overrides --nocrc' },
   { s => 'help',           d => 'Show this help message' },
   { s => 'ignoredb|g=s',   d => 'Ignore this comma-separated list of databases' },
   { s => 'ignoretbl|n=s',  d => 'Ignore this comma-separated list of tables' },
   { s => 'lock|k',         d => 'Lock table on master until done on slaves (implies -l)' },
   { s => 'count|r!',       d => 'Do the count (default)' },
   { s => 'crc|c!',         d => 'Do the CRC (default)' },
   { s => 'password|p=s',   d => 'Password to use when connecting' },
   { s => 'port|P=i',       d => 'Port number to use for connection' },
   { s => 'slavelag|l',     d => 'Report how far slaves lag master' },
   { s => 'socket|S=s',     d => 'Socket file to use for connection' },
   { s => 'tab|b',          d => 'Output separated with tabs' },
   { s => 'tables|t=s',     d => 'Only do this comma-separated list of tables' },
   { s => 'user|u=s',       d => 'User for login if not current user' },
   { s => 'wait|w=i',       d => 'How long to do MASTER_POS_WAIT on slaves (implies -kl)' },
   { s => 'where|W=s',      d => 'Only do rows matching this WHERE clause (implies -f SHA1)' },
);
# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = ( W => '', r => 1, c => 1 );
# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# Apply dependencies between arguments.
$opts{k} ||= defined $opts{w};
$opts{l} ||= $opts{k};
$opts{f} ||= $opts{s} ? 'SHA1' : '';

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g} || '') };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n} || '') };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}

# Create a WHERE clause
$opts{W} = $opts{W} ? " WHERE $opts{W}" : '';

if ( $opts{help} || !@ARGV ) {
   print "Usage: $PROGRAM_NAME -u <user> -p <pass> [OPTION]... MASTER [SLAVE...]\n\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-13s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

$PROGRAM_NAME checksums MySQL tables.  If you specify multiple servers, the
first server is treated as the master, and the rest as slaves of it, for
purposes of locking and doing MASTER_POS_WAIT.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Ready to work now.
# ############################################################################

my $exit_status = 0;
my @hosts = unique(@ARGV);

my $db_options = {
   RaiseError => 1,
   PrintError => 1,
   AutoCommit => $opts{k} ? 0 : 1,
};

my $main_dbh  = get_dbh($hosts[0], ($opts{d} ? keys %{$opts{d}} : '' ));
$main_dbh->{InactiveDestroy} = 1; # Can't be set in $db_options
my @databases = @{$main_dbh->selectcol_arrayref('SHOW DATABASES')};

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^(information_schema|lost\+found)$/mi
      || exists $opts{g}->{$database};

   my @tables = @{$main_dbh->selectcol_arrayref("SHOW TABLES FROM `$database`")};
   next DATABASE unless @tables;

   my %info_for;
   TABLE:
   foreach my $table ( @tables ) {
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || exists $opts{n}->{$table};

      # Get the table type, and a query to generate a checksum for it.
      my ( $engine, $query ) = checksum_query( $main_dbh, $database, $table );

      # Skip views, and tables of the wrong engine.
      next TABLE if
         $engine eq 'VIEW'
         || ( $opts{e} && !exists $opts{e}->{lc($engine)});
      $info_for{$table} = {
         database => $database,
         table    => $table,
         engine   => $engine,
         query    => $query,
      };
   }

   next DATABASE unless %info_for;

   # Design and print header
   my $hdr;
   if ( $opts{b} ) {
      $hdr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n";
   }
   else {
      my $crc_wid  = lc($opts{f}) eq 'md5' ? 32 : 40;
      my $max_tbl  = max(5, map { length($_) } keys %info_for);
      my $max_db   = max(8, length($database));
      my $max_host = max(4, map { length($_) } @hosts);
      $hdr         = "%-${max_db}s %-${max_tbl}s %-${max_host}s %-6s %10s %${crc_wid}s %4s %4s %4s %4s\n";
   }
   my @hdr_args = qw(DATABASE TABLE HOST ENGINE COUNT CHECKSUM TIME WAIT STAT LAG);
   printf($hdr, @hdr_args);

   TABLE:
   foreach my $table ( sort keys %info_for ) {

      # Lock table and get master position on the master, if applicable.
      $main_dbh->do("LOCK TABLES `$database`.`$table` READ") if $opts{k};
      if ( defined $opts{w} ) {
         my $master_status = $main_dbh->selectrow_hashref('SHOW MASTER STATUS');
         @{$info_for{$table}}{keys %$master_status} = values %$master_status;
      }

      my %children;
      foreach my $host ( @hosts ) {
         my $pid = fork();
         if ( defined($pid) && $pid == 0 ) { # I am a child
            eval {
               do_tbl($host, $info_for{$table}, $host eq $hosts[0], $hdr);
            };
            if ( $EVAL_ERROR ) {
               print STDERR $EVAL_ERROR, "\n";
               exit(1);
            }
            exit(0);
         }
         elsif ( !defined($pid) ) {
            die("Unable to fork!");
         }
         # I already exited if I'm a child, so I'm the parent.
         $children{$host} = $pid;
      }

      # Wait for the children to exit.
      foreach my $host ( keys %children ) {
         my $pid = waitpid($children{$host}, 0);
         $exit_status = $CHILD_ERROR;
      }
      $main_dbh->do("UNLOCK TABLES") if $opts{k};
   }
}

sub do_tbl {
   my ( $host, $info, $is_master, $hdr ) = @_;
   my $dbh = get_dbh($host, $info->{database});
   my $cnt = 'NULL';
   my $crc = 'NULL';
   my $sta = 'NULL';
   my $lag = 'NULL';
   my $beg = time();
   if ( !$is_master && defined $opts{w} ) {
      $sta = $dbh->selectall_arrayref(
         "SELECT /*$info->{database}.$info->{table}*/ MASTER_POS_WAIT('$info->{File}', $info->{Position}, $opts{w})")->[0]->[0];
      $sta = 'NULL' unless defined $sta;
   }
   if ( !$is_master && $opts{l} ) {
      my $res = $dbh->selectrow_hashref("SHOW SLAVE STATUS");
      $lag = $res && defined $res->{Seconds_Behind_Master}
           ? $res->{Seconds_Behind_Master}
           : 'NULL';
   }
   my $mid = time();
   if ( $info->{engine} eq 'MyISAM' && !$opts{f}  ) {
      if ( $opts{c} ) {
         $crc = $dbh->selectall_arrayref("CHECKSUM TABLE `$info->{database}`.`$info->{table}`",
            { Slice => {} })->[0]->{Checksum};
      }
      if ( $opts{r} ) {
         $cnt = do_count($dbh, $info);
      }
   }
   else {
      if ( !$opts{f} && !$opts{c} ) {
         $cnt = do_count($dbh, $info);
      }
      else {
         ( $cnt, $crc ) = do_var_crc($dbh, $info->{query});
         $crc ||= 'NULL';
      }
   }
   my $end = time();
   $dbh->disconnect();
   printf($hdr, $info->{database}, $info->{table}, $host, $info->{engine}, $cnt, $crc,
      $end - $mid, $mid - $beg, $sta, $lag);
}

sub checksum_query {
   my ( $dbh, $db, $tbl ) = @_;
   my $ddl = ($dbh->selectrow_array("SHOW CREATE TABLE `$db`.`$tbl`"))[1];
   return ( 'VIEW', '' ) if $ddl =~ m/^CREATE ALGORITHM/;

   my ( $type ) = $ddl =~ m/^\) (?:ENGINE|TYPE)=(\S+)/m;

   # Make a list of all columns.
   my @defs  = $ddl =~ m/^(\s+`.*)$/gm;
   my @cols  = map { $_ =~ m/(`[^`]+`)/g } @defs;
   my $cols  = join(', ', @cols);

   # To handle nulls, make a bitmap of nullable columns that are null.
   my @nulls = map { $_ =~ m/(`[^`]+`)/g } grep { $_ !~ m/NOT NULL/ } @defs;
   my $nulls = @nulls
             ? (", CONCAT(" . join(', ', map { "ISNULL($_)" } @nulls) .  ")")
             : '';

   # Apply WHERE and find whether there's a PK (for order-by in InnoDB).
   my $index = $ddl =~ m/PRIMARY KEY\s*\((.*?)\)/ ? ' USE INDEX(PRIMARY)' : '';

   # Make the query.
   my $func = $opts{f} || 'SHA1';
   my $query = "SELECT /*$db.$tbl*/ MIN(LEAST(0, "
      . "LENGTH(\@crc := $func(CONCAT_WS('#', \@crc, $func(CONCAT_WS('#', $cols$nulls))))), "
      . "\@cnt := \@cnt + 1)) AS len FROM `$db`.`$tbl`$index$opts{W}";

   return ( $type, $query );
}

exit $exit_status;

# ############################################################################
# Subroutines
# ############################################################################

sub get_dbh {
   my ( $host, $db ) = @_;
   my %conn = ( h => 'host', P => 'port', S => 'socket');

   $db ||= '';
   my $dsn = "DBI:mysql:$db;host=$host"
      . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(h P S))
      . ';mysql_read_default_group=mysql';
   return DBI->connect($dsn, @opts{qw(u p)}, $db_options )
      or die("Can't connect to DB: $OS_ERROR");
}

sub do_var_crc {
   my ( $dbh, $query ) = @_;
   $dbh->do('set @crc := "", @cnt := 0');
   $dbh->do($query);
   return @{$dbh->selectall_arrayref('select @cnt, @crc')->[0]};
}

sub do_count {
   my ( $dbh, $info ) = @_;
   return $dbh->selectall_arrayref(
      "SELECT COUNT(*) FROM `$info->{database}`.`$info->{table}`$opts{W}"
   )->[0]->[0];
}

sub unique {
   my %seen;
   grep { !$seen{$_}++ } @_;
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-table-checksum - Print checksums for MySQL tables on one or many servers.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

The checksums work for me on MySQL version 4.1.20-log and various MySQL 5.0.x
versions.

=head1 OVERVIEW

This script generates table checksums for MySQL tables, typically useful for
verifying your slaves are in sync with the master.  The checksums are generated
by a query on the server, and there is virtually no network traffic as a result.

Invoke the script with options and server names on the command line.  If you
specify more than one server, the script assumes the first server is the master
and others are slaves.  It iterates through the databases and tables, and for
each table generates a checksum for each server, in the order you specified them
on the command line.  For speed it does these in parallel, forking off a child
process for each table.  Duplicate server names are ignored, but if you want to
checksum a server against itself you can use two different forms of the hostname
(for example, localhost and 127.0.0.1).

There are several options to help you get a more consistent read as
unobtrusively as possible.  The most basic thing the script can do is lock the
table on the master until the checksum on the slave is finished, preventing
replication changes from affecting the data in the table.  This is one table at
a time; it does not lock all tables at once.  Also, the checksums are on the
in-memory copy of the table, so there is no need to flush them to disk.  If your
slaves are keeping up with the master, this is probably a fine way to do things.
You can tell the script to print how far behind the slave is to help you see
this.

If the slaves aren't keeping up, you can tell the checksum to wait on the slave
until it has reached the position in the master's binlog where the table was
locked.  The wait parameter is a timeout value, so if it times out, it'll go
ahead with the checksum even if the slave hasn't caught up to that position.
Check the STAT column to see.

Checksums use SHA1 by default on non-MyISAM tables, and the built-in table
checksum on MyISAM tables, but you can specify a CRC function to use too.  Good
options include SHA1 and MD5.  This function is run in SQL, not in Perl, so the
function must be built in to MySQL.

You can skip the row count or the checksum if you want.  The non-MyISAM checksum
technique automatically counts rows as it does the checksum, so skipping the
count on InnoDB doesn't save you any overhead, if you're worried about that.
COUNT(*) is not used unless you skip the checksum.

You can constrain the checksum to only do some databases or tables and ignore
some databases or tables.  You can tell it to only do tables with some storage
engines.  The script only examines table structure on the master, so if the
storage engine or table structure differs on the slave, it won't notice.  The
script ignores views.

You can further restrict the checksum to only a part of a table with the --where
option, similar the the -w option to mysqldump.  The argument to this option
should be quoted and should not contain the word WHERE.  For example, specifying
"--where 'foo=bar'" on the command line will result in the checksum being run
with "WHERE foo=bar".  If you specify this option for a table that doesn't have
a foo column, the query will cause an error.

=head1 HOW TO GET A CONSISTENT CHECKSUM ACROSS REPLICATED SERVERS

If you are using this tool to verify your slaves still have the same data as the
master, which is why I wrote it, you should read this section.

The script is designed so you can get a consistent checksum on the master and
slaves.  The first feature to do this is knowing which server is the master.
It's the first server you specify on the command line.

If your servers are inactive, you might be able to just run the tool with no
further ado.  This is unlikely, so you probably need to take a checksum on the
master, then ensure the slave is caught up and no changes propagate to the
slave(s) before taking the checksum there.

There are several ways to do this, depending on your setup and how much overhead
you can tolerate.  The lowest-impact way to do it is simply hope the slave is
caught up to the master.  You can tell the script to report slave lag in one of
the columns so you can see if there's much lag, then just run the tool as usual.
If you see tables that are different and the slave is behind the master, it
might just be a false positive.  You can dig deeper on the tables that are
troublesome, perhaps with one of the more intrusive methods I'm about to
explain.

The next most disruptive technique is to lock the table on the master, then take
checksums.  This should prevent changes from propagating to the slaves.  You can
just lock on the master (with -k), or you can both lock on the master and wait
on the slaves till they reach that point in the master's binlog (-w).  Which is
better depends on your workload; only you know that.

If you decide to make the checksums on the slaves wait until they're guaranteed
to be caught up to the master, the algorithm looks like this:

 For each table,
   Master: lock table
   Master: get pos
   In parallel,
     Master: checksum
     Slave(s): wait for pos, then checksum
   End
   Master: unlock table
 End 

Another option, which is useful in certain cases, is to checksum only some of
the rows.  If you know your data is being appended to the table and old data
isn't changing, you could checksum up until a few hours ago (for example) and
not worry about any data newer than that.  To do this effectively, you need some
way to know which rows are "old," such as a timestamp column.  You should also
have an index on that column.  Then you can use the --where option to limit the
rows that are checksummed.

If you need a different algorithm and this program doesn't support it, please
get in touch with me and let's see how we can add it.

=head1 OUTPUT

Output is to STDOUT, one line per server and table, with header lines for each
database.  I tried to make the output easy to process with awk.  For this reason
columns are always present.  If there's no value, the script prints 'NULL'.

The default is column-aligned output for human readability, but you can change
it to tab-separated if you want.

Output is unsorted, though all lines about one table should be output together.
For speed, all checksums are done in parallel (as much as possible) and may
complete out of the order in which they were started.  You might want to run
them through another script or command-line utility to make sure they are in the
order you want.  If you pipe the output through mysql-checksum-filter, you can
avoid seeing output about tables that are the same.

The columns in the output are as follows.  The database and table come first so
you can sort by them easily.

=over

=item DATABASE

The database the table is in.

=item TABLE

The table name.

=item HOST

The server's hostname.

=item ENGINE

The table's storage engine.

=item COUNT

The table's row count, unless you specified to skip it.

=item CHECKSUM

The table's checksum, unless you specifed to skip it or the table has no rows.
MyISAM checksums will be 0 if there are no rows; other styles will print NULL.

=item TIME

The time the actual checksum and/or counting took.

=item WAIT

How long the checksum blocked before beginning.

=item STAT

The return value of MASTER_POS_WAIT().

=item LAG

How far the slave lags the master, as reported by SHOW SLAVE STATUS.

=back

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
