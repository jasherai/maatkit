#!/usr/bin/perl

# This program efficiently checksums MySQL tables on one or more servers.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(min max);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# TODO:
# Is it possible to XOR rows so the result is order-independent?
# Add a --paranoid flag that'll checksum each column separately
# Allow using GROUP_CONCAT
# Allow to specify separator
# Allow to use different user/pass on diffeerent servers

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my @opt_spec = (
   { s => 'algorithm|a=s',  d => 'Checksum algorithm (default: BIT_XOR)' },
   { s => 'databases|d=s',  d => 'Only do this comma-separated list of databases' },
   { s => 'engine|e=s',     d => 'Only do this comma-separated list of storage engines' },
   { s => 'function|f=s',   d => 'CRC function (SHA1, MD5...) overrides --nocrc' },
   { s => 'help',           d => 'Show this help message' },
   { s => 'ignoredb|g=s',   d => 'Ignore this comma-separated list of databases' },
   { s => 'ignoretbl|n=s',  d => 'Ignore this comma-separated list of tables' },
   { s => 'lock|k',         d => 'Lock table on master until done on slaves (implies -l)' },
   { s => 'count|r!',       d => 'Do the count (default)' },
   { s => 'crc|c!',         d => 'Do the CRC (default)' },
   { s => 'password|p=s',   d => 'Password to use when connecting' },
   { s => 'port|P=i',       d => 'Port number to use for connection' },
   { s => 'replicate|R=s',  d => 'Replicate checksums in a table (implies -a BIT_XOR)' },
   { s => 'slavelag|l',     d => 'Report how far slaves lag master' },
   { s => 'separator|s=s',  d => 'Separator for CONCAT_WS' },
   { s => 'socket|S=s',     d => 'Socket file to use for connection' },
   { s => 'tab|b',          d => 'Output separated with tabs' },
   { s => 'tables|t=s',     d => 'Only do this comma-separated list of tables' },
   { s => 'user|u=s',       d => 'User for login if not current user' },
   { s => 'verify|v!',      d => 'Verify checksum compatibility across servers (default)' },
   { s => 'wait|w=i',       d => 'How long to do MASTER_POS_WAIT on slaves (implies -kl)' },
   { s => 'where|W=s',      d => 'Only do rows matching this WHERE clause (implies -f SHA1)' },
);

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   a => 'BIT_XOR',
   W => '',
   r => 1,
   c => 1,
   s => '#',
   v => 1,
);

# Post-process...
my %opt_seen;
foreach my $spec ( @opt_spec ) {
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{t} = $short;
   $spec->{n} = $spec->{s} =~ m/!/;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
}

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;

# Apply dependencies between arguments.
$opts{k} ||= defined $opts{w};
$opts{l} ||= $opts{k};
$opts{f} ||= $opts{W} ? 'SHA1'    : '';
$opts{a} =   $opts{R} ? 'BIT_XOR' : uc $opts{a};

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g} || '') };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n} || '') };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}

# Don't let someone put a ' in the separator
$opts{s} =~ s/'//g;

# Create a WHERE clause
$opts{W} = $opts{W} ? " WHERE $opts{W}" : '';

if ( $opts{a} !~ m/^(?:ACCUM|BIT_XOR)$/ ) {
   warn "--algorithm=$opts{a}: unknown algorithm.\n";
   $opts{help} = 1;
}

if ( !@ARGV ) {
   warn "No hosts specified.\n";
   $opts{help} = 1;
}

my @hosts = unique(@ARGV);
if ( $opts{R} && @hosts > 1 ) {
   die "You can only specify one host with --replicate\n";
}

if ( $opts{help} || $opts{a} !~ m/^(?:ACCUM|BIT_XOR)$/ || !@ARGV ) {
   print "Usage: $PROGRAM_NAME [OPTION]... HOST [HOST...]\n\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
      my $short = $spec->{t} ? "-$spec->{t}" : '';
      printf("  --%-13s %-4s %s\n", $long, $short, $spec->{d});
   }
   print <<USAGE;

$PROGRAM_NAME efficiently checksums MySQL tables
on one or more hosts.  If you specify multiple hosts, the first
is assumed to be the master.

If possible, database options are read from your .my.cnf file.
For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Ready to work now.
# ############################################################################

my $exit_status = 0;

my $db_options = {
   RaiseError => 1,
   PrintError => 1,
   AutoCommit => $opts{k} ? 0 : 1,
};

my $main_dbh  = get_dbh($hosts[0], ($opts{d} ? keys %{$opts{d}} : '' ));
$main_dbh->{InactiveDestroy} = 1; # Can't be set in $db_options
my @databases = @{$main_dbh->selectcol_arrayref('SHOW DATABASES')};

my $crc_wid = max(16, length(($main_dbh->selectrow_array("SELECT $opts{f}('a')"))[0]));

if ( $opts{v} && @hosts > 1 ) {
   # Verify that CONCAT_WS is compatible across all servers.  On older versions
   # of MySQL it skips both empty strings and NULL; on newer just NULL.
   my @verify_sums;
   foreach my $host ( @hosts ) {
      my $dbh = get_dbh($host, ($opts{d} ? keys %{$opts{d}} : '' ));
      my $cks = $dbh->selectall_arrayref("SELECT MD5(CONCAT_WS(',', '1', ''))")->[0]->[0];
      push @verify_sums, { host => $host, ver => $dbh->{mysql_serverinfo}, sum => $cks };
   }
   if ( unique(map { $_->{sum} } @verify_sums ) > 1 ) {
      my $max = max(map { length($_) } @hosts);
      die "Not all servers have compatible versions.  Some return different\n"
         . "checksum values for the same query, and cannot be compared.  This\n"
         . "behavior changed in MySQL 4.0.14.  Here is info on each host:\n\n"
         . join("\n",
            map { sprintf("%-${max}s %-32s %s", @{$_}{qw(host sum ver)}) }
            { host => 'HOST', sum => 'CHECKSUM', ver => 'VERSION'}, @verify_sums)
         . "\n\nYou can disable this check with --noverify.\n";
   }
}

my ($fetch_sth, $update_sth);
if ( $opts{R} ) {
   if ( !version_ge($main_dbh, '4.1.1') ) {
      die "--replicate can only be used on MySQL 4.1.1 and greater.\n";
   }
   $fetch_sth = $main_dbh->prepare(
      "SELECT this_crc, this_cnt FROM $opts{R} WHERE db = ? AND tbl = ?");
   $update_sth = $main_dbh->prepare(
      "UPDATE $opts{R} SET master_crc = ?, master_cnt = ? WHERE db = ? AND tbl = ?");
}
elsif ( $opts{a} eq 'BIT_XOR' ) {
   if ( !version_ge($main_dbh, '4.1.1') ) {
      warn "MySQL version is less than 4.1.1; using --algorithm=ACCUM.\n";
      $opts{a} = 'ACCUM';
   }
}

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^(information_schema|lost\+found)$/mi
      || exists $opts{g}->{$database};

   my @tables = @{$main_dbh->selectcol_arrayref("SHOW TABLES FROM `$database`")};
   next DATABASE unless @tables;

   my %info_for;
   TABLE:
   foreach my $table ( @tables ) {
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || ( $opts{R} && $opts{R} eq "$database.$table" )
         || exists $opts{n}->{$table};

      # Get the table type, and a query to generate a checksum for it.
      my ( $engine, $query ) = checksum_query( $main_dbh, $database, $table );

      # Skip views, and tables of the wrong engine.
      next TABLE if
         $engine eq 'VIEW'
         || ( $opts{e} && !exists $opts{e}->{lc($engine)});
      $info_for{$table} = {
         database => $database,
         table    => $table,
         engine   => $engine,
         query    => $query,
      };

   }

   next DATABASE unless %info_for;

   # Design and print header
   my $hdr;
   if ( $opts{b} ) {
      $hdr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n";
   }
   else {
      my $max_tbl  = max(5, map { length($_) } keys %info_for);
      my $max_db   = max(8, length($database));
      my $max_host = max(4, map { length($_) } @hosts);
      $hdr         = "%-${max_db}s %-${max_tbl}s %-${max_host}s %-6s %10s %${crc_wid}s %4s %4s %4s %4s\n";
   }
   my @hdr_args = qw(DATABASE TABLE HOST ENGINE COUNT CHECKSUM TIME WAIT STAT LAG);
   printf($hdr, @hdr_args);

   TABLE:
   foreach my $table ( sort keys %info_for ) {

      if ( $opts{R} ) { # We're in --replicate mode.
         eval {
            do_tbl_replicate($hosts[0], $info_for{$table}, $hdr);
         };
         if ( $EVAL_ERROR ) {
            print STDERR $EVAL_ERROR, "\n";
            $exit_status = 1;
         }
         next TABLE;
      }

      # Lock table and get master position on the master, if applicable.
      $main_dbh->do("LOCK TABLES `$database`.`$table` READ") if $opts{k};
      if ( defined $opts{w} ) {
         my $master_status = $main_dbh->selectrow_hashref('SHOW MASTER STATUS');
         @{$info_for{$table}}{keys %$master_status} = values %$master_status;
      }

      my %children;
      foreach my $host ( @hosts ) {
         my $pid = @hosts > 1 ? fork() : undef;
         if ( @hosts == 1 || (defined($pid) && $pid == 0) ) { # I am a child
            eval {
               do_tbl($host, $info_for{$table}, $host eq $hosts[0], $hdr);
            };
            if ( $EVAL_ERROR ) {
               print STDERR $EVAL_ERROR, "\n";
               exit(1); # die, even if only a single host
            }
            exit(0) if @hosts > 1; # exit only if I'm a child
         }
         elsif ( @hosts > 1 && !defined($pid) ) {
            die("Unable to fork!");
         }
         # I already exited if I'm a child, so I'm the parent.
         $children{$host} = $pid if @hosts > 1;
      }

      # Wait for the children to exit.
      foreach my $host ( keys %children ) {
         my $pid = waitpid($children{$host}, 0);
         $exit_status = $CHILD_ERROR;
      }
      $main_dbh->do("UNLOCK TABLES") if $opts{k};
   }
}

sub do_tbl_replicate {
   my ( $host, $info, $hdr ) = @_;
   my $dbh = $main_dbh;
   my $cnt = 'NULL';
   my $crc = 'NULL';
   my $beg = time();
   $dbh->do('SET @crc := NULL');
   $dbh->do($info->{query});
   $fetch_sth->execute($info->{database}, $info->{table});
   ( $crc, $cnt ) = $fetch_sth->fetchrow_array();
   $update_sth->execute($crc, $cnt, $info->{database}, $info->{table});
   my $end = time();
   printf($hdr, $info->{database}, $info->{table}, $host, $info->{engine}, $cnt, $crc,
      $end - $beg, 'NULL', 'NULL', 'NULL');
}

sub do_tbl {
   my ( $host, $info, $is_master, $hdr ) = @_;
   my $dbh = get_dbh($host, $info->{database});
   my $cnt = 'NULL';
   my $crc = 'NULL';
   my $sta = 'NULL';
   my $lag = 'NULL';
   my $beg = time();
   if ( !$is_master && defined $opts{w} ) {
      $sta = $dbh->selectall_arrayref(
         "SELECT /*$info->{database}.$info->{table}*/ MASTER_POS_WAIT('$info->{File}', $info->{Position}, $opts{w})")->[0]->[0];
      $sta = 'NULL' unless defined $sta;
   }
   if ( !$is_master && $opts{l} ) {
      my $res = $dbh->selectrow_hashref("SHOW SLAVE STATUS");
      $lag = $res && defined $res->{Seconds_Behind_Master}
           ? $res->{Seconds_Behind_Master}
           : 'NULL';
   }
   my $mid = time();
   if ( !$opts{f} && version_ge($dbh, '4.1.1') ) {
      if ( $opts{c} ) {
         $crc = $dbh->selectall_arrayref("CHECKSUM TABLE `$info->{database}`.`$info->{table}`",
            { Slice => {} })->[0]->{Checksum};
      }
      if ( $opts{r} ) {
         $cnt = do_count($dbh, $info);
      }
   }
   else {
      if ( !$opts{f} && !$opts{c} ) {
         $cnt = do_count($dbh, $info);
      }
      else {
         ( $cnt, $crc ) = do_var_crc($dbh, $info->{query});
         $crc ||= 'NULL';
      }
   }
   my $end = time();
   $dbh->disconnect();
   printf($hdr, $info->{database}, $info->{table}, $host, $info->{engine}, $cnt, $crc,
      $end - $mid, $mid - $beg, $sta, $lag);
}

sub checksum_query {
   my ( $dbh, $db, $tbl ) = @_;
   my $ddl = ($dbh->selectrow_array("SHOW CREATE TABLE `$db`.`$tbl`"))[1];
   return ( 'VIEW', '' ) if $ddl =~ m/^CREATE ALGORITHM/;

   my ( $type ) = $ddl =~ m/^\) (?:ENGINE|TYPE)=(\S+)/m;

   # Make a list of all columns.
   my @defs  = $ddl =~ m/^(\s+`.*)$/gm;
   my @cols  = map { $_ =~ m/(`[^`]+`)/g } @defs;
   my @tocrc = @cols;

   # To detect when columns are NULL, make a bitmap of nullable columns.
   my @nulls = map { $_ =~ m/(`[^`]+`)/g } grep { $_ !~ m/NOT NULL/ } @defs;
   if ( @nulls ) {
      push @tocrc, "CONCAT(" . join(', ', map { "ISNULL($_)" } @nulls) . ")";
   }

   # Design the column checksum expression.
   my $func = $opts{f} || 'SHA1';
   my $chks = @tocrc > 1
            ? "$func(CONCAT_WS('$opts{s}', " . join(',', @tocrc) . '))'
            : "$func($tocrc[0])";

   # Make the query.
   my $query = '';
   if ( $opts{a} eq 'BIT_XOR' ) {

      # Split the CRC result up into slices and glue them together.
      my @slices;
      for ( my $start = 1; $start < $crc_wid; $start += 16 ) {
         my $len = min(16, $crc_wid - $start + 1);
         push @slices,
            "LPAD(CONV(BIT_XOR("
            . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
            . ", 10, 16), $len, '0')";
      }

      # The last slice actually needs to do a real CRC on the columns.
      # TODO: when there are two slices, the second... when three, the
      # third... argh.  Figure out how to fix this.
      # $slices[-1] =~ s/\@crc/\@crc:=$func(CONCAT_WS('$opts{s}', $cols$nulls))/;
      map { s/\@crc/$chks/ } @slices;

      if ( $opts{R} ) {
         $query = "REPLACE /*$db.$tbl*/ INTO $opts{R}(db, tbl, this_cnt, this_crc) "
            . "SELECT '$db', '$tbl', COUNT(*), CONCAT("
            . join(', ', @slices)
            . ") AS crc FROM `$db`.`$tbl`$opts{W}";
      }
      else {
         $query = "SELECT \@cnt := COUNT(*), \@crc := CONCAT("
            . join(', ', @slices)
            . ") AS crc FROM `$db`.`$tbl`$opts{W}";
      }

   }
   else {
      # Find whether there's a PK (for order-by).
      my $index = $ddl =~ m/PRIMARY KEY\s*\((.*?)\)/ ? ' USE INDEX(PRIMARY)' : '';
      $query = "SELECT /*$db.$tbl*/ MIN(LEAST(0, "
      . "LENGTH(\@crc := $func(CONCAT_WS('$opts{s}', \@crc, $chks))), "
      . "\@cnt := \@cnt + 1)) AS len FROM `$db`.`$tbl`$index$opts{W}";
   }

   return ( $type, $query );
}

exit $exit_status;

# ############################################################################
# Subroutines
# ############################################################################

sub get_dbh {
   my ( $host, $db ) = @_;
   my %conn = ( h => 'host', P => 'port', S => 'socket');

   $db ||= '';
   my $dsn = "DBI:mysql:$db;host=$host"
      . join(';', map  { "$conn{$_}=$opts{$_}" } grep { defined $opts{$_} } qw(h P S))
      . ';mysql_read_default_group=mysql';
   return DBI->connect($dsn, @opts{qw(u p)}, $db_options )
      or die("Can't connect to DB: $OS_ERROR");
}

sub do_var_crc {
   my ( $dbh, $query ) = @_;
   $dbh->do('set @crc := "", @cnt := 0');
   $dbh->do($query);
   return @{$dbh->selectall_arrayref('select @cnt, @crc')->[0]};
}

sub do_count {
   my ( $dbh, $info ) = @_;
   return $dbh->selectall_arrayref(
      "SELECT COUNT(*) FROM `$info->{database}`.`$info->{table}`$opts{W}"
   )->[0]->[0];
}

sub unique {
   my %seen;
   grep { !$seen{$_}++ } @_;
}

# Compares versions like 5.0.27 and 4.1.15-standard-log
sub version_ge {
   my ( $dbh, $target ) = @_;
   my $version = sprintf('%03d%03d%03d', $dbh->{mysql_serverinfo} =~ m/(\d+)/g);
   return $version ge sprintf('%03d%03d%03d', $target =~ m/(\d+)/g);
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-table-checksum - Efficiently checksum MySQL tables on one or many servers.

=head1 SYNOPSIS 

  mysql-table-checksum --replicate=mydb.checksum master-host

Or,

  mysql-table-checksum master-host slave-host1 slave-host2 ... slave-hostN

=head1 OPTIONS

Many options are enabled by default and can be disabled by prefixing with --no.

=over

=item --algorithm

Specifies which checksum algorithm to use when not using CHECKSUM TABLE (see
--function).  Valid arguments are BIT_XOR and ACCUM.  BIT_XOR is the default.

The BIT_XOR algorithm is available for MySQL 4.1.1 and newer.  It uses a
cryptographic hash of all columns concatenated together with a separator,
followed by a bitmap of each nullable column that is NULL (necessary because
CONCAT_WS() skips NULL columns).  It then uses BIT_XOR(), which is
order-independent, to reduce all the rows to a single checksum.

For servers older than 4.1.1, BIT_XOR() is not available, and the ACCUM
algorithm is used as a fallback.  In this case a single user variable is used
as an accumulator.  Each row is reduced to a single checksum, which is
concatenated and re-checksummed.  This technique is order-dependent.  If the
table has a primary key, it will be used to order the results for consistency;
otherwise it's up to chance.

The ACCUM algorithm has two important advantages over BIT_XOR: speed (there
are fewer cryptographic hash operations) and possibly fewer collisions.  You
can construct a pathological case where a table with a single column, having
all the same values and an even number of rows, will checksum and BIT_XOR to
zero.  In this case you will not be able to distinguish a table full of one
value from a table full of another value.  The ACCUM algorithm will
distinguish them.

However, the ACCUM algorithm is order-dependent, so if you have two tables
with identical data but the rows are out of order, you'll get different
checksums with ACCUM.

Choose your poison.

=item --databases

Only checksum this comma-separated list of databases.

=item --engine

Only checksum tables whose storage engine is in this comma-separated list.
You can use this to restrict the checksum to InnoDB, for example.

=item --function

You can use this option to choose the cryptographic hash function used to
create a row checksum for each row.  The default is to use SHA1, but other
good choices include MD5.  Whatever function you specify is run in SQL, not in
Perl, so it must be available to MySQL.

If you leave this option at its default, storage engines that support MySQL's
built-in CHECKSUM TABLE command will be checksummed with that.

One reason you might override this is to do checksums across tables that have
the same data but different row formats (possibly because of different storage
engines), and thus will return different values for CHECKSUM TABLE.  Or you
might want to checksum on a pre-4.1.1 server, which is when CHECKSUM TABLE was
introduced.

Checksums based on cryptographic hash functions simultaneously count rows, so if
you want a row count, this might be faster than CHECKSUM TABLE, which requires a
separate COUNT(*) query to get row count.

If you want to checksum only part of the table with a WHERE clause, CHECKSUM
TABLE will not work, so this option is enabled by default when you specify
--where.

=item --ignoredb

Use this option to skip a comma-separated list of databases.

=item --ignoretbl

Use this option to skip a comma-separated list of tables.

=item --lock

This option can help you to get a consistent read on a master and many slaves.
If you specify this option, mysql-table-checksum will lock the table on the
first server on the command line, which it assumes to be the master.  It will
keep this lock until the checksums complete on the other servers.

This option isn't very useful by itself, so you probably want to use --wait
instead.

=item --count

Count the rows as well as taking their checksum. This is enabled by default.

=item --crc

Take the checksum of the rows as well as their count.  This is enabled by
default.

=item --password

The password to use when connecting.

=item --port

The port number to use for the connection.

=item --replicate

This option enables a completely different checksum strategy for a consistent,
lock-free checksum across a master and its slaves.  This only works with
statement-based replication on MySQL 4.1.1 and greater.

Instead of running the checksum queries on each server, you only run it on the
master.  You specify a table to insert the results into.  The query will
insert directly into the table, so it will be replicated through the binlog to
the slaves.

The argument to the option is the table in which the checksums should be
stored.  The table must have at least these columns: db, tbl, this_crc,
master_crc, this_cnt, master_cnt.  Here is a suggested table structure:

  CREATE TABLE checksum (
     db         char(64)     NOT NULL,
     tbl        char(64)     NOT NULL,
     this_crc   char(32)     NOT NULL,
     this_cnt   int unsigned NOT NULL,
     master_crc char(32)         NULL,
     master_cnt int unsigned     NULL,
     ts         timestamp    NOT NULL,
     PRIMARY KEY (db,tbl)
  );

When the queries are finished replicating, you can run a simple query on each
slave to see which tables have differences from the master.  See L<"CONSISTENT
CHECKSUMS"> for details.

This option eliminates the need to do complicated locking and unlocking,
waiting for master binlog positions, and so on.  It disables --lock, --wait,
and --slavelag.

=item --slavelag

If this option is enabled, the output will show how many seconds behind the
master each slave is.  This can be useful when you want a fast, parallel,
non-blocking checksum, and you know your slaves might lag the master.  You can
inspect the results and make an educated guess whether any discrepancies on the
slave are due to slave lag instead of corrupt data.

=item --separator

This option controls the separator character used for CONCAT_WS() when taking
row checksums with user-variables.

=item --socket

The socket file to use for the connection.

=item --tab

Instead of using tabular, aligned output, print tab-separated output.

=item --tables

Restrict checksums to this comma-separated list of tables.

=item --user

MySQL user account to use for the connection.

=item --verify

This option is enabled by default.  It runs a trivial checksum on all servers to
ensure they have compatible CONCAT_WS() and cryptographic hash functions.

Versions of MySQL before 4.0.14 will skip empty strings and NULLs in
CONCAT_WS, and others will only skip NULLs.  The two kinds of behavior will
produce different results if you have any columns containing the empty string
in your table.  If you know you don't (for instance, all columns are
integers), you can safely disable this check and you will get a reliable
checksum even on servers with different behavior.

=item --wait

This option helps you get a consistent checksum across a master server and its
slaves.  It combines locking and waiting to accomplish this.  First it locks the
table on the master (the first server on the command line).  Then it finds the
master's binlog position and checksums.

The argument to the option is the number of seconds to wait for the slaves to
catch up to the master.  It is actually the argument to MASTER_POS_WAIT().  If
the slaves don't catch up to the master within this time, they will unblock
and go ahead with the checksum.  You can tell whether this happened by
examining the STAT column in mysql-table-checksum's output.

=item --where

You can use this option to limit the checksum to only part of the table.  This
is particularly useful if you have append-only tables and don't want to
constantly re-check all rows; you could run a daily job to just check
yesterday's rows, for instance.

This option is much like the -w option to mysqldump.  Do not specify the WHERE
keyword.  You may need to quote the value.  Here is an example:

  mysql-table-checksum --where "foo=bar"

=back

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

The checksums work for me on MySQL version 4.1.20-log and various MySQL 5.0.x
versions.

=head1 OVERVIEW

This script generates table checksums for MySQL tables, typically useful for
verifying your slaves are in sync with the master.  The checksums are
generated by a query on the server, and there is virtually no network traffic
as a result.

If you specify more than one server, the script assumes the first server is
the master and others are slaves.  Checksums are done in parallel for speed,
forking off a child process for each table.  Duplicate server names are
ignored, but if you want to checksum a server against itself you can use two
different forms of the hostname (for example, localhost and 127.0.0.1).

mysql-table-checksum only examines table structure on the master, so if the
storage engine or table structure differs on the slave, it won't notice.  The
script ignores views.

=head1 CONSISTENT CHECKSUMS

If you are using this tool to verify your slaves still have the same data as the
master, which is why I wrote it, you should read this section.

The best way to do this with statement-based replication is to use the
--replicate option.  When the queries are finished running on the master and
its slaves, you can go to the slaves and issue SQL queries to see if any
tables are different from the master.  Try the following:

  SELECT db, tbl FROM checksum
  WHERE master_cnt <> this_cnt OR master_crc <> this_crc;

If you can't use this method, try the following:

=over

=item *

If your servers are not being written to, you can just run the tool with no
further ado:

  mysql-table-checksum server1 server2 ... serverN

=item *

If the servers are being written to, you need some way to make sure they are
consistent at the moment you run the checksums.  For situations other than
master-slave replication, you will have to figure this out yourself.  You may
be able to use the --where option with a date or time column to only checksum
data that's not recent.

=item *

If you are checksumming a master and slaves, you can do a fast parallel
checksum and assume the slaves are caught up to the master.  In practice, this
tends to work well except for tables which are constantly updated.  You can
use the --slavelag option to see how far behind each slave was when it
checksummed a given table.  This can help you decide whether to investigate
further.

=item *

The next most disruptive technique is to lock the table on the master, then take
checksums.  This should prevent changes from propagating to the slaves.  You can
just lock on the master (with --lock), or you can both lock on the master and wait
on the slaves till they reach that point in the master's binlog (--wait).  Which is
better depends on your workload; only you know that.

=item *

If you decide to make the checksums on the slaves wait until they're guaranteed
to be caught up to the master, the algorithm looks like this:

 For each table,
   Master: lock table
   Master: get pos
   In parallel,
     Master: checksum
     Slave(s): wait for pos, then checksum
   End
   Master: unlock table
 End 

=back

What I typically do when I'm not using the --replicate option is simply run the
tool on all servers with no further options.  This runs fast, parallel,
non-blocking checksums simultaneously.  If there are tables that look different,
I re-run with --wait=600 on the tables in question.  This makes the tool lock on
the master as explained above.

=head1 OUTPUT

Output is to STDOUT, one line per server and table, with header lines for each
database.  I tried to make the output easy to process with awk.  For this reason
columns are always present.  If there's no value, the script prints 'NULL'.

The default is column-aligned output for human readability, but you can change
it to tab-separated if you want.  Use the --tab option for this.

Output is unsorted, though all lines for one table should be output together.
For speed, all checksums are done in parallel (as much as possible) and may
complete out of the order in which they were started.  You might want to run
them through another script or command-line utility to make sure they are in the
order you want.  If you pipe the output through mysql-checksum-filter, you can
avoid seeing output about tables that are the same.

The columns in the output are as follows.  The database and table come first so
you can sort by them easily.

=over

=item DATABASE

The database the table is in.

=item TABLE

The table name.

=item HOST

The server's hostname.

=item ENGINE

The table's storage engine.

=item COUNT

The table's row count, unless you specified to skip it.

=item CHECKSUM

The table's checksum, unless you specifed to skip it or the table has no rows.
MyISAM checksums will be 0 if there are no rows; other styles will print NULL.

=item TIME

The time the actual checksum and/or counting took.

=item WAIT

How long the checksum blocked before beginning.

=item STAT

The return value of MASTER_POS_WAIT().

=item LAG

How far the slave lags the master, as reported by SHOW SLAVE STATUS.

=back

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=head1 ACKNOWLEDGEMENTS

This is an incomplete list.  My apologies for omissions or misspellings.

Giuseppe Maxia,
Heikki Tuuri,
Martin Friebe,

=cut
