#!/usr/bin/perl

# TODO:
# Is it possible to XOR rows so the result is order-independent?

# This program checksums MySQL tables on one or more servers.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(max);
use Time::HiRes qw(time);

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my %opt_spec = (
   l => { s => 'help',           d => 'Show this help message' },
   d => { s => 'databases|d=s',  d => 'Only do this comma-separated list of databases' },
   g => { s => 'ignoredb|g=s',   d => 'Ignore this comma-separated list of databases' },
   t => { s => 'tables|t=s',     d => 'Only do this comma-separated list of tables' },
   n => { s => 'ignoretbl|n=s',  d => 'Ignore this comma-separated list of tables' },
   e => { s => 'engine|e=s',     d => 'Only do this comma-separated list of storage engines' },
   s => { s => 'where=s',        d => 'Only do rows matching this WHERE clause (implies -f SHA1)' },
   f => { s => 'function|f=s',   d => 'CRC function (SHA1, MD5...) overrides --nocrc' },
   c => { s => 'nocrc',          d => 'Skip the CRC' },
   r => { s => 'nocount',        d => 'Skip the count' },
   k => { s => 'lock|k',         d => 'Lock table on master until done on slaves (implies -v)' },
   v => { s => 'slavelag|v',     d => 'Report how far slaves lag master' },
   w => { s => 'wait|w=i',       d => 'How long to do MASTER_POS_WAIT on slaves (implies -kv)' },
   b => { s => 'tab|b',          d => 'Output separated with tabs' },
   o => { s => 'port|P=i',       d => 'Database server port' },
   u => { s => 'user|u=s',       d => 'Database username' },
   p => { s => 'pass|p=s',       d => 'Database password' },
);

# Define the order cmdline opts will appear in help output.  Add any extra ones
# defined above.  If it's not in this list, it's not an option to this
# program.  Note that 'h' is host and 'l' is help.
my @opt_keys = qw( l d g t n e s f c r k v w b o p u );

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   l => 0,
   d => '',
   g => '',
   t => '',
   n => '',
   e => '',
   s => '',
   f => '',
   c => 0,
   r => 0,
   k => 0,
   v => 0,
   w => undef,
   b => 0,
   o => 3306,
   u => getlogin() || getpwuid($UID),
   p => '',
);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => ref $opts{$_} ? $opts{$_} : \$opts{$_} }  @opt_keys );

# Apply dependencies between arguments.
$opts{k} ||= defined $opts{w};
$opts{v} ||= $opts{k};
$opts{f} ||= $opts{s} ? 'SHA1' : '';

# Make comma-separated lists into hashes.
if ( $opts{d} ) {
   $opts{d} = { map { $_ => 1 } split(/,\s*/, $opts{d}) };
}
$opts{g} = { map { $_ => 1 } split(/,\s*/, $opts{g}) };
if ( $opts{t} ) {
   $opts{t} = { map { $_ => 1 } split(/,\s*/, $opts{t}) };
}
$opts{n} = { map { $_ => 1 } split(/,\s*/, $opts{n}) };
if ( $opts{e} ) {
   $opts{e} = { map { lc($_) => 1 } split(/,\s*/, $opts{e}) };
}

# Create a WHERE clause
$opts{s} = $opts{s} ? " WHERE $opts{s}" : '';

if ( $opts{l} || !@ARGV ) {
   print "Usage: $PROGRAM_NAME -u <user> -p <pass> [OPTION]... MASTER [SLAVE...]\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^=]*))?/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME checksums MySQL tables.  If you specify multiple servers, the
first server is treated as the master, and the rest as slaves of it, for
purposes of locking and doing MASTER_POS_WAIT.

For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Ready to work now.
# ############################################################################

my $exit_status = 0;
my @hosts = unique(@ARGV);

my $db_options = {
   RaiseError => 1,
   PrintError => 1,
   AutoCommit => $opts{k} ? 0 : 1,
};

my $main_dbh  = get_dbh($hosts[0], ($opts{d} ? keys %{$opts{d}} : '' ));
$main_dbh->{InactiveDestroy} = 1; # Can't be set in $db_options
my @databases = @{$main_dbh->selectcol_arrayref('show databases')};

DATABASE:
foreach my $database ( @databases ) {
   next DATABASE if
      ( $opts{d} && !exists($opts{d}->{$database}) )
      || $database =~ m/^information_schema$/mi
      || exists $opts{g}->{$database};

   my @tables = @{$main_dbh->selectcol_arrayref('SHOW TABLES FROM ' . $database)};
   next DATABASE unless @tables;

   my %info_for;
   TABLE:
   foreach my $table ( @tables ) {
      next TABLE if
         ( $opts{t} && !exists($opts{t}->{$table}) )
         || exists $opts{n}->{$table};

      # Get the table type, and a query to generate a checksum for it.
      my ( $engine, $query ) = checksum_query( $main_dbh, $database, $table );

      # Skip views, and tables of the wrong engine.
      next TABLE if
         $engine eq 'VIEW'
         || ( $opts{e} && !exists $opts{e}->{lc($engine)});
      $info_for{$table} = {
         database => $database,
         table    => $table,
         engine   => $engine,
         query    => $query,
      };
   }

   next DATABASE unless %info_for;

   # Design and print header
   my $hdr;
   if ( $opts{b} ) {
      $hdr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n";
   }
   else {
      my $crc_wid  = lc($opts{f}) eq 'md5' ? 32 : 40;
      my $max_tbl  = max(5, map { length($_) } keys %info_for);
      my $max_db   = max(8, length($database));
      my $max_host = max(4, map { length($_) } @hosts);
      $hdr         = "%-${max_db}s %-${max_tbl}s %-${max_host}s %-6s %10s %${crc_wid}s %4s %4s %4s %4s\n";
   }
   my @hdr_args = qw(DATABASE TABLE HOST ENGINE COUNT CHECKSUM TIME WAIT STAT LAG);
   printf($hdr, @hdr_args);

   TABLE:
   foreach my $table ( sort keys %info_for ) {

      # Lock table and get master position on the master, if applicable.
      $main_dbh->do("LOCK TABLES $database.$table READ") if $opts{k};
      if ( defined $opts{w} ) {
         my $master_status = $main_dbh->selectrow_hashref('SHOW MASTER STATUS');
         @{$info_for{$table}}{keys %$master_status} = values %$master_status;
      }

      my %children;
      foreach my $host ( @hosts ) {
         my $pid = fork();
         if ( defined($pid) && $pid == 0 ) { # I am a child
            do_tbl($host, $info_for{$table}, $host eq $hosts[0], $hdr);
         }
         elsif ( !defined($pid) ) {
            die("Unable to fork!");
         }
         # I already exited if I'm a child, so I'm the parent.
         $children{$host} = $pid;
      }

      # Wait for the children to exit.
      foreach my $host ( keys %children ) {
         my $pid = waitpid($children{$host}, 0);
         $exit_status ||= $CHILD_ERROR;
      }
      $main_dbh->do("UNLOCK TABLES") if $opts{k};
   }
}

sub do_tbl {
   my ( $host, $info, $is_master, $hdr ) = @_;
   my $dbh = get_dbh($host, $info->{database});
   my $cnt = 'NULL';
   my $crc = 'NULL';
   my $sta = 'NULL';
   my $lag = 'NULL';
   my $beg = time();
   if ( !$is_master && defined $opts{w} ) {
      $sta = $dbh->selectall_arrayref(
         "SELECT MASTER_POS_WAIT('$info->{File}', $info->{Position}, $opts{w})")->[0]->[0];
      $sta = 'NULL' unless defined $sta;
   }
   if ( !$is_master && $opts{v} ) {
      my $res = $dbh->selectrow_hashref("SHOW SLAVE STATUS");
      $lag = $res && defined $res->{Seconds_Behind_Master}
           ? $res->{Seconds_Behind_Master}
           : 'NULL';
   }
   my $mid = time();
   if ( $info->{engine} eq 'MyISAM' && !$opts{f}  ) {
      if ( !$opts{c} ) {
         $crc = $dbh->selectall_arrayref("CHECKSUM TABLE $info->{database}.$info->{table}",
            { Slice => {} })->[0]->{Checksum};
      }
      if ( !$opts{r} ) {
         $cnt = do_count($dbh, $info);
      }
   }
   else {
      if ( !$opts{f} && $opts{c} ) {
         $cnt = do_count($dbh, $info);
      }
      else {
         ( $cnt, $crc ) = do_var_crc($dbh, $info->{query});
         $crc ||= 'NULL';
      }
   }
   my $end = time();
   $dbh->disconnect();
   printf($hdr, $info->{database}, $info->{table}, $host, $info->{engine}, $cnt, $crc,
      sprintf('%d', $end - $mid), sprintf('%d', $mid - $beg), $sta, $lag);
   exit(0);
}

sub checksum_query {
   my ( $dbh, $db, $tbl ) = @_;
   my $ddl = ($dbh->selectrow_array("SHOW CREATE TABLE $db.$tbl"))[1];
   return ( 'VIEW', '' ) if $ddl =~ m/^CREATE ALGORITHM/;

   my ( $type ) = $ddl =~ m/^\) (?:ENGINE|TYPE)=(\S+)/m;

   # Make a list of all columns.
   my @defs  = $ddl =~ m/^(\s+`.*)$/gm;
   my @cols  = map { $_ =~ m/(`[^`]+`)/g } @defs;
   my $cols  = join(', ', @cols);

   # To handle nulls, make a bitmap of nullable columns that are null.
   my @nulls = map { $_ =~ m/(`[^`]+`)/g } grep { $_ !~ m/NOT NULL/ } @defs;
   my $nulls = @nulls
             ? (", CONCAT(" . join(', ', map { "ISNULL($_)" } @nulls) .  ")")
             : '';

   # Apply WHERE and find whether there's a PK (for order-by in InnoDB).
   my $index = $ddl =~ m/PRIMARY KEY\s*\((.*?)\)/ ? ' USE INDEX(PRIMARY)' : '';

   # Make the query.
   my $func = $opts{f} || 'SHA1';
   my $query = "SELECT MIN(LEAST(0, "
      . "LENGTH(\@crc := $func(CONCAT_WS('#', \@crc, $func(CONCAT_WS('#', $cols$nulls))))), "
      . "\@cnt := \@cnt + 1)) AS len FROM `$db`.`$tbl`$index$opts{s}";

   return ( $type, $query );
}

exit $exit_status;

# ############################################################################
# Subroutines
# ############################################################################

sub get_dbh {
   my ( $host, $db ) = @_;
   $db ||= '';
   return DBI->connect(
      "DBI:mysql:$db;host=$host;port=$opts{o}", $opts{u}, $opts{p}, $db_options )
      or die("Can't connect to DB: $!");
}

sub do_var_crc {
   my ( $dbh, $query ) = @_;
   $dbh->do('set @crc := "", @cnt := 0');
   $dbh->do($query);
   return @{$dbh->selectall_arrayref('select @cnt, @crc')->[0]};
}

sub do_count {
   my ( $dbh, $info ) = @_;
   return $dbh->selectall_arrayref(
      "SELECT COUNT(*) FROM $info->{database}.$info->{table}$opts{s}"
   )->[0]->[0];
}

sub unique {
   my %seen;
   grep { !$seen{$_}++ } @_;
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-table-checksum - Print checksums for MySQL tables on one or many servers.

=head1 OVERVIEW

This script generates table checksums for MySQL tables, typically useful for
verifying your slaves are in sync with the master.

Invoke the script with options and server names on the command line.  If you
specify more than one server, the script assumes the first server is the master
and others are slaves.  It iterates through the databases and tables, and for
each table generates a checksum for each server, in the order you specified them
on the command line.  For speed it does these in parallel, forking off a child
process for each table.  Duplicate server names are ignored, but if you want to
checksum a server against itself you can use two different forms of the hostname
(for example, localhost and 127.0.0.1).

There are several options to help you get a more consistent read as
unobtrusively as possible.  The most basic thing the script can do is lock the
table on the master until the checksum on the slave is finished, preventing
replication changes from affecting the data in the table.  This is one table at
a time; it does not lock all tables at once.  Also, the checksums are on the
in-memory copy of the table, so there is no need to flush them to disk.  If your
slaves are keeping up with the master, this is probably a fine way to do things.
You can tell the script to print how far behind the slave is to help you see
this.

If the slaves aren't keeping up, you can tell the checksum to wait on the slave
until it has reached the position in the master's binlog where the table was
locked.  The wait parameter is a timeout value, so if it times out, it'll go
ahead with the checksum even if the slave hasn't caught up to that position.
Check the STAT column to see.

Checksums use SHA1 by default on non-MyISAM tables, and the built-in table
checksum on MyISAM tables, but you can specify a CRC function to use too.  Good
options include SHA1 and MD5.  This function is run in SQL, not in Perl, so the
function must be built in to MySQL.

You can skip the row count or the checksum if you want.  The non-MyISAM checksum
technique automatically counts rows as it does the checksum, so skipping the
count on InnoDB doesn't save you any overhead, if you're worried about that.
COUNT(*) is not used unless you skip the checksum.

You can constrain the checksum to only do some databases or tables and ignore
some databases or tables.  You can tell it to only do tables with some storage
engines.  The script only examines table structure on the master, so if the
storage engine or table structure differs on the slave, it won't notice.  The
script ignores views.

You can further restrict the checksum to only a part of a table with the --where
option, similar the the -w option to mysqldump.  The argument to this option
should be quoted and should not contain the word WHERE.  For example, specifying
"--where 'foo=bar'" on the command line will result in the checksum being run
with "WHERE foo=bar".  If you specify this option for a table that doesn't have
a foo column, the query will cause an error.

=head1 OUTPUT

Output is to STDOUT, one line per server and table, with header lines for each
database.  I tried to make the output easy to process with awk.  For this reason
columns are always present.  If there's no value, the script prints 'NULL'.

The default is column-aligned output for human readability, but you can change
it to tab-separated if you want.

Output is unsorted, though all lines about one table should be output together.
For speed, all checksums are done in parallel (as much as possible) and may
complete out of the order in which they were started.  You might want to run
them through another script or command-line utility to make sure they are in the
order you want.  If you pipe the output through mysql-checksum-filter, you can
avoid seeing output about tables that are the same.

The columns in the output are as follows.  The database and table come first so
you can sort by them easily.

=over

=item DATABASE

The database the table is in.

=item TABLE

The table name.

=item HOST

The server's hostname.

=item ENGINE

The table's storage engine.

=item COUNT

The table's row count, unless you specified to skip it.

=item CHECKSUM

The table's checksum, unless you specifed to skip it or the table has no rows.
MyISAM checksums will be 0 if there are no rows; other styles will print NULL.

=item TIME

The time the actual checksum and/or counting took.

=item WAIT

How long the checksum blocked before beginning.

=item STAT

The return value of MASTER_POS_WAIT().

=item LAG

How far the slave lags the master, as reported by SHOW SLAVE STATUS.

=back

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
