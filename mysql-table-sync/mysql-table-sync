#!/usr/bin/perl

# This program synchronizes data between two MySQL tables, which need not be
# on the same server.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my %opt_spec = (
   l => { s => 'help',           d => 'Show this help message' },
   a => { s => 'algorithm|a=s',  d => 'Sync algorithm to use' },
   p => { s => 'print|p',        d => 'Print all sync queries to STDOUT' },
   e => { s => 'explain|e=i',    d => 'Explain changes at recursion levels 0..n' },
   x => { s => 'execute|x',      d => 'Execute queries required to sync' },
   g => { s => 'grouping|g=s',   d => 'Grouping for recursion in top-down algorithm' },
# TODO:
# check that master is amaster, and slave is a slave
# Don't allow updates on dest server if it is a slave unless --updateon=master|slave
# Allow choice of REPLACE/INSERT/INSERT IGNORE/INSERT ODKU/UPDATE
# Allow using a different key than primary key
# Allow to specify which columns
);

# Define the order cmdline opts will appear in help output.  Add any extra ones
# defined above.  If it's not in this list, it's not an option to this
# program.  Note that 'h' is host and 'l' is help.
my @opt_keys = qw( l a p e x g );

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   l => 0,
   a => 'topdown',
   p => 0,
   e => 0,
   x => 1,
   g => '',
);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => \$opts{$_} }  @opt_keys );

# ############################################################################
# Try to use the user's .my.cnf file.
# ############################################################################
my $my_cnf = {
   host => 'localhost',
   user => getlogin() || getpwuid($UID),
   port => 3306,
};
eval {
   my $homedir = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '';
   my $filename = "$homedir/.my.cnf";
   if ( -f $filename ) {
      open my $conf_file, "<", "$homedir/.my.cnf" or die $OS_ERROR;
      while ( my $line = <$conf_file> ) {
         chomp $line;
         $line =~ s/(^\s*)|(\s*#.*$)//g;
         next unless $line;
         my ( $key, $val ) = split( /\s*=\s*/, $line );
         next unless defined $val;
         if ( $key eq 'host' )     { $my_cnf->{host} = $val; }
         if ( $key eq 'user' )     { $my_cnf->{user} = $val; }
         if ( $key =~ m/^pass/ )   { $my_cnf->{pass} = $val; }
         if ( $key eq 'database' ) { $my_cnf->{database} = $val; }
         if ( $key eq 'port' )     { $my_cnf->{port} = $val; }
      }
      close $conf_file;
   }
};

# ############################################################################
# Parse arguments saying which tables.  If the script doesn't have everything
# it needs, how help text.
# ############################################################################
my $source = parse_dsn(shift(@ARGV), {},      $my_cnf);
my $dest   = parse_dsn(shift(@ARGV), $source, $my_cnf);

if ( $opts{l} || !$dest ) {
   print "Usage: $PROGRAM_NAME [OPTION].. <source> <dest>\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^=]*))?/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME finds and resolves data differences between two MySQL tables.
<source> and <dest> are data sources in the format
   user:pass\@host:port/database.table
Everything but the table name is optional, and defaults will be read from your
environment and your .my.cnf file if possible.  Values for <dest> default to the
values for <source> except for the table name.

For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Algorithm lookup table.
# ############################################################################
my %code_for_algorithm = (
   topdown => \&topdown,
);

# ############################################################################
# Do the work.
# ############################################################################
my $exit_status = 0;

my $dbh_s = get_dbh($source);
my $dbh_d = get_dbh($dest);
my $tbl_n = "`$opts{d}`.`$opts{t}`"; # XXX
my $tbl_s = get_tbl_struct();
my $tbl_c = join(', ', map { $dbh_s->quote_identifier($_) } @{$tbl_s->{cols}});

if ( $code_for_algorithm{$opts{a}} ) {
   $code_for_algorithm{$opts{a}}->();
}
else {
   die "Sorry, algorithm '$opts{a}' unknown; try one of "
      . join('|', keys %code_for_algorithm);
}

exit $exit_status;

# ############################################################################
# Top-down algorithm
# ############################################################################

sub topdown {

   # TODO
   # Verify that the tables have the same structure or something?

   # Design a grouping strategy.  First entry is the last one to be executed
   # -- this goes from fine-grained to coarse-grained.
   my @groupings = map {
      { cols => [$_] }
   } $opts{g} =~ m/(\w+)/g;
   die "You must define some groupings." unless @groupings;

   # Begin the recursion
   topdown_recurse($#groupings, \@groupings, {});
}

sub topdown_recurse {
   my ( $level, $groupings, $where ) = @_;

   # Get the differences.  Must fetch all into memory before trying to
   # recurse, so we can detect if too many groups have differences and we
   # should abort.
   my $grp     = $groupings->[$level]->{cols};
   my $query   = grouped_checksum_query($grp, {});

   # Figure out which groups are different from source to dest.
   my %diffs;
   my $sth = $dbh_s->prepare($query);
   $sth->execute;
   while ( my $row = $sth->fetchrow_hashref ) {
      my $key = join('#', @{$row}{@$grp});
      $row->{_act_} = 'INSERT';
      $diffs{$key} = $row;
   }
   $sth = $dbh_d->prepare($query);
   $sth->execute;
   while ( my $row = $sth->fetchrow_hashref ) {
      my $key = join('#', @{$row}{@$grp});
      if ( $diffs{$key} ) {
         if ( $diffs{$key}->{crc} eq $row->{crc} ) {
            delete $diffs{$key};
         }
         else {
            $diffs{$key}->{_act_} = 'UPDATE';
         }
      }
      else {
         $row->{_act_} = 'DELETE';
         $diffs{$key} = $row;
      }
   }

   if ( %diffs ) {
      foreach my $key ( sort keys %diffs ) {
         my $row = $diffs{$key};
         my %new_where = %$where;
         @new_where{@$grp} = @{$row}{@$grp};
         if ( $level ) {
            # TODO
            # INS/UPD/DEL
            # recurse_topdown($level - 1, $groupings, \%new_where);
         }
         else {
            if ( $row->{_act_} eq 'DELETE' ) {
               # Deletes can be handled with a single query...
               handle_data_change('DELETE', $row, \%new_where, $row->{cnt});
            }
            else {
               # ... but updates and inserts must be done a row at a time.
               topdown_bottom_out($row, \%new_where);
            }
         }
      }
   }
}

# $row is not a row in the table -- it's a row from one of the grouped
# checksum queries.
sub topdown_bottom_out {
   my ( $row, $where ) = @_;
   my @pks   = @{$tbl_s->{keys}->{PRIMARY}};
   my $query = ungrouped_checksum_query(\@pks, $where);

   # Figure out which rows in the TABLE are different from source to dest (at
   # this point we have drilled down to row-level diffs and are not working on
   # aggregated checksums anymore).
   my %diffs; # Each entry is a row in the table.
   my $num_src = 0;
   my $num_dst = 0;

   my $sth = $dbh_s->prepare($query);
   $sth->execute;
   while ( my $row = $sth->fetchrow_hashref ) {
      my $key = join('#', @{$row}{@pks});
      $row->{_act_} = 'INSERT';
      $diffs{$key} = $row;
      $num_src++;
   }

   $sth = $dbh_d->prepare($query);
   $sth->execute;
   while ( my $row = $sth->fetchrow_hashref ) {
      my $key = join('#', @{$row}{@pks});
      if ( $diffs{$key} ) {
         if ( $diffs{$key}->{crc} eq $row->{crc} ) {
            delete $diffs{$key};
         }
         else {
            $diffs{$key}->{_act_} = 'UPDATE';
         }
      }
      else {
         $row->{_act_} = 'DELETE'; # TODO: name _act_ something more magical
         $diffs{$key} = $row;
      }
      $num_dst++;
   }

   if ( %diffs ) {
      if ( $opts{x} =~ m/x|p/ ) { # Do the changes
         foreach my $key ( sort keys %diffs ) {
            my $row = $diffs{$key};
            my %where = map { $_ => $row->{$_} } @pks;
            handle_data_change($row->{_act_}, $row, \%where);
         }
      }
      elsif ( $opts{x} =~ m/e/ ) { # Just summarize this group and report
         my %counts;
         map { $counts{$_->{_act_}}++ } values %diffs;
         foreach my $action ( keys %counts ) {
            explain_data_change($action, $row, $where, $counts{$action});
         }
      }
   }

}

# TODO: put in logic to allow it to act on the dest server
sub handle_data_change {
   my ( $action, $row, $where ) = @_;

   my @crit = map {
      $dbh_s->quote_identifier($_) . '=' . $dbh_s->quote($where->{$_})
   } keys %$where;
   my $crit = @crit ? ' WHERE ' . join(' AND ', @crit) : '';

   if ( $action eq 'DELETE' ) {
      my $query = "DELETE FROM $tbl_n$crit";
      if ( $opts{x} =~ m/p/ ) {
         print STDOUT $query, ";\n";
      }
      if ( $opts{x} =~ m/x/ ) {
         $dbh_s->do($query);
      }
   }
   else {
# TODO this might need to be on the other server, and needs other algorithms
      my $query = "REPLACE INTO $tbl_n($tbl_c) VALUES("
         . join(',', map { $dbh_s->quote($row->{$_}) } @{$tbl_s->{cols}}) . ")";

      if ( $opts{x} =~ m/p/ ) {
         print STDOUT $query, ";\n";
# TODO 3 actions: do, explain, print queries
      }
      if ( $opts{x} =~ m/x/ ) {
         my $row = $dbh_s->selectrow_arrayref("SELECT * FROM $tbl_n$crit");
         # $sth_insupd->execute(@$row);
         # TODO commit?
      }
   }
}

# ############################################################################
# End top-down algorithm
# ############################################################################

# Parses a DSN in login:pass@host:port/database.table format
# TODO: implement 'only compare some columns'
sub parse_dsn {
   my ($dsn, $prev, $defs) = @_;
   return unless $dsn;
   $prev ||= {};
   $defs ||= {};

   my ( $user, $pass, $host, $port, $database, $table ) = $dsn =~ m{
      (?:
         (.*?)       # Username
         (?::(.*))?  # Optional passoword
      @)?            # User-pass is optional
      (?:
         (.*?)       # Hostname
         (?::(.*))?  # Optional port
      /)?            # Host-port is optional
      (?:
         (.*?)       # Database
      \.)?           # Database is optional
      (.*)           # Table is required
      }x or return undef;

   return {
      user     => coalesce( $user,     $prev->{user},     $defs->{user} ),
      pass     => coalesce( $pass,     $prev->{pass},     $defs->{pass} ),
      host     => coalesce( $host,     $prev->{host},     $defs->{host} ),
      port     => coalesce( $port,     $prev->{port},     $defs->{port} ),
      database => coalesce( $database, $prev->{database}, $defs->{database} ),
   };
}

# TODO: make a SELECT FOR UPDATE option so no table locks needed
sub ungrouped_checksum_query {
   my ( $primary_key, $where ) = @_;

   # To handle nulls, make a bitmap of nullable columns that are null.
   my $null = @{$tbl_s->{null}}
            ? (", CONCAT(" . join(', ', map { "ISNULL(`$_`)" } @{$tbl_s->{null}}) .  ")")
            : '';
   my $pks  = join(', ', map { $dbh_s->quote_identifier($_) } @$primary_key);
   my @crit = map {
      $dbh_s->quote_identifier($_) . '=' . $dbh_s->quote($where->{$_})
   } keys %$where;
   my $crit = @crit ? join(' AND ', @crit) : '1 = 1';

   # Make the query.
   my $query = <<"   END";

      select $pks, MD5(CONCAT_WS('#', $tbl_c$null)) AS crc
      FROM $tbl_n
      WHERE $crit

   END

   return ( $query );
}

sub grouped_checksum_query {
   my ( $groupby, $where ) = @_;

   # To handle nulls, make a bitmap of nullable columns that are null.
   my $null = @{$tbl_s->{null}}
            ? (", CONCAT(" . join(', ', map { "ISNULL(`$_`)" } @{$tbl_s->{null}}) .  ")")
            : '';
   my $grp  = join(', ', map { $dbh_s->quote_identifier($_) } @$groupby);
   my @crit = map {
      $dbh_s->quote_identifier($_) . '=' . $dbh_s->quote($where->{$_})
   } keys %$where;
   my $crit = @crit ? join(' AND ', @crit) : '1 = 1';

   # Make the query.
   my $query = <<"   END";

      select $grp, COUNT(*) AS cnt,
         CONCAT(
            LPAD(CONV(BIT_XOR(CONV(SUBSTRING(\@CRC
                                                    := MD5(CONCAT_WS('#', $tbl_c$null)),
                                                    1,  16), 16, 10)), 10, 16), 16, '0'),
            LPAD(CONV(BIT_XOR(CONV(SUBSTRING(\@CRC, 17, 16), 16, 10)), 10, 16), 16, '0')
         ) AS crc
      FROM $tbl_n
      WHERE $crit
      GROUP BY $grp

   END

   return ( $query );
}

sub get_tbl_struct {
   my $ddl = ($dbh_s->selectrow_array("SHOW CREATE TABLE $tbl_n"))[1];
   my @defs = $ddl =~ m/^(\s+`.*)$/gm;
   my @cols = map { $_ =~ m/`([^`]+)`/g } @defs;
   my @null = map { $_ =~ m/`([^`]+)`/g } grep { $_ !~ m/NOT NULL/ } @defs;
   my @keys =
      map {
         my ($name) = $_ =~ m/(PRIMARY|`[^`]*`)/;
         my ($cols) = $_ =~ m/\((.+)\),?$/;
         $name =~ s/`//g;
         ($name, [ grep { m/[^,]/ } split('`', $cols) ])
      }
      $ddl =~ m/^  ((?:PRIMARY )?KEY .*)$/gm;

   return {
      cols => \@cols,
      null => \@null,
      keys => { @keys },
   };
}

sub get_dbh {
   my ( $conn ) = @_;
   return DBI->connect(
      "DBI:mysql:$conn->{database};host=$conn->{host};port=$conn->{port}",
      $conn->{user}, $conn->{pass},
      { RaiseError => 1, PrintError => 1, AutoCommit => $opts{k} ? 0 : 1 } )
      or die("Can't connect to DB: $!");
}

sub do_var_crc {
   my ( $dbh, $query ) = @_;
   $dbh->do('set @crc := "", @cnt := 0');
   $dbh->do($query);
   return @{$dbh->selectall_arrayref('select @cnt, @crc')->[0]};
}

sub do_count {
   my ( $dbh, $info ) = @_;
   return $dbh->selectall_arrayref(
      "SELECT COUNT(*) FROM $info->{database}.$info->{table}$opts{s}"
   )->[0]->[0];
}

sub unique {
   my %seen;
   grep { !$seen{$_}++ } @_;
}

sub coalesce {
   my $i = 0;
   while ( $i < @_ && !defined $_[$i] ) {
      $i++;
   }
   return $_[$i];
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-table-checksum - Print checksums for MySQL tables on one or many servers.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

=head1 OVERVIEW

=head1 OUTPUT

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
