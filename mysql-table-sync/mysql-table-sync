#!/usr/bin/perl

# TODO examine why md5 returns values like 7FFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF and
# 44AB717791FDA9610000000000000000

# This program synchronizes data between two MySQL tables, which need not be
# on the same server.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use Data::Dumper;
use DBI;
use English qw(-no_match_vars);
use Getopt::Long;

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

# ############################################################################
# Get configuration information.
# ############################################################################

# Define cmdline args; each is GetOpt::Long spec, whether required,
# human-readable description.  Add more hash entries as needed.
my %opt_spec = (
   l => { s => 'help',           d => 'Show this help message' },
   a => { s => 'algorithm|a=s',  d => 'Sync algorithm to use' },
   p => { s => 'print|p',        d => 'Print all sync queries to STDOUT' },
   e => { s => 'explain|e=i',    d => 'Explain changes at recursion levels 0..n' },
   x => { s => 'execute|x',      d => 'Execute queries required to sync' },
   g => { s => 'grouping|g=s',   d => 'Grouping for recursion in top-down algorithm' },
   m => { s => 'master|m',       d => 'Change on master (source) and let replication propagate'},
# TODO:
# Allow using a different key than primary key
# Allow to specify which columns
# Verify that the grouping isn't just the whole primary key

);

# Define the order cmdline opts will appear in help output.  Add any extra ones
# defined above.  If it's not in this list, it's not an option to this
# program.  Note that 'h' is host and 'l' is help.
my @opt_keys = qw( l a p e x g m );

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   l => 0,
   a => 'topdown',
   p => 0,
   e => 0,
   x => 0,
   g => '',
   m => '',
);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => \$opts{$_} }  @opt_keys );

# ############################################################################
# Try to use the user's .my.cnf file.
# ############################################################################
my $my_cnf = {
   host => 'localhost',
   user => getlogin() || getpwuid($UID),
   port => 3306,
};
eval {
   my $homedir = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '';
   my $filename = "$homedir/.my.cnf";
   if ( -f $filename ) {
      open my $conf_file, "<", "$homedir/.my.cnf" or die $OS_ERROR;
      while ( my $line = <$conf_file> ) {
         chomp $line;
         $line =~ s/(^\s*)|(\s*#.*$)//g;
         next unless $line;
         my ( $key, $val ) = split( /\s*=\s*/, $line );
         next unless defined $val;
         if ( $key eq 'host' )     { $my_cnf->{host} = $val; }
         if ( $key eq 'user' )     { $my_cnf->{user} = $val; }
         if ( $key =~ m/^pass/ )   { $my_cnf->{pass} = $val; }
         if ( $key eq 'database' ) { $my_cnf->{database} = $val; }
         if ( $key eq 'port' )     { $my_cnf->{port} = $val; }
      }
      close $conf_file;
   }
};

# ############################################################################
# Parse arguments saying which tables.  If the script doesn't have everything
# it needs, how help text.
# ############################################################################
my $source = parse_dsn(shift(@ARGV), {},      $my_cnf);
my $dest   = parse_dsn(shift(@ARGV), $source, $my_cnf);

if ( $opts{l} || !$dest ) {
   print "Usage: $PROGRAM_NAME [OPTION].. <source> <dest>\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^=]*))?/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME finds and resolves data differences between two MySQL tables.
<source> and <dest> are data sources in the format
   user:pass\@host:port/database.table
Everything but the table name is optional, and defaults will be read from your
environment and your .my.cnf file if possible.  Values for <dest> default to the
values for <source>.

For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Lookup tables
# ############################################################################
my %code_for_algorithm = (
   topdown => \&topdown,
);

# ############################################################################
# Do the work.
# ############################################################################
my $exit_status = 0;

foreach my $table ( $source, $dest ) {
   my $dbh = get_dbh($table);
   $table->{dbh} = $dbh;
   $table->{db_tbl} =
      join('.',
      map  {  $dbh->quote_identifier($_) }
      grep { $_ }
      ( $table->{database}, $table->{table} ));
   $table->{info} = get_tbl_struct($table);
   $table->{cols} =
      join(', ',
      map  { $dbh->quote_identifier($_) }
      @{$table->{info}->{cols}});
}

if ( $code_for_algorithm{$opts{a}} ) {
   $code_for_algorithm{$opts{a}}->();
}
else {
   die "Sorry, algorithm '$opts{a}' unknown; try one of "
      . join('|', keys %code_for_algorithm);
}

exit $exit_status;

# ############################################################################
# Top-down algorithm
# ############################################################################

sub topdown {

   # Design a grouping strategy.
   my @groupings = map {
      { cols => [$_] }
   } $opts{g} =~ m/(\w+)/g;
   # TODO: check groupings are valid columns
   die "You must define some groupings." unless @groupings;

   # Begin the recursion
   topdown_recurse(0, \@groupings, {});
}

# Figure out which groups are different between source and dest.
sub topdown_recurse {
   my ( $level, $groupings, $where ) = @_;

   my $grouping  = $groupings->[$level]->{cols};
   my $src_query = grouped_checksum_query($source, $grouping, $where);
   my $dst_query = grouped_checksum_query($dest,   $grouping, $where);
   my $src_cnt   = 0;
   my $dst_cnt   = 0;
   my %diffs;

   # Fetch from source:
   my $src_sth = $source->{dbh}->prepare($src_query);
   $src_sth->execute;
   while ( my $row = $src_sth->fetchrow_hashref ) {
      my $key = make_key($row, $grouping);
      $row->{_act_} = 'INSERT';
      $diffs{$key} = $row;
      $src_cnt++;
   }

   # Fetch from dest:
   my $dst_sth = $dest->{dbh}->prepare($dst_query);
   $dst_sth->execute;
   while ( my $row = $dst_sth->fetchrow_hashref ) {
      my $key = make_key($row, $grouping);
      if ( $diffs{$key} ) {
         if ( $diffs{$key}->{crc} eq $row->{crc} ) {
            delete $diffs{$key};
         }
         else {
            $diffs{$key}->{_act_} = 'UPDATE';
         }
      }
      else {
         $row->{_act_} = 'DELETE';
         $diffs{$key} = $row;
      }
      $dst_cnt++;
   }

   if ( $opts{e} > $level ) {
      print join(' ', '-- LEVEL', $level + 1, $src_cnt, $dst_cnt,
         scalar(keys %diffs), make_where_clause($source->{dbh}, $where)), "\n";
   }

   if ( %diffs ) {
      foreach my $key ( sort keys %diffs ) {
         my $row = $diffs{$key};
         my %new_where = %$where;
         @new_where{@$grouping} = @{$row}{@$grouping};

         if ( $row->{_act_} eq 'DELETE' ) {
            # Deletes can be handled with a single query, pruning this whole
            # section of the recursion tree.
            handle_data_change('DELETE', $row, \%new_where, $row->{cnt});
         }
         elsif ( $level < $#{$groupings} ) {
            # There is more recursion to do.
            topdown_recurse($level + 1, $groupings, \%new_where);
         }
         else {
            # Non-recursed update/insert must be done a row at a time.
            topdown_bottom_out($level + 1, $row, \%new_where);
         }
      }
   }

}

# $row is not a row in the table -- it's a row from one of the grouped
# checksum queries.  But it is only one level removed from the individual rows
# in the table, hence the name bottom_out.
sub topdown_bottom_out {
   my ( $level, $row, $where ) = @_;

   my @key       = @{$source->{info}->{keys}->{PRIMARY}}; #TODO could be another key
   my $src_query = ungrouped_checksum_query($source, \@key, $where);
   my $dst_query = ungrouped_checksum_query($dest,   \@key, $where);
   my $src_cnt   = 0;
   my $dst_cnt   = 0;
   my %diffs; # Each entry is a row in the table.

   # Fetch from source:
   my $src_sth = $source->{dbh}->prepare($src_query);
   $src_sth->execute;
   while ( my $row = $src_sth->fetchrow_hashref ) {
      my $key = make_key($row, \@key);
      $row->{_act_} = 'INSERT';
      $diffs{$key} = $row;
      $src_cnt++;
   }

   # Fetch from dest:
   my $dst_sth = $dest->{dbh}->prepare($dst_query);
   $dst_sth->execute;
   while ( my $row = $dst_sth->fetchrow_hashref ) {
      my $key = make_key($row, \@key);
      if ( $diffs{$key} ) {
         if ( $diffs{$key}->{crc} eq $row->{crc} ) {
            delete $diffs{$key};
         }
         else {
            $diffs{$key}->{_act_} = 'UPDATE';
         }
      }
      else {
         $row->{_act_} = 'DELETE';
         $diffs{$key} = $row;
      }
      $dst_cnt++;
   }

   if ( %diffs ) {

      explain_data_change($level, \%diffs, $where) if $opts{e} > $level;

      foreach my $key ( sort keys %diffs ) {
         my $row = $diffs{$key};
         my %new_where = %$where;
         @new_where{@key} = @{$row}{@key};
         handle_data_change($row->{_act_}, $row, \%new_where);
      }
   }
}

# TODO: print out headers and a key.  Maybe make the format a global.
sub explain_data_change {
   my ( $level, $diffs, $where ) = @_;
   my %counts;
   map { $counts{$_->{_act_}}++ } values %$diffs;
   foreach my $action ( keys %counts ) {
      print join(' ', '--', $action, scalar(keys %$diffs),
      make_where_clause($source->{dbh}, $where)), "\n";
   }
}

# TODO: put in logic to allow it to act on the dest server
      # TODO this might need to be on the other server, and needs other algorithms
sub handle_data_change {
   my ( $action, $row, $where ) = @_;

   my $which = $opts{m} ? $source : $dest; # TODO
   my $crit = make_where_clause($which->{dbh}, $where);

   if ( $action eq 'DELETE' ) {
      my $query = "DELETE FROM $which->{db_tbl}$crit";
      if ( $opts{p} ) {
         print STDOUT $query, ";\n";
      }
      if ( $opts{x} ) {
         $which->{dbh}->do($query);
      }
   }
   else {
      my $vals = $source->{dbh}->selectrow_hashref("SELECT * FROM $source->{db_tbl}$crit");
      my $query = "REPLACE INTO $which->{db_tbl}($which->{cols}) VALUES("
         . join(',', map { $which->{dbh}->quote($vals->{$_}) } @{$which->{info}->{cols}}) . ")";

      if ( $opts{p} ) {
         print STDOUT $query, ";\n";
      }
      if ( $opts{x} ) {
         $which->{dbh}->do($query);
         # TODO commit?
      }
   }
}

# ############################################################################
# End top-down algorithm
# ############################################################################

# Parses a DSN in login:pass@host:port/database.table format
# TODO: implement 'only compare some columns'
sub parse_dsn {
   my ($dsn, $prev, $defs) = @_;
   return unless $dsn;
   $prev ||= {};
   $defs ||= {};

   my ( $user, $pass, $host, $port, $database, $table ) = $dsn =~ m{
      (?:
         (.*?)       # Username
         (?::(.*))?  # Optional passoword
      @)?            # User-pass is optional
      (?:
         (.*?)       # Hostname
         (?::(.*))?  # Optional port
      /)?            # Host-port is optional
      (?:
         (.*?)       # Database
      \.)?           # Database is optional
      (.*)           # Table is required
      }x or return undef;

   return {
      user     => coalesce( $user,     $prev->{user},     $defs->{user} ),
      pass     => coalesce( $pass,     $prev->{pass},     $defs->{pass} ),
      host     => coalesce( $host,     $prev->{host},     $defs->{host} ),
      port     => coalesce( $port,     $prev->{port},     $defs->{port} ),
      database => coalesce( $database, $prev->{database}, $defs->{database} ),
      table    => coalesce( $table,    $prev->{table} ),
   };
}

# TODO: make a SELECT FOR UPDATE option so no table locks needed
sub ungrouped_checksum_query {
   my ( $info, $key, $where ) = @_;
   my $dbh = $info->{dbh};
   my $tbl = $info->{info};

   # To handle nulls, make a bitmap of nullable columns that are null.
   my $null = @{$tbl->{null}}
            ? (", CONCAT(" . join(', ', map { "ISNULL(`$_`)" } @{$tbl->{null}}) .  ")")
            : '';
   my $key_cols  = join(', ', map { $dbh->quote_identifier($_) } @$key);
   my $crit = make_where_clause($dbh, $where);

   # Make the query.
   my $query = <<"   END";

      SELECT $key_cols, MD5(CONCAT_WS('#', $info->{cols}$null)) AS crc
      FROM $info->{db_tbl}
      $crit

   END
   return ( $query );
}

# TODO: can eliminate any $where columns from the query
sub grouped_checksum_query {
   my ( $info, $groupby, $where ) = @_;
   my $dbh = $info->{dbh};
   my $tbl = $info->{info};

   # To handle nulls, make a bitmap of nullable columns that are null.
   my $null = @{$tbl->{null}}
            ? (", CONCAT(" . join(', ', map { "ISNULL(`$_`)" } @{$tbl->{null}}) .  ")")
            : '';
   my $grp  = join(', ', map { $dbh->quote_identifier($_) } @$groupby);
   my $crit = make_where_clause($dbh, $where);

   # Make the query.
   my $query = <<"   END";

      SELECT $grp, COUNT(*) AS cnt,
         CONCAT(
            LPAD(CONV(BIT_XOR(CONV(SUBSTRING(\@CRC
                                                    := MD5(CONCAT_WS('#', $info->{cols}$null)),
                                                    1,  16), 16, 10)), 10, 16), 16, '0'),
            LPAD(CONV(BIT_XOR(CONV(SUBSTRING(\@CRC, 17, 16), 16, 10)), 10, 16), 16, '0')
         ) AS crc
      FROM $info->{db_tbl}
      $crit
      GROUP BY $grp

   END

   return ( $query );
}

sub get_tbl_struct {
   my ( $info ) = @_;
   my $ddl = ($info->{dbh}->selectrow_array("SHOW CREATE TABLE $info->{db_tbl}"))[1];
   my @defs = $ddl =~ m/^(\s+`.*)$/gm;
   my @cols = map { $_ =~ m/`([^`]+)`/g } @defs;
   my @null = map { $_ =~ m/`([^`]+)`/g } grep { $_ !~ m/NOT NULL/ } @defs;
   my @keys =
      map {
         my ($name) = $_ =~ m/(PRIMARY|`[^`]*`)/;
         my ($cols) = $_ =~ m/\((.+)\),?$/;
         $name =~ s/`//g;
         ($name, [ grep { m/[^,]/ } split('`', $cols) ])
      }
      $ddl =~ m/^  ((?:PRIMARY )?KEY .*)$/gm;

   return {
      cols => \@cols,
      null => \@null,
      keys => { @keys },
   };
}

sub make_where_clause {
   my ( $dbh, $where ) = @_;
   my @clauses = map {
      my $val = $where->{$_};
      my $sep = defined $val ? ' = ' : ' IS ';
      $dbh->quote_identifier($_) . $sep . $dbh->quote($val);
   } keys %$where;
   my $clause = @clauses ? 'WHERE ' . join(' AND ', @clauses) : '';
   return $clause;
}

sub make_key {
   my ( $row, $cols ) = @_;
   return join('#', map { defined $row->{$_} ? $row->{$_} : 'NULL' } @$cols);
}

sub get_dbh {
   my ( $conn ) = @_;
   return DBI->connect(
      "DBI:mysql:$conn->{database};host=$conn->{host};port=$conn->{port}",
      $conn->{user}, $conn->{pass},
      { RaiseError => 1, PrintError => 1, AutoCommit => $opts{k} ? 0 : 1 } )
      or die("Can't connect to DB: $!");
}

sub do_var_crc {
   my ( $dbh, $query ) = @_;
   $dbh->do('set @crc := "", @cnt := 0');
   $dbh->do($query);
   return @{$dbh->selectall_arrayref('SELECT @cnt, @crc')->[0]};
}

sub do_count {
   my ( $dbh, $info ) = @_;
   return $dbh->selectall_arrayref(
      "SELECT COUNT(*) FROM $info->{database}.$info->{table}$opts{s}"
   )->[0]->[0];
}

sub unique {
   my %seen;
   grep { !$seen{$_}++ } @_;
}

sub coalesce {
   my $i = 0;
   while ( $i < @_ && !defined $_[$i] ) {
      $i++;
   }
   return $_[$i];
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-table-checksum - Print checksums for MySQL tables on one or many servers.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

=head1 OVERVIEW

=head1 OUTPUT

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
