#!/usr/bin/perl

# TODO: convert top-down to iteration and proper comparison.
# Advantage of bottom-up: parts can be parallelized
# Advantage of top-down: locking tables is easier.
# TODO: put acknowledgements in the perdoc
# cite: Remote Comparison of Database Tables
# Explain structure of tables, what __rem/__par mean etc
# top-down with where clauses allows mass insert/deletes much more efficiently.
# Look up the law of large numbers and justify why not to use SUM()
# Explain why @crc & $mask is the same as mod()
# Allow a threshold of expensiveness
# TODO: another algorithm: binary search for where the corruption starts, say a
# chunk at a time of 10000 from start/end of table, then when a different chunk is
# found, binary search within that chunk to find the first row and report it.

# This program efficiently synchronizes data between two MySQL tables, which
# can be on different servers.
#
# This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

use DBI;
use English qw(-no_match_vars);
use Getopt::Long;
use List::Util qw(sum max);
use POSIX qw(ceil);

our $VERSION = '@VERSION@';

$OUTPUT_AUTOFLUSH = 1;

my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime(time);

# ############################################################################
# Get configuration information.
# ############################################################################

my %opt_spec = (
   h => { s => 'help|h',           d => 'Show this help message' },
   a => { s => 'algorithm|a=s',    d => 'Algorithm to use (topdown, bottomup)' },
   e => { s => 'separator|e=s',    d => 'Separator for CONCAT_WS' },
   p => { s => 'print|p',          d => 'Print all sync queries to STDOUT' },
   b => { s => 'debug|b',          d => 'Print debugging output to STDOUT' },
   v => { s => 'verbose|v+',       d => 'Explain differences found' },
   x => { s => 'execute|x',        d => 'Execute queries required to sync' },
   o => { s => 'onlydo|o=s',       d => 'Only do INS/UPD/DEL (default: all)' },
   m => { s => 'maxcost|m=i',      d => 'Maximum rowcount before bailing out' },
   s => { s => 'strategy|s=s',     d => 'Query strategy when syncing' },
   d => { s => 'drilldown|d=s',    d => 'Drilldown groupings for top-down algorithm' },
   r => { s => 'replicate|r',      d => 'Change on master. Implies --strategy=r'},
   f => { s => 'forupdate|f',      d => 'Use SELECT FOR UPDATE for checksums' },
   c => { s => 'columns|c=s',      d => 'Comma-separated column list' },
   k => { s => 'lock|k',           d => 'Lock tables when beginning work' },
   w => { s => 'wait|w=i',         d => 'Make slave wait for master pos (implies --lock)' },
   B => { s => 'branchfactor|B=i', d => 'Branch factor for bottom-up algorithm' },
   P => { s => 'prefix|P=s',       d => 'Tablename prefix for bottom-up algorithm' },
   E => { s => 'engine|E=s',       d => 'Storage engine for bottom-up tables' },
   T => { s => 'temp|T=s',         d => 'Use temporary tables in bottom-up algorithm' },
   S => { s => 'size|S=i',         d => 'Table size in bottom-up algorithm' },
   U => { s => 'build|U!',         d => 'Build tables for bottom-up algorithm' },
   A => { s => 'analyze|A',        d => 'Analyze (find/fix/print) in bottom-up algorithm' },
   C => { s => 'cleanup|C!',       d => 'Clean up scratch tables for bottom-up algorithm' },
);

my @opt_keys = qw( h a e p b v x o m s d r f c k w B P E T S U A C );

# Generate a quasi-random string that's constant in a given day
# TODO: does this work on windows?
my $prefix = '__cmp' . crypt(sprintf('%d%02d%02d', $year + 1900, $mon, $mday), '00');
$prefix =~ s/\W+/_/g;

# This is the container for the command-line options' values to be stored in
# after processing.  Initial values are defaults.
my %opts = (
   h => 0,
   a => 'topdown',
   e => '#',
   p => 0,
   b => 0,
   v => 0,
   x => 0,
   o => 'INSUPDDEL',
   m => 0,
   s => 's',
   d => '',
   r => 0,
   f => 0,
   c => '',
   k => 0,
   w => 0,
   B => 128,
   P => $prefix,
   E => 'InnoDB',
   T => '',
   S => 0,
   U => 1,
   A => 1,
   C => undef,
);

# ############################################################################
# Get and process options
# ############################################################################

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions( map { $opt_spec{$_}->{s} => \$opts{$_} }  @opt_keys )
   or $opts{h} = 1;

$opts{h} = 1 if $opts{s} && $opts{s} !~ m/^(s|r)/;
$opts{k} ||= $opts{w};

# Make comma-separated lists into hashes.
if ( $opts{c} ) {
   $opts{c} = { map { $_ => 1 } split(/,\s*/, $opts{c}) };
}
$opts{T} = $opts{T} ? 'TEMPORARY' : '';
if ( !defined $opts{C} ) {
   $opts{C} = !$opts{T};
}
if ( $opts{r} ) {
   $opts{s} = 'r';
}
$opts{o} = lc(join('|', $opts{o} =~ m/(\w{3})/g));

# ############################################################################
# Try to use the user's .my.cnf file.
# ############################################################################
my $dsn_defaults = {
   host => 'localhost',
   user => getlogin() || getpwuid($UID),
   port => 3306,
   key  => 'PRIMARY',
};
eval {
   my $homedir = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '';
   my $filename = "$homedir/.my.cnf";
   if ( -f $filename ) {
      open my $conf_file, "<", "$homedir/.my.cnf" or die $OS_ERROR;
      while ( my $line = <$conf_file> ) {
         chomp $line;
         $line =~ s/(^\s*)|(\s*#.*$)//g;
         next unless $line;
         my ( $key, $val ) = split( /\s*=\s*/, $line );
         next unless defined $val;
         if ( $key eq 'host' )     { $dsn_defaults->{host} = $val; }
         if ( $key eq 'user' )     { $dsn_defaults->{user} = $val; }
         if ( $key =~ m/^pass/ )   { $dsn_defaults->{pass} = $val; }
         if ( $key eq 'database' ) { $dsn_defaults->{database} = $val; }
         if ( $key eq 'port' )     { $dsn_defaults->{port} = $val; }
      }
      close $conf_file;
   }
};

# ############################################################################
# Parse arguments saying which tables.  If the script doesn't have everything
# it needs, show help text.
# ############################################################################
my $source = parse_dsn(shift(@ARGV), {},      $dsn_defaults);
my $dest   = parse_dsn(shift(@ARGV), $source, $dsn_defaults);

if ( $opts{h} || !$dest ) {
   print "Usage: $PROGRAM_NAME [OPTION].. <source> <dest>\n\n  Options:\n\n";
   foreach my $key ( @opt_keys ) {
      my ( $long, $short ) = $opt_spec{$key}->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
      $long  = "[no]$long" if $opt_spec{$key}->{s} =~ m/!/;
      $long  = "--$long" . ( $short ? ',' : '' );
      $short = $short ? " -$short" : '';
      printf("  %-13s %-4s %s\n", $long, $short, $opt_spec{$key}->{d});
   }
   print <<USAGE;

$PROGRAM_NAME finds and resolves data differences between two MySQL tables.
<source> and <dest> are data sources in the format
   user:pass\@host:port/database.table:key
Everything but the table name is optional, and defaults will be read from your
environment and your .my.cnf file if possible.  Values for <dest> default to the
values for <source>.

For more details, please read the documentation:

   perldoc $PROGRAM_NAME

USAGE
   exit(1);
}

# ############################################################################
# Lookup tables
# ############################################################################
my %code_for_algorithm = (
   topdown  => \&topdown,
   bottomup => \&bottomup,
);

# ############################################################################
# Do the work.
# ############################################################################
my $exit_status = 0;

foreach my $table ( $source, $dest ) {
   my $dbh = get_dbh($table);
   $table->{dbh} = $dbh;
   $table->{db_tbl} =
      join('.',
      map  {  $dbh->quote_identifier($_) }
      grep { $_ }
      ( $table->{database}, $table->{table} ));
   $table->{info} = get_tbl_struct($table);
   $table->{cols} = col_list(@{$table->{info}->{cols}});
}

if ( $opts{k} && $opts{a} eq 'topdown' ) {
   if ( $opts{v} ) {
      print "-- Locking table on source\n";
   }
   my $query = "LOCK TABLES $source->{db_tbl} READ";
   debug_print($query);
   $source->{dbh}->do($query);
   if ( $opts{v} ) {
      print "-- Acquired table lock on source\n";
   }
}

if ( $opts{w} ) {
   my $query = 'SHOW MASTER STATUS';
   debug_print($query);
   my $ms = $source->{dbh}->selectrow_hashref($query);
   if ( $opts{v} ) {
      print "-- Waiting for destination to catch up in binlog\n";
   }
   $query = "SELECT MASTER_POS_WAIT('$ms->{File}', $ms->{Position}, $opts{w})";
   debug_print($query);
   my $stat = $dest->{dbh}->selectall_arrayref($query)->[0]->[0];
   $stat = 'NULL' unless defined $stat;
   if ( $opts{v} ) {
      print "-- Result of waiting: $stat\n";
   }
}

if ( $code_for_algorithm{$opts{a}} ) {
   $code_for_algorithm{$opts{a}}->();
}
else {
   die "Sorry, algorithm '$opts{a}' unknown; try one of "
      . join('|', keys %code_for_algorithm);
}

foreach my $table ( $source, $dest ) {
   my $dbh = $table->{dbh};
   $dbh->commit if $opts{k};
   $dbh->disconnect;
}

exit $exit_status;

# ############################################################################
# Top-down algorithm
# ############################################################################

sub topdown {

   # Design a grouping strategy: user-defined, then finally primary key.
   my @groupings = { cols => $source->{info}->{keys}->{$source->{key}} };
   if ( $opts{d} ) {
      push @groupings, map { { cols => [$_] } } $opts{d} =~ m/(\w+)/g;
   }

   # Array indices
   my ($WHERE, $LEVEL, $COUNT) = (0, 1, 2);

   # Queue of groups to drill into on next iteration.  Managing as a queue, not
   # stack, is breadth-first search, not depth-first.
   my @to_examine = [ {}, $#groupings, 0 ]; # TODO --where applies here

   # Lists of rows that differ in the target tables.
   my (@to_update, @to_delete, @to_insert);

   # Counters
   my %count = map { $_ => 0 } qw(ins upd del bad);

   do {
      my $work  = shift @to_examine;
      my $level = $work->[$LEVEL];
      my $where = $work->[$WHERE];

      my $grouping = $groupings[$level]->{cols};
      my $src_sth  = td_fetch_level($source, $level, $grouping, $where);
      my $dst_sth  = td_fetch_level($dest,   $level, $grouping, $where);

      my ($sr, $dr);       # Source row, dest row
      my %this_level = ( rows => 0, cnt => 0 );

      # The statements fetch in order, so use a 'merge' algorithm of advancing
      # after rows match.  This is essentially a FULL OUTER JOIN.
      MERGE:
      while ( 1 ) { # Exit this loop via 'last'

         if ( !$sr ) {
            $sr = $src_sth->fetchrow_hashref;
         }
         if ( !$dr ) {
            $dr = $dst_sth->fetchrow_hashref;
         }

         last MERGE unless $sr || $dr;

         my %new_where = %$where;  # Will get more cols added and used below.

         # If the current row is the "same row" on both sides...
         if ( $sr && $dr && key_eq($source, $sr, $dr, $grouping) ) {
            # The "same" row descends from parents that differ.
            if ( $sr->{__crc} ne $dr->{__crc} ) {
               @new_where{@$grouping} = @{$sr}{@$grouping};
               if ( $level ) {
                  # Special case: push $level - 1 because this will be processed
                  # later.
                  push @to_examine, [ \%new_where, $level - 1, $sr->{__cnt} ];
                  $this_level{cnt}++;
                  $this_level{rows} += $sr->{__cnt};
                  if ( $level && $opts{v} > 2 ) {
                     printf("-- Level %1d: CHECK  group of  %4d rows %s\n",
                        $level, $sr->{__cnt}, make_where_clause($source->{dbh}, \%new_where));
                  }
               }
               else {
                  push @to_update, \%new_where;
                  $count{upd}++;
                  $count{bad}++;
                  if ( $opts{v} > 2 ) {
                     printf("-- Level %1d: UPDATE             1 row  %s\n",
                        $level, make_where_clause($source->{dbh}, \%new_where));
                  }
               }
            }
            $sr = $dr = undef;
         }

         # The row in the source doesn't exist at the destination
         elsif ( !$dr || ( $sr && key_le($source, $sr, $dr, $grouping) ) ) {
            @new_where{@$grouping} = @{$sr}{@$grouping};
            push @to_insert, \%new_where;
            $count{ins} += $sr->{__cnt} || 1;
            $count{bad} += $sr->{__cnt} || 1;
            if ( $level && $opts{v} > 2 ) {
               printf("-- Level %1d: INSERT group of  %4d rows %s\n",
                  $level, $sr->{__cnt}, make_where_clause($source->{dbh}, \%new_where));
            }
            $sr = undef;
         }

         # Symmetric to the above
         elsif ( !$sr || ( $dr && key_le($source, $dr, $sr, $grouping) ) ) {
            @new_where{@$grouping} = @{$dr}{@$grouping};
            push @to_delete, \%new_where;
            $count{del} += $dr->{__cnt} || 1;
            $count{bad} += $dr->{__cnt} || 1;
            if ( $level && $opts{v} > 2 ) {
               printf("-- Level %1d: DELETE group of  %4d rows %s\n",
                  $level, $dr->{__cnt}, make_where_clause($source->{dbh}, \%new_where));
            }
            $dr = undef;
         }

         else {
            die "This code should never have run.  This is a bug.";
         }

         if ( $level < $#groupings && $opts{m} && $opts{m} < $count{bad}) {
            print "-- Level $level halt: $count{bad} rows, --maxcost=$opts{m}\n";
            return 0;
         }

      }

      if ( $opts{v} ) {
         printf("--          Level %1d total:   %4d bad rows      %4d to inspect\n",
            $level, $count{bad}, sum(map { $_->[$COUNT] } @to_examine) || 0);
      }
      if ( $opts{v} > 1 ) {
         printf("--          Level %1d summary: %4d bad groups in %4d src groups %4d dst groups\n",
            $level, scalar(@to_examine), $src_sth->rows, $dst_sth->rows);
         printf("--          Level %1d changes: %4d updates       %4d inserts    %4d deletes\n",
            $level, scalar(@to_update), $count{ins}, $count{del});
      }

      $level--;
   } while ( @to_examine );

   td_handle_data_change('INSERT', @to_insert);
   td_handle_data_change('DELETE', @to_delete);
   td_handle_data_change('UPDATE', @to_update);
}

sub td_handle_data_change {
   my ( $action, @rows ) = @_;
   return unless $action =~ m/$opts{o}/i;
   foreach my $where ( @rows ) {
      my $which = $opts{r} ? $source : $dest;
      my $dbh   = $which->{dbh};
      my $crit  = make_where_clause($dbh, $where);
      handle_data_change($action, $crit);
   }
}

sub td_fetch_level {
   my ( $info, $level, $groupby, $where ) = @_;
   my $dbh = $info->{dbh};
   my $tbl = $info->{info};

   # Columns that need to be in the checksum list.
   my @cols = grep { !exists($where->{$_}) } @{$tbl->{cols}};
   if ( $opts{c} ) {
      @cols = grep { exists($opts{c}->{$_}) } @cols;
   }
   my $cols = col_list(@cols);

   # To handle nulls, make a bitmap of nullable columns that are null.
   my @null = grep { $tbl->{null_hash}->{$_} } @cols;
   my $null = @null
            ? (", CONCAT(" . join(', ', map  { "ISNULL(`$_`)" } @null) . ")")
            : '';

   my $grp  = col_list(@$groupby);
   my $crit = make_where_clause($dbh, $where);
   my $lock = $opts{f} ? ' FOR UPDATE' : '';

   my $query;
   if ( $level ) {
      ( $query = <<"      END" ) =~ s/\s+/ /g;
         SELECT /*$info->{db_tbl}*/
            $grp,
            COUNT(*) AS __cnt,
            CONCAT(
               LPAD(CONV(BIT_XOR(
                  CAST(CONV(LEFT(\@CRC := MD5(CONCAT_WS('$opts{e}', $cols$null)), 16), 16, 10) AS UNSIGNED)
                  ), 10, 16), 16, '0'),
               LPAD(CONV(BIT_XOR(
                  CAST(CONV(RIGHT(\@CRC, 16), 16, 10) AS UNSIGNED)
                  ), 10, 16), 16, '0')
            ) AS __crc
         FROM $info->{db_tbl}
         $crit
         GROUP BY $grp
         ORDER BY $grp$lock
      END
   }
   else {
      $query = "SELECT /*$info->{db_tbl}*/ $grp, "
         . "MD5(CONCAT_WS('$opts{e}', $cols$null)) AS __crc "
         . "FROM $info->{db_tbl} $crit "
         . "ORDER BY $grp";
   }
   debug_print($query);

   my $sth = $dbh->prepare($query);
   $sth->execute();
   return $sth;
}

# ############################################################################
# Bottom-up algorithm
# ############################################################################

sub bottomup {

   # Ensure branch factor is a power of two.
   $opts{B} = max(2, 2 ** round( log($opts{B}) / log(2) ));

   # Store table prefix in hashes
   $source->{prefix} = "$opts{P}_s_";
   $dest->{prefix}   = "$opts{P}_d_";

   my $levels = 0;
   if ( $opts{U} ) {

      # Begin with estimates of table size to allow calculating the checksum
      # remainder on the first level.
      my $est_size    = $opts{S} || max( estimate_size($source), estimate_size($dest) );
      my $level_est_1 = bu_num_levels($est_size);

      # Determine the data type needed for the remainder column.
      my $rem_col        = bu_size_to_type(( $opts{B} ** ($level_est_1 + 2)) - 1);
      $source->{rem_col} = $rem_col;
      $dest->{rem_col}   = $rem_col;

      # Build the initial checksum tables and calculate how many summary tables to build.  
      my $src_size    = bu_build_checksum( $source, $level_est_1 );
      my $level_est_2 = bu_num_levels( max( $est_size, $src_size ) );
      my $dst_size    = bu_build_checksum( $dest, $level_est_2 );
      my $true_size   = max( $src_size, $dst_size );
      $levels         = bu_num_levels( $true_size );

      # Similar to the above, choose a type for the __cnt columns
      my $cnt_col        = bu_size_to_type($true_size);
      $source->{cnt_col} = $cnt_col;
      $dest->{cnt_col}   = $cnt_col;

      # Check and possibly rebuild remainders.
      if ( $levels > $level_est_1 + 2 ) {
         # The initial estimated number of levels caused the first-level tables to
         # have too-small data types, and I don't want to run ALTER TABLE; I'd
         # rather ask the user to re-run.
         die "Table size estimates ($est_size) were too small; specify --size $true_size";
      }
      if ( $level_est_1 != $levels ) {
         bu_rebuild_remainder($source, $levels);
      }
      if ( $level_est_2 != $levels ) {
         bu_rebuild_remainder($dest, $levels);
      }

      # Build the trees, merge them, and clean them up. TODO this part can be
      # parallelized with fork.
      bu_build_tree($source, $levels);
      bu_build_tree($dest,   $levels);
   }
   else {
      $levels  = bu_existing_levels( $source );
   }

   my $finished_work = 1;
   if ( $opts{A} ) {
      $finished_work = bu_merge_tree($dest,   $source, $levels);
   }
   bu_cleanup_tree($dest, $source) if $finished_work && $opts{C};
}

# Builds the first-level checksum table and returns the number of rows in it.
sub bu_build_checksum {
   my ($info, $levels) = @_;
   my $dbh    = $info->{dbh};
   my $tbl    = $info->{info};
   my $pk     = col_list( @{ $tbl->{keys}->{$info->{key}} } );
   my @cols   = @{ $tbl->{cols} };
   my $cols   = col_list(@cols);
   my $pks    = join( ',', @{ $tbl->{defs} }{ @{ $tbl->{keys}->{$info->{key}} } } );
   my @null   = grep { $tbl->{null_hash}->{$_} } @cols;
   my $null = @null
            ? ( ", CONCAT(" . join( ', ', map {"ISNULL(`$_`)"} @null ) . ")" ) : '';
   my $name = "$info->{prefix}_0";
   my $mask = ($opts{B} ** ($levels - 1)) - 1;

   # Create the table
   my $query = "DROP TABLE IF EXISTS `$info->{database}`.`$name`";
   debug_print($query);
   $dbh->do($query);
   ( $query = <<"   END") =~ s/\s+/ /g;
      CREATE $opts{T} TABLE `$info->{database}`.`$name` (
         $pks,
         __crc CHAR(32) NOT NULL,
         __rem $info->{rem_col} UNSIGNED NOT NULL,
         KEY(__rem),
         PRIMARY KEY($pk)
      ) ENGINE=$opts{E}
   END
   debug_print($query);
   $dbh->do($query);

   # Populate it
   ( $query = <<"   END") =~ s/\s+/ /g;
      INSERT INTO `$info->{database}`.`$name`($pk, __crc, __rem)
      SELECT $pk,
         MD5(CONCAT_WS('$opts{e}', $cols$null)) AS __crc,
         CAST(CONV(RIGHT(MD5(CONCAT_WS('$opts{e}', $pk)), 16), 16, 10) AS UNSIGNED) & $mask AS __rem
      FROM $info->{db_tbl}
   END
   debug_print($query);
   my $sth = $dbh->prepare($query);
   $sth->execute();
   return $sth->rows;
}

sub bu_rebuild_remainder {
   my ( $info, $levels ) = @_;
   my $pk   = col_list( @{ $info->{info}->{keys}->{$info->{key}} } );
   my $mask = ($opts{B} ** ($levels - 1)) - 1;
   my $name = "$info->{prefix}_0";
   my $query = "UPDATE `$info->{database}`.`$name` SET __rem = "
      . "CAST(CONV(RIGHT(MD5(CONCAT_WS('$opts{e}', $pk)), 8), 16, 10) AS UNSIGNED) & $mask";
   debug_print($query);
   $info->{dbh}->do($query);
}

# Builds the nth-level summary tables.
# TODO: allow to use other hash functions like SHA1, and genericize the substringing code
# and the required size of the columns.
sub bu_build_tree {
   my ($info, $levels) = @_;
   my $dbh = $info->{dbh};
   my $tbl = $info->{info};

   # Do from 1 because level 0 has already been built.
   foreach my $i ( 1 .. $levels ) {
      my $modulo   = int($opts{B} ** ( $levels - $i - 1 ));
      my $last_mod = $modulo * $opts{B};
      my $this_tbl = "$info->{prefix}_" . $i;
      my $last_tbl = "$info->{prefix}_" . ( $i - 1 );
      my $mask     = max(0, $modulo - 1);
      my $cnt_sum  = $i > 1 ? 'SUM(__cnt)' : 'COUNT(*)';

      # Create the table
      my $query = "DROP TABLE IF EXISTS `$info->{database}`.`$this_tbl`";
      debug_print($query);
      $dbh->do($query);
      ( $query = <<"      END" ) =~ s/\s+/ /g;
         CREATE $opts{T} TABLE `$info->{database}`.`$this_tbl` (
            __par INT NOT NULL,
            __crc CHAR(32) NOT NULL,
            __rem $info->{rem_col} UNSIGNED NOT NULL,
            __cnt $info->{cnt_col} UNSIGNED NOT NULL,
            KEY(__rem),
            PRIMARY KEY(__par)
         ) ENGINE=$opts{E}
      END
      debug_print($query);
      $dbh->do($query);

      # Populate it
      ( $query = <<"      END" ) =~ s/\s+/ /g;
         INSERT INTO `$info->{database}`.`$this_tbl`
            (__par, __crc, __rem, __cnt)
         SELECT __rem,
            CONCAT(
               LPAD(CONV(BIT_XOR(CAST(CONV(SUBSTRING(__crc, 1,  16), 16, 10) AS UNSIGNED)), 10, 16), 16, '0'),
               LPAD(CONV(BIT_XOR(CAST(CONV(SUBSTRING(__crc, 17, 16), 16, 10) AS UNSIGNED)), 10, 16), 16, '0')
            ) AS this_crc,
            __rem & $mask AS this_remainder,
            $cnt_sum AS total_rows
         FROM `$info->{database}`.`$last_tbl`
         GROUP BY __rem
         ORDER BY NULL
      END
      debug_print($query);
      $dbh->do($query);
   }
}

# There are actually 1 more than $levels summary tables; there are tables 0 ..
# $levels (see bu_build_tree).  Level 0 has a different structure.  It has
# primary keys instead of a __par pointer.
# Returns true if it finished working.
sub bu_merge_tree {
   my ($dest, $source, $levels) = @_;

   my $level = $levels;
   my @bad_parents; # List of parents that must differ at current level
   my ( $rows_in_src, $rows_in_dst ) = (0,0);

   # Lists of rows that differ in the target tables.
   my (@to_update, @to_delete, @to_insert);
   my (@bulk_insert, @bulk_delete);
   
   # Counters
   my %count = map { $_ => 0 } qw(ins upd del bad);

   do {
      my $src_sth = bu_fetch_level($source, $level, @bad_parents);
      my $dst_sth = bu_fetch_level($dest,   $level, @bad_parents);

      # Reset for next loop, once used to fetch this loop
      @bad_parents = ();
      $rows_in_src = $rows_in_dst = 0;

      my @key = $level ? '__par' : @{$source->{info}->{keys}->{$source->{key}}};
      my ($sr, $dr); # Source row, dest row

      # The statements fetch in order, so use a 'merge' algorithm of advancing
      # after rows match.  This is essentially a FULL OUTER JOIN.
      MERGE:
      while ( 1 ) { # Exit this loop via 'last'

         if ( !$sr ) {
            $sr = $src_sth->fetchrow_hashref;
            if ( $sr ) {
               $rows_in_src += $sr->{__cnt} || 1;
            }
         }
         if ( !$dr ) {
            $dr = $dst_sth->fetchrow_hashref;
            if ( $dr ) {
               $rows_in_dst += $dr->{__cnt} || 1;
            }
         }

         last MERGE unless $sr || $dr;

         # If the current row is the "same row" on both sides...
         if ( $sr && $dr && key_eq($source, $sr, $dr, \@key) ) {
            # The "same" row descends from parents that differ.
            if ( $sr->{__crc} ne $dr->{__crc} ) {
               if ( $level ) {
                  push @bad_parents, $sr;
                  if ( $level && $opts{v} > 2 ) {
                     printf("-- Level %1d UPDATE parent:   %4d\n",
                        $level, $sr->{__par});
                  }
               }
               else {
                  $count{upd}++;
                  $count{bad}++;
                  push @to_update, $sr;
               }
            }
            $sr = $dr = undef;
         }

         # The row in the source doesn't exist at the destination
         elsif ( !$dr || ( $sr && key_le($source, $sr, $dr, \@key) ) ) {
            if ( $level ) {
               push @bulk_insert, $sr;
               if ( $level && $opts{v} > 2 ) {
                  printf("-- Level %1d BULKIN parent:   %4d\n",
                     $level, $sr->{__par});
               }
            }
            else {
               push @to_insert, $sr;
               if ( $level && $opts{v} > 2 ) {
                  printf("-- Level %1d INSERT parent:   %4d\n",
                     $level, $sr->{__par});
               }
            }
            $count{ins} += $sr->{__cnt} || 1;
            $count{bad} += $sr->{__cnt} || 1;
            $sr = undef;
         }

         # Symmetric to the above
         elsif ( !$sr || ( $dr && key_le($source, $dr, $sr, \@key) ) ) {
            if ( $level ) {
               push @bulk_delete, $dr;
               if ( $level && $opts{v} > 2 ) {
                  printf("-- Level %1d BULKDE parent:   %4d\n",
                     $level, $dr->{__par});
               }
            }
            else {
               push @to_delete, $dr;
               if ( $level && $opts{v} > 2 ) {
                  printf("-- Level %1d DELETE parent:   %4d\n",
                     $level, $dr->{__par});
               }
            }
            $count{del} += $dr->{__cnt} || 1;
            $count{bad} += $dr->{__cnt} || 1;
            $dr = undef;
         }

         else {
            die "This code should never have run.  This is a bug.";
         }

         if ( $level < $levels && $opts{m} && $opts{m} < $count{bad} ) {
            print "-- Level $level halt: $count{bad} rows, --maxcost=$opts{m}\n";
            return 0;
         }

      }

      my $sum_bulk_ins = sum(map { $_->{__cnt} } @bulk_insert) || 0;
      my $sum_bulk_del = sum(map { $_->{__cnt} } @bulk_delete) || 0;
      my $sum_parents  = sum(map { $_->{__cnt} || 1 } @bad_parents) || 0;
      my $num_bad_rows = scalar(@to_update) + scalar(@to_insert) + $sum_bulk_ins
                       + scalar(@to_delete) + $sum_bulk_del + $sum_parents;

      if ( $opts{v} ) {
         printf("--         Level %1d total:   %4d rows\n", $level, $num_bad_rows);
      }
      if ( $opts{v} > 1 ) {
         printf("--         Level %1d summary: %4d parents %4d src rows %4d dst rows\n",
            $level, scalar(@bad_parents), $rows_in_src, $rows_in_dst);
         printf("--         Level %1d changes: %4d updates %4d inserts  %4d deletes %4d total\n",
            $level, scalar(@to_update), scalar(@to_insert) + $sum_bulk_ins,
            scalar(@to_delete) + $sum_bulk_del,
            scalar(@to_update) + scalar(@to_insert) + $sum_bulk_ins
               + scalar(@to_delete) + $sum_bulk_del
         );
         printf("--         Level %1d bulk-op: %4d inserts %4d ins-rows %4d deletes %4d del-rows\n",
            $level, scalar(@bulk_insert), $sum_bulk_ins,
            scalar(@bulk_delete), $sum_bulk_del);
      }

      $level--;
   } while ( $level >= 0 && @bad_parents );

   bu_handle_data_change('UPDATE', @to_update);
   bu_handle_data_change('INSERT', @to_insert);
   bu_handle_data_change('DELETE', @to_delete);
   bu_handle_bulk_change('INSERT', $levels, $source, @bulk_insert);
   bu_handle_bulk_change('DELETE', $levels, $dest,   @bulk_delete);

   return 1; # Finished the work.
}

sub bu_cleanup_tree {
   my @servers = @_;
   foreach my $info ( @servers ) {
      my @tables = @{$info->{dbh}->selectcol_arrayref("SHOW TABLES FROM `$info->{database}`")};
      foreach my $table ( grep { m/^$info->{prefix}_\d+$/ } @tables ) {
         my $query = "DROP TABLE IF EXISTS `$info->{database}`.`$table`";
         debug_print($query);
         $info->{dbh}->do($query);
      }
   }
}

# Finds atomic rows that got folded into an entirely insertable or deleteable
# part of the tree.
sub bu_handle_bulk_change {
   my ( $action, $levels, $info, @rows ) = @_;
   return unless $action =~ m/$opts{o}/i;
   my $pk = col_list( @{ $info->{info}->{keys}->{$info->{key}} } );
   my @rows_to_do;
   my $mask = ($opts{B} ** ($levels - 1)) - 1;

   foreach my $row ( @rows ) {

      # TODO: optimization.
      # This is logically correct, but MySQL won't use indexes:
      # "SELECT $pk FROM $info->{prefix}_0 WHERE __rem & $mask = $row->{__par}"
      # This ends up looking like __rem & 255 = 3.  This will match any of the
      # following (partial list):
      # +-------+--------+
      # | __rem | binary |
      # +-------+--------+
      # |     3 |     11 |
      # |    11 |   1011 |
      # |    15 |   1111 |
      # |    19 |  10011 |
      # |    31 |  11111 |
      # |    51 | 110011 |
      # |    59 | 111011 |
      # +-------+--------+
      # Notice the rightmost two bits are the same in each number.  All these
      # combinations can be generated by adding 3 and every number from 4 to the
      # maximum possible __rem value.  This is easiest to do by mentally
      # left-shifting by the appropriate number of digits and adding.  Suppose
      # $levels is such that the maximum __rem is 63; something like
      # $i = 1; while ( $i * 4 < 63 ) { print 3 + $i * 4; $i++; }
      # If the list is really long, it'll be less efficient for MySQL, so I'd
      # say only do this if the list is less than 20% of the number of __rem
      # values.

      my $parent = $row->{__par};
      my $query  = "SELECT $pk FROM $info->{prefix}_0 WHERE __rem & $mask = $parent";
      debug_print($query);
      my $vals = $info->{dbh}->selectall_arrayref($query, { Slice => {} });
      push @rows_to_do, @$vals;
   }

   bu_handle_data_change($action, @rows_to_do);
}

sub bu_handle_data_change {
   my ( $action, @rows ) = @_;
   return unless $action =~ m/$opts{o}/i;
   my $which = $opts{r} ? $source : $dest;
   my $dbh   = $which->{dbh};

   foreach my $row ( @rows ) {
      delete $row->{__crc}; # Now the row can be used as a WHERE clause
      my $crit = make_where_clause($dbh, $row);
      handle_data_change($action, $crit);
   }
}

sub bu_fetch_level {
   my ( $info, $level, @bad_parents ) = @_;
   my $dbh = $info->{dbh};
   my $tbl = "$info->{prefix}_" . $level;

   my $cols  = $level
             ? '__par, __cnt'
             : col_list( @{ $info->{info}->{keys}->{$info->{key}} } );
   my $where = @bad_parents
             ? "WHERE __rem IN(" . join(',', map { $_->{__par} } @bad_parents) . ")"
             : '';
   my $order = $level
             ? '__par'
             : col_list( @{ $info->{info}->{keys}->{$info->{key}} } );

   my $query = "SELECT $cols, __crc FROM $tbl $where ORDER BY $order";
   debug_print($query);
   my $sth = $dbh->prepare($query);
   $sth->execute();
   return $sth;
}

# Returns how many levels of tables you need to build for a table of a given
# size.  If your B factor is 4 and you pass in 100, you need the summaries
# to be grouping mod 64, 16, 4, 1 so you need 4 levels (5 total including 0,
# which is row-for-row with the real table).
sub bu_num_levels {
   my ( $size ) = @_;
   return int( log( $size / $opts{B} ) / log(2) );
}

# Returns the maximum modulus that the tables will need.
sub bu_size_to_type {
   my ( $size ) = @_;
   return $size < 256        ? 'TINYINT'
        : $size < 65536      ? 'SMALLINT'
        : $size < 16777216   ? 'MEDIUMINT'
        : $size < 4294967296 ? 'INT'
        :                      'BIGINT';
}

# Figure out how many levels exist for pre-existing tables.
sub bu_existing_levels {
   my ($info) = @_;
   my @tables = @{$info->{dbh}->selectcol_arrayref("SHOW TABLES FROM `$info->{database}`")};
   @tables    = grep { m/^$info->{prefix}_\d+$/ } @tables;
   die "No existing tables with prefix $info->{prefix} found" unless @tables;
   return max(map { $_ =~ m/(\d+)$/g } @tables);
}

# ############################################################################
# Subroutines
# ############################################################################

# I named this 'le' for clarity about what it does, even though the way it's
# used is in a strict 'lt' sense because key_eq would prevent the code from
# reaching this function.  NULL sorts before defined values in MySQL, so I
# consider undef "less than."
sub key_le {
   my ( $info, $r1, $r2, $key ) = @_;
   foreach my $i ( 0 .. @$key - 1 ) {
      my $l = $r1->{$key->[$i]};
      my $r = $r2->{$key->[$i]};
      my $n = $key->[$i] eq '__par' || $info->{info}->{num_hash}->{$key->[$i]}; # Whether numeric col
      if ( (defined $l && !defined $r)
         || ( defined $l && defined $r && ($n ? $l > $r : $l gt $r) )
      ) {
         return 0;
      }
      elsif ( (!defined $l && defined $r)
         || ( defined $l && defined $r && ($n ? $l < $r : $l lt $r) )
      ) {
         return 1;
      }
   }
   return 1;
}

sub key_eq {
   my ( $info, $r1, $r2, $key ) = @_;
   foreach my $i ( 0 .. @$key - 1 ) {
      my $l = $r1->{$key->[$i]};
      my $r = $r2->{$key->[$i]};
      my $n = $key->[$i] eq '__par' || $info->{info}->{num_hash}->{$key->[$i]}; # Whether numeric col
      my $parity = defined($l) + defined($r);
      if ( $parity == 1 || ( $parity == 2 && ($n ? $l != $r : $l ne $r) )) {
         return 0;
      }
   }
   return 1;
}

# All output has to be prefixed with SQL comments so the output can be piped
# right into MySQL if desired.
sub debug_print {
   print '-- ', @_, "\n" if $opts{b};
}

# Code factored out of bu_handle_data_change and td_handle_data_change.
sub handle_data_change {
   my ( $action, $crit ) = @_;
   my $which = $opts{r} ? $source : $dest;
   my $dbh   = $which->{dbh};

   if ( $action eq 'DELETE' ) {
      my $query = "DELETE FROM $which->{db_tbl} $crit";
      if ( $opts{p} ) {
         print STDOUT $query, ";\n";
      }
      if ( $opts{x} ) {
         $dbh->do($query);
      }
   }

   else {
      my $query = "SELECT $source->{cols} FROM $source->{db_tbl} $crit";
      debug_print($query);
      my $sth = $source->{dbh}->prepare($query);
      $sth->execute();
      while ( my $res = $sth->fetchrow_hashref() ) {
         if ( $opts{s} eq 'r' || $action eq 'INSERT' ) {
            my $verb = $opts{s} eq 'r' ? 'REPLACE' : 'INSERT';
            $query = "$verb INTO $which->{db_tbl}($which->{cols}) VALUES("
               . join(',', map { $dbh->quote($res->{$_}) }
                  @{$which->{info}->{cols}}) . ")";
         }
         else {
            $query = "UPDATE $which->{db_tbl} SET "
               . join(',',
                  map { $dbh->quote_identifier($_) . '=' .  $dbh->quote($res->{$_}) }
                  @{$which->{info}->{cols}});
         }
         if ( $opts{p} ) {
            print STDOUT $query, ";\n";
         }
         if ( $opts{x} ) {
            $dbh->do($query);
         }
      }
   }
}

# Parses a DSN in login:pass@host:port/database.table:key format
sub parse_dsn {
   my ($dsn, $prev, $defs) = @_;
   return unless $dsn;
   $prev ||= {};
   $defs ||= {};

   my ( $user, $pass, $host, $port, $database, $table, $key) = $dsn =~ m{
      (?:
         (.+?)       # Username
         (?::(.+))?  # Optional password
      @)?            # User-pass is optional
      (?:
         (.+?)       # Hostname
         (?::(.+))?  # Optional port
      /)?            # Host-port is optional
      (?:
         (.+?)       # Database
      \.)?           # Database is optional
      ([^:]+)        # Table is required
      (?::
         (.+)        # Key/index
      )?             # Index is optional
      }xsm or return undef;

   return {
      user     => coalesce( $user,     $prev->{user},     $defs->{user} ),
      pass     => coalesce( $pass,     $prev->{pass},     $defs->{pass} ),
      host     => coalesce( $host,     $prev->{host},     $defs->{host} ),
      port     => coalesce( $port,     $prev->{port},     $defs->{port} ),
      database => coalesce( $database, $prev->{database}, $defs->{database} ),
      table    => coalesce( $table,    $prev->{table} ),
      key      => coalesce( $key,      $prev->{key},      $defs->{key} ),
   };
}

sub get_tbl_struct {
   my ( $info ) = @_;
   my $ddl = ($info->{dbh}->selectrow_array("SHOW CREATE TABLE $info->{db_tbl}"))[1];
   my @defs = $ddl =~ m/^(\s+`.*?),?$/gm;
   my @cols = map { $_ =~ m/`([^`]+)`/g } @defs;
   my @nums = map  { $_ =~ m/`([^`]+)`/g }
              grep { $_ =~ m/`[^`]+` (?:(?:tiny|big|medium|small)?int|float|double|decimal)/ } @defs;
   my @null = map { $_ =~ m/`([^`]+)`/g } grep { $_ !~ m/NOT NULL/ } @defs;
   my %keys =
      map {
         my ($name) = $_ =~ m/(PRIMARY|`[^`]*`)/;
         my ($cols) = $_ =~ m/\((.+)\),?$/;
         $name =~ s/`//g;
         ($name, [ grep { m/[^,]/ } split('`', $cols) ])
      }
      $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm;
   my %alldefs;
   @alldefs{@cols} = @defs;

   if ( !exists $keys{$info->{key}} ) {
      die "No such key $info->{key} in table $info->{host}/$info->{db_tbl}";
   }

   return {
      cols      => \@cols,
      col_hash  => { map { $_ => 1 } @cols },
      null      => \@null,
      null_hash => { map { $_ => 1 } @null },
      keys      => \%keys,
      defs      => \%alldefs,
      nums      => \@nums,
      num_hash  => { map { $_ => 1 } @nums },
   };
}

# Get a size estimate (not a precise count because that may be very slow).
# Can't use COUNT(*) because it might be optimized away and so 'rows' could be
# null.  And in tables where there is no NULL column, again it could be
# optimized away, so I must generate a WHERE clause that will defeat this.
sub estimate_size {
   my ($info) = @_;
   my ( $pkcol ) = @{$info->{info}->{keys}->{$info->{key}}};
   my $query = "EXPLAIN SELECT COUNT("
      . join("), COUNT(", split(',', col_list(@{$info->{info}->{cols}})))
      . ") FROM $info->{db_tbl} "
      . "WHERE COALESCE(`$pkcol`, `$pkcol`) = `$pkcol`";
   debug_print($query);
   return $info->{dbh}->selectrow_hashref($query)->{rows};
}

sub round {
   my ($number) = @_;
   return int( $number + .5 );
}

sub make_where_clause {
   my ( $dbh, $where ) = @_;
   my @clauses = map {
      my $val = $where->{$_};
      my $sep = defined $val ? ' = ' : ' IS ';
      $dbh->quote_identifier($_) . $sep . $dbh->quote($val);
   } keys %$where;
   my $clause = @clauses ? 'WHERE ' . join(' AND ', @clauses) : '';
   return $clause;
}

sub make_key {
   my ( $row, $cols ) = @_;
   return join('#', map { defined $row->{$_} ? $row->{$_} : 'NULL' } @$cols);
}

sub get_dbh {
   my ( $conn ) = @_;
   return DBI->connect(
      "DBI:mysql:$conn->{database};host=$conn->{host};port=$conn->{port}",
      $conn->{user}, $conn->{pass},
      { RaiseError => 1, PrintError => 1, AutoCommit => $opts{k} ? 0 : 1 } )
      or die("Can't connect to DB: $OS_ERROR");
}

sub col_list {
   return '`' . join('`,`', @_) . '`';
}

sub coalesce {
   my $i = 0;
   while ( $i < @_ && !defined $_[$i] ) {
      $i++;
   }
   return $_[$i];
}

# ############################################################################
# Documentation
# ############################################################################
=pod

=head1 NAME

mysql-table-sync - Efficiently synchronize data between two MySQL tables.

=head1 DESCRIPTION

Given two MySQL tables already known to be different, and assuming the
differences are moderately small, find and resolve the differences between the
tables.

The DBA must choose the algorithm and parameters to use when reconciling
differences between the tables.  See below for help making this decision.
Different algorithms have more or less network traffic, impact on the servers,
or work better in certain circumstances.  The tool supports a variety of
algorithms so you can resolve the differences as efficiently as possible within
whatever parameters matter to you.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

=head1 OVERVIEW

=head1 OUTPUT

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright (c) 2007 Baron Schwartz, baron at xaprb dot com.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Baron Schwartz, baron at xaprb dot com.

=cut
